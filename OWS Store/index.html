<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdnjs.cloudflare.com; font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com; img-src 'self' data: https: blob:; connect-src 'self' https://owsdatabase.onrender.com https://images.unsplash.com https://ui-avatars.com https://placehold.co https://api.github.com; frame-src https:;">
    <title>OWS Store - Central Studio Hub</title>
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;600;700;800&family=Space+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg: #f4efe6;
            --paper: #fffaf2;
            --surface: #ffffff;
            --ink: #1f1f24;
            --ink-soft: #595a66;
            --line: #d8ccbc;
            --brand: #d14f2a;
            --brand-2: #007f84;
            --text-dim: #595a66;
            --glass: rgba(255, 255, 255, 0.66);
            --glass-border: #d8ccbc;
            --accent-primary: #007f84;
            --accent-secondary: #d14f2a;
            --ok: #1f9d63;
            --warn: #b96700;
            --shadow: 0 16px 38px rgba(35, 27, 21, 0.12);
        }

        body[data-theme="dark"] {
            --bg: #0d1117;
            --paper: #0f1723;
            --surface: #121b2a;
            --ink: #ecf3ff;
            --ink-soft: #97a8c2;
            --line: #233347;
            --brand: #f26e3f;
            --brand-2: #11b6bd;
            --text-dim: #8fa4bf;
            --glass: rgba(20, 30, 45, 0.72);
            --glass-border: #2d4057;
            --accent-primary: #11b6bd;
            --accent-secondary: #f26e3f;
            --ok: #34d399;
            --warn: #f59e0b;
            --shadow: 0 18px 38px rgba(0, 0, 0, 0.34);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Sora', sans-serif;
        }

        body {
            background: radial-gradient(1300px 600px at -10% -20%, #f9d9b1 0%, transparent 45%),
                        radial-gradient(900px 500px at 110% 10%, #bfe8e8 0%, transparent 45%),
                        var(--bg);
            color: var(--ink);
            overflow-x: hidden;
            min-height: 100vh;
        }

        body[data-theme="dark"] {
            background: radial-gradient(1300px 700px at -15% -25%, rgba(39, 93, 130, 0.35) 0%, transparent 50%),
                        radial-gradient(1000px 600px at 120% 8%, rgba(72, 39, 104, 0.35) 0%, transparent 55%),
                        var(--bg);
        }

        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: 100vh;
            gap: 0;
        }

        .sidebar {
            background: linear-gradient(180deg, #fffaf2 0%, #f7eee0 100%);
            border-right: 1px solid var(--line);
            padding: 2rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
        }

        body[data-theme="dark"] .sidebar {
            background: linear-gradient(180deg, #0f1723 0%, #0d1522 100%);
        }

        body[data-theme="dark"] .search-bar,
        body[data-theme="dark"] .app-card,
        body[data-theme="dark"] .stat-box,
        body[data-theme="dark"] .download-item,
        body[data-theme="dark"] .explore-controls,
        body[data-theme="dark"] .download-dock,
        body[data-theme="dark"] .modal-actions {
            background: linear-gradient(180deg, #121b2a 0%, #101827 100%);
            border-color: var(--line);
        }

        body[data-theme="dark"] .spotlight-slider {
            background:
                radial-gradient(420px 170px at 0% 0%, rgba(17, 182, 189, 0.2), transparent 60%),
                radial-gradient(420px 170px at 100% 100%, rgba(242, 110, 63, 0.17), transparent 62%),
                linear-gradient(160deg, #111b2a 0%, #0f1723 100%);
            border-color: #2e4360;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.34);
        }

        body[data-theme="dark"] .spotlight-slider-label {
            color: #8de8ee;
        }

        body[data-theme="dark"] .spotlight-slider-title {
            color: #edf4ff;
        }

        body[data-theme="dark"] .spotlight-slider-text {
            color: #b7c9e2;
        }

        body[data-theme="dark"] .spotlight-slider-dot {
            background: rgba(237, 244, 255, 0.28);
        }

        body[data-theme="dark"] .spotlight-slider-visual {
            border-color: rgba(144, 179, 215, 0.24);
            background: rgba(8, 15, 24, 0.34);
        }

        body[data-theme="dark"] .update-banner {
            background: rgba(13, 20, 32, 0.95);
            border-color: #2e4360;
            box-shadow: 0 14px 35px rgba(0, 0, 0, 0.45);
        }

        body[data-theme="dark"] .download-item-phase {
            background: rgba(17, 182, 189, 0.15);
            color: #8de8ee;
        }

        .sidebar::after {
            content: '';
            position: absolute;
            inset: auto 14px 14px 14px;
            height: 120px;
            border-radius: 18px;
            background: linear-gradient(135deg, rgba(0, 127, 132, 0.08), rgba(209, 79, 42, 0.12));
            pointer-events: none;
        }

        body[data-theme="dark"] .sidebar::after {
            background: linear-gradient(135deg, rgba(17, 182, 189, 0.12), rgba(242, 110, 63, 0.12));
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--ink);
            letter-spacing: -1px;
            display: flex;
            align-items: center;
            gap: 0.7rem;
            min-height: 40px;
        }

        .logo i {
            color: var(--brand);
            min-width: 22px;
            text-align: center;
            transition: color 0.22s ease, transform 0.22s ease;
        }

        .brand-copy {
            display: inline-flex;
            align-items: baseline;
            gap: 0.35rem;
            line-height: 1;
        }

        .brand-prefix {
            color: var(--ink);
            opacity: 0.92;
        }

        .brand-word {
            color: var(--brand);
            letter-spacing: 0.35px;
            min-width: 92px;
            display: inline-block;
            transition: color 0.22s ease, transform 0.22s ease, opacity 0.22s ease;
        }

        .logo.swap i,
        .logo.swap .brand-word {
            transform: translateY(-2px) scale(1.03);
            opacity: 0.88;
        }

        .logo-caption {
            margin-top: -0.6rem;
            margin-bottom: 0.1rem;
            font-size: 0.72rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
            letter-spacing: 0.2px;
            min-height: 16px;
        }

        .nav-menu {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 2;
        }

        .theme-toggle-row {
            margin-top: 0.2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.8rem;
            padding: 0.6rem 0.2rem;
            z-index: 2;
        }

        .theme-toggle-label {
            font-size: 0.72rem;
            font-weight: 800;
            color: var(--ink-soft);
            letter-spacing: 0.4px;
            text-transform: uppercase;
        }

        .theme-switch {
            width: 54px;
            height: 30px;
            border-radius: 999px;
            border: 1px solid var(--line);
            background: #fff;
            position: relative;
            cursor: pointer;
            transition: all 0.22s ease;
        }

        .theme-switch::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffb35c, #f26e3f);
            transition: transform 0.22s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.16);
        }

        .theme-switch.dark {
            background: linear-gradient(90deg, #15263d, #1d334f);
            border-color: #2d4767;
        }

        .theme-switch.dark::before {
            transform: translateX(24px);
            background: linear-gradient(135deg, #11b6bd, #4f46e5);
        }

        .connection-card {
            margin-top: auto;
            padding: 1rem;
            background: var(--glass);
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            gap: 0.42rem;
        }

        .connection-caption {
            font-size: 0.7rem;
            color: var(--text-dim);
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-weight: 700;
        }

        .connection-title {
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 0.45rem;
        }

        .connection-title i {
            color: var(--accent-primary);
        }

        .connection-placeholder-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.32rem;
            width: fit-content;
            border-radius: 999px;
            border: 1px dashed rgba(17, 182, 189, 0.55);
            color: var(--accent-primary);
            background: rgba(17, 182, 189, 0.08);
            padding: 0.22rem 0.56rem;
            font-size: 0.65rem;
            font-weight: 800;
            letter-spacing: 0.35px;
            text-transform: uppercase;
        }

        .connection-placeholder-note {
            font-size: 0.74rem;
            color: var(--ink-soft);
            line-height: 1.45;
        }

        .op-mini-form {
            display: flex;
            flex-direction: column;
            gap: 0.42rem;
            margin-top: 0.25rem;
        }

        .op-mini-input {
            width: 100%;
            border: 1px solid var(--line);
            border-radius: 10px;
            background: var(--surface);
            color: var(--ink);
            padding: 0.42rem 0.55rem;
            font-size: 0.76rem;
            outline: none;
        }

        .op-mini-input:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(17, 182, 189, 0.15);
        }

        .op-mini-actions {
            display: flex;
            gap: 0.35rem;
            flex-wrap: wrap;
            margin-top: 0.12rem;
        }

        .op-mini-btn {
            border: 1px solid var(--line);
            border-radius: 9px;
            background: var(--surface);
            color: var(--ink);
            padding: 0.34rem 0.55rem;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
        }

        .op-mini-btn.primary {
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            border-color: transparent;
            color: #fff;
        }

        .op-mini-btn.warn {
            border-color: rgba(210, 80, 60, 0.45);
            color: #cf5a43;
        }

        .op-mini-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .op-mini-status {
            font-size: 0.69rem;
            color: var(--ink-soft);
            line-height: 1.38;
        }

        .op-mini-user {
            font-size: 0.74rem;
            font-weight: 800;
            color: var(--ink);
            display: none;
        }

        .op-mini-balance {
            font-size: 0.72rem;
            color: var(--ink-soft);
            display: none;
        }

        .op-mini-currencies {
            display: none;
            margin-top: 0.28rem;
            grid-template-columns: 1fr 1fr;
            gap: 0.3rem;
            max-height: 148px;
            overflow-y: auto;
            padding-right: 0.1rem;
        }

        .op-mini-currency-chip {
            border: 1px solid var(--line);
            border-radius: 8px;
            background: var(--surface);
            padding: 0.28rem 0.38rem;
            min-width: 0;
        }

        .op-mini-currency-chip .label {
            display: block;
            font-size: 0.62rem;
            color: var(--ink-soft);
            line-height: 1.15;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .op-mini-currency-chip .value {
            display: block;
            margin-top: 0.08rem;
            font-size: 0.69rem;
            color: var(--ink);
            font-weight: 800;
            font-family: 'Space Mono', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .op-mini-currencies-more {
            grid-column: 1 / -1;
            font-size: 0.62rem;
            color: var(--ink-soft);
            text-align: right;
            padding-right: 0.05rem;
        }

        .download-dock {
            margin-top: 0.5rem;
            border: 1px solid var(--line);
            border-radius: 14px;
            background: linear-gradient(180deg, #fff 0%, #f7efe3 100%);
            padding: 0.65rem;
            display: none;
            flex-direction: column;
            gap: 0.55rem;
            position: relative;
            z-index: 2;
        }

        .download-dock.visible {
            display: flex;
            animation: dockSlideIn 0.22s ease;
        }

        .download-dock-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.68rem;
            color: var(--ink-soft);
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-weight: 800;
        }

        .download-dock-count {
            background: var(--brand-2);
            color: #fff;
            border-radius: 999px;
            padding: 0.08rem 0.44rem;
            font-size: 0.65rem;
            font-family: 'Space Mono', monospace;
        }

        .download-dock-body {
            display: flex;
            gap: 0.55rem;
            align-items: center;
        }

        .download-dock-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            object-fit: cover;
            border: 1px solid #dfd2c2;
            background: #fff;
            flex-shrink: 0;
        }

        .download-dock-info {
            min-width: 0;
            flex: 1;
        }

        .download-dock-title {
            font-size: 0.77rem;
            font-weight: 800;
            color: var(--ink);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-dock-status {
            margin-top: 0.08rem;
            font-size: 0.67rem;
            color: var(--ink-soft);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-dock-progress {
            margin-top: 0.3rem;
            height: 5px;
            background: #e9ddcf;
            border-radius: 99px;
            overflow: hidden;
        }

        .download-dock-progress-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            border-radius: 99px;
            transition: width 0.2s ease;
        }

        .download-dock-loader {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(0, 127, 132, 0.2);
            border-top-color: var(--brand-2);
            border-radius: 50%;
            animation: spinLoop 1s linear infinite;
            margin-left: auto;
            flex-shrink: 0;
            display: none;
        }

        .download-dock-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.3rem;
        }

        .download-dock-btn {
            width: 24px;
            height: 24px;
            border-radius: 8px;
            border: 1px solid #dccfbf;
            background: #fff;
            color: var(--ink-soft);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.68rem;
        }

        .download-dock-btn:hover {
            color: var(--ink);
            background: #f6efe3;
        }

        .download-dock-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .download-dock-index {
            font-size: 0.64rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
        }

        @keyframes dockSlideIn {
            from { opacity: 0; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .nav-item {
            padding: 0.9rem 1rem;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            color: var(--ink-soft);
            font-weight: 700;
            border: 1px solid transparent;
            background: transparent;
        }

        .nav-item i {
            font-size: 1.1rem;
        }

        .nav-item:hover,
        .nav-item.active {
            background: #fff;
            color: var(--ink);
            border-color: var(--line);
            transform: translateX(4px);
            box-shadow: 0 6px 18px rgba(25, 20, 15, 0.08);
        }

        .main-content {
            padding: 2rem 2.2rem 3rem;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            gap: 1rem;
        }

        .search-bar {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: 16px;
            padding: 0.9rem 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            width: min(100%, 480px);
            box-shadow: var(--shadow);
        }

        .search-bar i {
            color: var(--brand-2);
        }

        .search-bar input {
            background: transparent;
            border: none;
            color: var(--ink);
            outline: none;
            width: 100%;
            font-weight: 600;
        }

        .featured-hero {
            width: 100%;
            height: 420px;
            border-radius: 28px;
            overflow: hidden;
            position: relative;
            margin-bottom: 2.3rem;
            background: #000;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.35);
        }

        .hero-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.85;
            transform: scale(1.03);
        }

        .hero-content {
            position: absolute;
            inset: auto 0 0 0;
            padding: 2.5rem;
            background: linear-gradient(180deg, transparent 0%, rgba(25, 20, 16, 0.82) 45%, rgba(25, 20, 16, 0.95) 100%);
            color: #f7f0e7;
        }

        .hero-tag {
            background: #ffd9c7;
            color: #7a2b10;
            padding: 0.35rem 0.7rem;
            border-radius: 999px;
            font-size: 0.72rem;
            font-weight: 800;
            text-transform: uppercase;
            margin-bottom: 0.9rem;
            display: inline-block;
            letter-spacing: 0.5px;
        }

        .hero-title {
            font-size: clamp(2rem, 5vw, 3.3rem);
            font-weight: 800;
            margin-bottom: 0.5rem;
            letter-spacing: -1.5px;
            line-height: 1.02;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 800;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            letter-spacing: -0.3px;
        }

        .explore-shell {
            display: flex;
            flex-direction: column;
            gap: 1.15rem;
            margin-bottom: 0.8rem;
        }

        .explore-spotlight {
            background:
                radial-gradient(600px 200px at 0% 0%, rgba(0, 127, 132, 0.2), transparent 55%),
                radial-gradient(600px 200px at 100% 100%, rgba(209, 79, 42, 0.22), transparent 55%),
                linear-gradient(145deg, #1f2026 0%, #2a2d39 50%, #18242b 100%);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #f2f5fa;
            padding: 1.3rem;
            display: grid;
            grid-template-columns: 1.4fr 1fr;
            gap: 1rem;
            box-shadow: 0 20px 42px rgba(18, 18, 24, 0.35);
        }

        .spotlight-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            background: rgba(255, 255, 255, 0.14);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 999px;
            padding: 0.25rem 0.65rem;
            font-size: 0.66rem;
            font-weight: 700;
            margin-bottom: 0.7rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .spotlight-title {
            font-size: clamp(1.7rem, 3.3vw, 2.5rem);
            font-weight: 800;
            line-height: 1.05;
            margin-bottom: 0.6rem;
            letter-spacing: -1px;
        }

        .spotlight-subtitle {
            color: rgba(242, 245, 250, 0.82);
            font-size: 0.94rem;
            line-height: 1.55;
            max-width: 620px;
            margin-bottom: 0.9rem;
        }

        .spotlight-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.55rem;
            margin-bottom: 0.95rem;
        }

        .btn-hero-secondary {
            border: 1px solid rgba(255, 255, 255, 0.28);
            background: rgba(255, 255, 255, 0.06);
            color: #f2f5fa;
        }

        .btn-hero-secondary:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .spotlight-metrics {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 0.55rem;
        }

        .spotlight-metric {
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.58rem 0.62rem;
        }

        .spotlight-metric-value {
            font-size: 1rem;
            font-weight: 800;
            color: #f9fbff;
            line-height: 1;
        }

        .spotlight-metric-label {
            margin-top: 0.25rem;
            font-size: 0.65rem;
            color: rgba(242, 245, 250, 0.72);
            text-transform: uppercase;
            letter-spacing: 0.45px;
        }

        .spotlight-side {
            display: flex;
            flex-direction: column;
            gap: 0.65rem;
        }

        .spotlight-panel {
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 14px;
            background: rgba(0, 0, 0, 0.24);
            padding: 0.72rem 0.75rem;
        }

        .spotlight-panel-title {
            font-size: 0.72rem;
            color: rgba(242, 245, 250, 0.72);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.45rem;
        }

        .spotlight-list {
            display: flex;
            flex-direction: column;
            gap: 0.42rem;
        }

        .spotlight-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.77rem;
            color: #eff2f8;
        }

        .spotlight-list-item span:last-child {
            color: rgba(242, 245, 250, 0.72);
            font-family: 'Space Mono', monospace;
            font-size: 0.66rem;
        }

        .news-hub-board {
            border: 1px solid var(--line);
            border-radius: 16px;
            background: linear-gradient(180deg, #fff 0%, #f7efe3 100%);
            padding: 0.95rem;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.85rem;
            margin-bottom: 0.95rem;
        }

        body[data-theme="dark"] .news-hub-board {
            background: linear-gradient(180deg, #121b2a 0%, #101827 100%);
            border-color: var(--line);
        }

        .news-hub-col {
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.42rem;
        }

        .news-hub-col-title {
            font-size: 0.7rem;
            font-weight: 800;
            letter-spacing: 0.45px;
            text-transform: uppercase;
            color: var(--ink-soft);
        }

        .news-hub-list {
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
        }

        .news-hub-item {
            border: 1px solid var(--line);
            border-radius: 11px;
            background: var(--surface);
            padding: 0.52rem 0.6rem;
        }

        .news-hub-item-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.45rem;
        }

        .news-hub-item-title {
            font-size: 0.78rem;
            font-weight: 800;
            color: var(--ink);
            line-height: 1.28;
        }

        .news-hub-item-date {
            font-size: 0.66rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
            white-space: nowrap;
        }

        .news-hub-item-meta {
            margin-top: 0.25rem;
            font-size: 0.72rem;
            color: var(--ink-soft);
            line-height: 1.4;
        }

        .spotlight-slider {
            position: relative;
            overflow: hidden;
            border-radius: 18px;
            border: 1px solid rgba(0, 127, 132, 0.2);
            background:
                radial-gradient(420px 170px at 0% 0%, rgba(0, 127, 132, 0.16), transparent 60%),
                radial-gradient(420px 170px at 100% 100%, rgba(209, 79, 42, 0.15), transparent 62%),
                linear-gradient(160deg, #fffaf2 0%, #f4ebe0 100%);
            padding: 0.95rem 1rem;
            box-shadow: 0 12px 24px rgba(23, 20, 16, 0.1);
            transition: opacity 0.22s ease, transform 0.22s ease;
        }

        .spotlight-slider.swap {
            animation: spotlightSlideSwap 0.26s ease;
        }

        .spotlight-slider-label {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.66rem;
            font-weight: 800;
            letter-spacing: 0.45px;
            text-transform: uppercase;
            color: var(--brand-2);
            margin-bottom: 0.3rem;
        }

        .spotlight-slider-title {
            font-size: 1.08rem;
            font-weight: 800;
            letter-spacing: -0.35px;
            color: var(--ink);
            margin-bottom: 0.24rem;
        }

        .spotlight-slider-text {
            color: var(--ink-soft);
            font-size: 0.84rem;
            line-height: 1.48;
            margin-bottom: 0.62rem;
        }

        .spotlight-slider-visual {
            width: 100%;
            height: 116px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(15, 19, 31, 0.08);
            background: rgba(255, 255, 255, 0.46);
            margin-bottom: 0.62rem;
        }

        .spotlight-slider-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .spotlight-slider-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.55rem;
            flex-wrap: wrap;
        }

        .spotlight-slider-btn {
            width: auto;
            padding: 0.62rem 0.92rem;
            font-size: 0.74rem;
            border-radius: 10px;
        }

        .spotlight-slider-dots {
            display: inline-flex;
            align-items: center;
            gap: 0.38rem;
        }

        .spotlight-slider-dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            border: none;
            background: rgba(15, 19, 31, 0.18);
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0;
        }

        .spotlight-slider-dot.active {
            width: 19px;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
        }

        .explore-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 0.65rem;
            background: #fff8ee;
            border: 1px solid var(--line);
            border-radius: 16px;
            padding: 0.7rem 0.8rem;
        }

        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .filter-chip {
            border: 1px solid #d9ccbd;
            border-radius: 999px;
            padding: 0.32rem 0.72rem;
            background: #fff;
            color: var(--ink-soft);
            font-size: 0.72rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.18s ease;
        }

        .filter-chip:hover,
        .filter-chip.active {
            color: #fff;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            border-color: transparent;
        }

        .explore-note {
            font-size: 0.72rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
        }

        .project-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 3rem;
        }

        .ecosystem-list {
            display: flex;
            flex-direction: column;
            gap: 0.78rem;
            margin-bottom: 2.2rem;
        }

        .ecosystem-row {
            display: grid;
            grid-template-columns: 86px minmax(0, 1fr) auto;
            align-items: center;
            gap: 0.9rem;
            padding: 0.85rem 0.95rem;
            border-radius: 16px;
        }

        .ecosystem-row .app-icon {
            width: 74px;
            height: 74px;
            border-radius: 16px;
            margin-bottom: 0;
        }

        .ecosystem-main {
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .ecosystem-topline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.6rem;
        }

        .ecosystem-topline .app-name {
            margin-bottom: 0;
        }

        .ecosystem-title-wrap {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            flex-wrap: wrap;
        }

        .ecosystem-platform {
            font-size: 0.65rem;
            border-radius: 999px;
            padding: 0.2rem 0.5rem;
            text-transform: uppercase;
            font-weight: 800;
            letter-spacing: 0.45px;
            background: rgba(0, 127, 132, 0.11);
            color: var(--accent-primary);
            border: 1px solid rgba(0, 127, 132, 0.26);
            white-space: nowrap;
        }

        .new-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 999px;
            border: 1px solid rgba(245, 158, 11, 0.45);
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(251, 113, 133, 0.2));
            color: #8a4300;
            font-size: 0.62rem;
            font-weight: 900;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            padding: 0.14rem 0.46rem;
            line-height: 1;
            box-shadow: 0 3px 10px rgba(245, 158, 11, 0.2);
        }

        body[data-theme="dark"] .new-badge {
            color: #ffd58a;
            border-color: rgba(245, 158, 11, 0.5);
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.25), rgba(244, 63, 94, 0.28));
            box-shadow: 0 4px 14px rgba(245, 158, 11, 0.26);
        }

        .ecosystem-submeta {
            font-size: 0.72rem;
            color: var(--ink-soft);
            line-height: 1.35;
        }

        .ecosystem-open-btn {
            width: auto;
            min-width: 130px;
            padding: 0.66rem 0.95rem;
            border-radius: 11px;
            font-size: 0.82rem;
            white-space: nowrap;
        }

        .app-card {
            background: linear-gradient(180deg, #fff 0%, #fffaf5 100%);
            border: 1px solid var(--line);
            border-radius: 18px;
            padding: 1.1rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(35, 27, 21, 0.08);
            animation: cardIn 0.45s ease both;
        }

        .app-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .app-card:hover {
            transform: translateY(-6px);
            border-color: #c6b29b;
            box-shadow: 0 16px 34px rgba(35, 27, 21, 0.16);
        }

        .app-card:hover::before {
            opacity: 1;
        }

        .app-icon {
            width: 62px;
            height: 62px;
            border-radius: 14px;
            background: #f6efe7;
            margin-bottom: 0.9rem;
            object-fit: cover;
            border: 1px solid #e6d9ca;
        }

        .app-name {
            font-size: 1.14rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
            color: var(--ink);
        }

        .app-meta {
            color: var(--ink-soft);
            font-size: 0.82rem;
            margin-bottom: 0.4rem;
            display: flex;
            justify-content: space-between;
            font-family: 'Space Mono', monospace;
        }

        .btn-install {
            width: 100%;
            padding: 0.78rem;
            border-radius: 12px;
            border: 0;
            background: linear-gradient(90deg, var(--brand), #e57b22);
            color: #fff;
            font-weight: 800;
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.45rem;
        }

        .btn-install:hover {
            filter: brightness(1.04);
            transform: translateY(-1px);
        }

        .btn-install.unavailable {
            background: #ece3d7;
            color: #888;
            cursor: not-allowed;
        }

        body[data-theme="dark"] .btn-install.unavailable {
            background: #263243;
            color: #8ca0bc;
        }

        .btn-install.coming-soon {
            background: transparent;
            border: 1px solid var(--warn);
            color: var(--warn);
        }

        .library-actions {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.45rem;
        }

        .library-actions .full {
            grid-column: 1 / -1;
        }

        .library-actions .btn-install {
            min-width: 0;
            font-size: 0.93rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0.7rem 0.6rem;
        }

        .progress-overlay {
            position: absolute;
            inset: 0;
            background: rgba(247, 238, 228, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            z-index: 10;
            color: #473326;
            backdrop-filter: blur(2px);
        }

        body[data-theme="dark"] .progress-overlay {
            background: rgba(14, 23, 36, 0.92);
            color: #d9e6fb;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: #e9ddcf;
            border-radius: 4px;
            margin-top: 0.7rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            width: 0%;
            transition: width 0.25s;
        }

        #game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
            display: none;
            flex-direction: column;
            animation: appScaleIn 0.25s ease;
        }

        #game-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: #000;
        }

        .game-controls {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 10000;
            display: flex;
            gap: 8px;
            opacity: 0.9;
            transition: opacity 0.2s;
        }

        .game-controls:hover {
            opacity: 1;
        }

        .btn-close-game {
            background: rgba(33, 35, 42, 0.86);
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: #fff;
            padding: 0.6rem 0.9rem;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-close-game:hover {
            background: #c63f24;
        }

        @keyframes appScaleIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes cardIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .no-scroll {
            overflow: hidden !important;
        }

        #details-modal {
            position: fixed;
            top: 0;
            right: -100%;
            width: 470px;
            height: 100vh;
            background: linear-gradient(180deg, #fffaf2 0%, #f7eee0 100%);
            border-left: 1px solid var(--line);
            z-index: 5000;
            transition: right 0.35s ease;
            display: flex;
            flex-direction: column;
            box-shadow: -18px 0 40px rgba(30, 23, 18, 0.15);
        }

        #details-modal.active {
            right: 0;
        }

        .modal-banner {
            width: 100%;
            height: 210px;
            background-size: cover;
            background-position: center;
            position: relative;
        }

        .modal-banner::after {
            content: '';
            position: absolute;
            inset: auto 0 0;
            height: 72px;
            background: linear-gradient(180deg, transparent, #f7eee0);
        }

        .modal-header {
            padding: 0 1.6rem;
            margin-top: -44px;
            position: relative;
            z-index: 1;
            display: flex;
            align-items: flex-end;
            gap: 1rem;
            margin-bottom: 1.4rem;
        }

        .modal-icon-large {
            width: 118px;
            height: 118px;
            border-radius: 24px;
            background: #fff;
            border: 3px solid #f7eee0;
            box-shadow: 0 10px 25px rgba(30, 24, 18, 0.18);
            object-fit: cover;
        }

        .modal-title-area { padding-bottom: 16px; }
        .modal-title { font-size: 1.8rem; font-weight: 800; line-height: 1.02; }
        .modal-dev {
            color: var(--brand-2);
            font-size: 0.78rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 4px;
        }

        .modal-body {
            padding: 1.6rem;
            flex: 1;
            overflow-y: auto;
        }

        .modal-description {
            color: var(--ink-soft);
            line-height: 1.58;
            margin-bottom: 1.4rem;
            font-size: 0.93rem;
        }

        .modal-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }

        .modal-platforms {
            margin-bottom: 1.1rem;
        }

        .modal-platform-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.55rem;
            margin-top: 0.55rem;
        }

        .platform-pill {
            border: 1px solid var(--line);
            background: #fff;
            color: var(--ink);
            border-radius: 999px;
            padding: 0.42rem 0.78rem;
            font-size: 0.72rem;
            font-weight: 700;
            letter-spacing: 0.2px;
            cursor: pointer;
            transition: all 0.18s ease;
        }

        .platform-pill.active {
            background: linear-gradient(90deg, var(--brand-2), #2aa0a6);
            border-color: transparent;
            color: #fff;
            box-shadow: 0 6px 16px rgba(0, 127, 132, 0.26);
        }

        .platform-pill.is-disabled {
            opacity: 0.58;
        }

        .platform-pill:hover {
            transform: translateY(-1px);
        }

        .modal-platform-meta {
            margin-top: 0.55rem;
            color: var(--ink-soft);
            font-size: 0.8rem;
        }

        .modal-news-wrap {
            margin-bottom: 1rem;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.7rem;
        }

        .modal-news-card {
            border: 1px solid var(--line);
            border-radius: 12px;
            background: var(--surface);
            padding: 0.65rem;
            min-height: 116px;
        }

        .modal-news-title {
            font-size: 0.68rem;
            color: var(--ink-soft);
            text-transform: uppercase;
            letter-spacing: 0.42px;
            font-weight: 800;
            margin-bottom: 0.48rem;
        }

        .modal-news-list {
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
        }

        .modal-news-item {
            border: 1px solid var(--line);
            border-radius: 9px;
            background: var(--paper);
            padding: 0.45rem 0.52rem;
        }

        .modal-news-item strong {
            display: block;
            font-size: 0.73rem;
            color: var(--ink);
            margin-bottom: 0.15rem;
            line-height: 1.25;
        }

        .modal-news-item span {
            display: block;
            font-size: 0.68rem;
            color: var(--ink-soft);
            line-height: 1.34;
        }

        .modal-news-empty {
            color: var(--ink-soft);
            font-size: 0.73rem;
            line-height: 1.35;
        }

        .stat-box {
            background: #fff;
            padding: 0.9rem;
            border-radius: 12px;
            border: 1px solid var(--line);
        }

        .stat-label {
            font-size: 0.68rem;
            color: var(--ink-soft);
            text-transform: uppercase;
            margin-bottom: 4px;
            letter-spacing: 0.6px;
        }

        .stat-value { font-weight: 700; font-size: 0.88rem; }

        .modal-actions {
            padding: 1.2rem 1.6rem 1.6rem;
            background: rgba(255, 250, 242, 0.92);
            border-top: 1px solid var(--line);
            position: relative;
        }

        .modal-recommend-bubble {
            position: relative;
            margin-bottom: 0.68rem;
            background: linear-gradient(145deg, #1f2026 0%, #2a2d39 55%, #18333b 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #f2f5fa;
            padding: 0.68rem 0.74rem;
            box-shadow: 0 12px 24px rgba(15, 17, 24, 0.24);
        }

        .modal-recommend-bubble::after {
            content: '';
            position: absolute;
            left: 46px;
            bottom: -8px;
            width: 14px;
            height: 14px;
            background: #25313a;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            transform: rotate(45deg);
        }

        .modal-recommend-bubble strong {
            display: block;
            font-size: 0.78rem;
            margin-bottom: 0.18rem;
            letter-spacing: 0.3px;
        }

        .modal-recommend-bubble span {
            display: block;
            font-size: 0.74rem;
            line-height: 1.42;
            color: rgba(242, 245, 250, 0.82);
        }

        .btn-close-modal {
            position: absolute;
            top: 14px;
            right: 14px;
            background: rgba(0, 0, 0, 0.38);
            border: none;
            color: white;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
        }

        .update-banner {
            display: none;
            position: fixed;
            bottom: 18px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 4000;
            background: linear-gradient(180deg, #fffdf8 0%, #fff6eb 100%);
            border: 1px solid #d8ccbc;
            border-radius: 18px;
            padding: 0.85rem 0.95rem;
            box-shadow: 0 18px 36px rgba(35, 27, 21, 0.24);
            align-items: center;
            gap: 0.75rem;
            min-width: 360px;
            max-width: min(92vw, 820px);
        }

        .update-banner::before {
            content: '';
            position: absolute;
            inset: 0 auto 0 0;
            width: 5px;
            border-radius: 18px 0 0 18px;
            background: linear-gradient(180deg, #007f84, #d14f2a);
        }

        .update-banner.visible {
            display: flex;
            animation: bannerPop 0.24s ease;
        }

        .update-banner.state-checking::before { background: linear-gradient(180deg, #007f84, #4baeb2); }
        .update-banner.state-available::before { background: linear-gradient(180deg, #d14f2a, #f08b33); }
        .update-banner.state-downloading::before { background: linear-gradient(180deg, #007f84, #d14f2a); }
        .update-banner.state-ready::before { background: linear-gradient(180deg, #1f9d63, #53c18b); }
        .update-banner.state-success::before { background: linear-gradient(180deg, #1f9d63, #53c18b); }
        .update-banner.state-error::before { background: linear-gradient(180deg, #c0392b, #ea6b5d); }
        .update-banner.state-info::before { background: linear-gradient(180deg, #6f7280, #979aa8); }

        .update-banner .update-icon {
            width: 42px;
            height: 42px;
            background: linear-gradient(140deg, rgba(0, 127, 132, 0.15), rgba(209, 79, 42, 0.18));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            color: #2c3d43;
            border: 1px solid rgba(0, 0, 0, 0.06);
            flex-shrink: 0;
        }

        .update-banner .update-icon i.spin {
            animation: spinLoop 1s linear infinite;
        }

        .update-banner .update-text {
            flex: 1;
            min-width: 0;
        }

        .update-banner .update-text strong {
            display: block;
            margin-bottom: 0.12rem;
            font-size: 0.9rem;
            color: #1f1f24;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .update-banner .update-text span {
            color: #5f6270;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
        }

        .update-banner .update-meta {
            color: #666978;
            font-size: 0.7rem;
            margin-top: 0.2rem;
            font-family: 'Space Mono', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .update-banner .update-progress {
            width: 132px;
            height: 7px;
            background: #eadfce;
            border-radius: 99px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .update-banner .update-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            width: 0%;
            transition: width 0.2s;
            border-radius: 99px;
        }

        .update-banner .btn-update {
            padding: 0.55rem 0.95rem;
            border-radius: 10px;
            border: none;
            background: #23242a;
            color: #fff;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.35rem;
            transition: opacity 0.2s;
            white-space: nowrap;
        }

        .update-banner .btn-close-update {
            width: 32px;
            height: 32px;
            border-radius: 10px;
            border: 1px solid #d8ccbc;
            background: #fff;
            color: #5f6270;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.18s ease;
            flex-shrink: 0;
        }

        .update-banner .btn-close-update:hover {
            background: #f4ede3;
            color: #2a2b31;
        }

        .update-banner .btn-update:hover { opacity: 0.92; }
        .update-banner .btn-update:disabled { opacity: 0.6; cursor: not-allowed; }

        @keyframes bannerPop {
            from { opacity: 0; transform: translateX(-50%) translateY(8px) scale(0.985); }
            to { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
        }

        @keyframes spinLoop {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .update-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 9px;
            height: 9px;
            background: var(--brand);
            border-radius: 50%;
            box-shadow: 0 0 0 6px rgba(209, 79, 42, 0.12);
            animation: pulse-dot 1.8s infinite;
        }

        .downloads-activity {
            display: flex;
            flex-direction: column;
            gap: 0.72rem;
            margin-bottom: 1rem;
        }

        .info-note-card {
            background: #fff;
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 0.7rem 0.85rem;
            color: var(--ink-soft);
        }

        .project-update-card {
            background: #fff;
            border: 1px solid var(--line);
            border-left: 4px solid var(--brand-2);
            border-radius: 10px;
            padding: 0.7rem 0.85rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.6rem;
        }

        .project-update-title {
            font-weight: 800;
            color: var(--ink);
        }

        .project-update-meta {
            font-size: 0.8rem;
            color: var(--ink-soft);
        }

        .project-update-platforms {
            display: grid;
            gap: 0.35rem;
            margin-top: 0.5rem;
        }

        .project-update-platform-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.55rem;
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 0.35rem 0.5rem;
            background: #fcfaf7;
        }

        .project-update-platform-label {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.72rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--ink);
        }

        .project-update-platform-label .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--brand-2);
        }

        .project-update-platform-status {
            font-size: 0.75rem;
            color: var(--ink-soft);
            text-align: right;
        }

        .project-update-platform-row.is-target {
            border-color: #4ab9c0;
            background: rgba(74, 185, 192, 0.08);
        }

        .project-update-platform-row.is-updating {
            border-color: #1f9d63;
            background: rgba(31, 157, 99, 0.08);
        }

        .project-update-platform-row.is-unavailable {
            opacity: 0.72;
        }

        .notification-card {
            --tone-color: var(--brand-2);
            background: #fff;
            border: 1px solid var(--line);
            border-left: 4px solid var(--tone-color);
            border-radius: 10px;
            padding: 0.7rem 0.85rem;
        }

        .notification-time {
            font-size: 0.82rem;
            color: var(--ink-soft);
        }

        .notification-text {
            font-weight: 700;
            margin-top: 0.15rem;
            color: var(--ink);
        }

        .android-release-meta {
            font-size: 0.75rem;
            color: var(--ink-soft);
            line-height: 1.35;
        }

        body[data-theme="dark"] .info-note-card,
        body[data-theme="dark"] .project-update-card,
        body[data-theme="dark"] .notification-card {
            background: linear-gradient(180deg, #121b2a 0%, #101827 100%);
            border-color: var(--line);
        }

        body[data-theme="dark"] .project-update-platform-row {
            background: rgba(10, 18, 30, 0.78);
            border-color: #213148;
        }

        body[data-theme="dark"] .project-update-platform-row.is-target {
            background: rgba(62, 126, 153, 0.2);
            border-color: #3d89a7;
        }

        body[data-theme="dark"] .project-update-platform-row.is-updating {
            background: rgba(31, 157, 99, 0.2);
            border-color: #24865e;
        }

        .download-item {
            border: 1px solid var(--line);
            border-radius: 14px;
            background: #fff;
            padding: 0.72rem;
            display: flex;
            align-items: center;
            gap: 0.72rem;
            box-shadow: 0 8px 20px rgba(35, 27, 21, 0.08);
            transition: transform 0.16s ease, border-color 0.16s ease;
        }

        .download-item:hover {
            transform: translateY(-2px);
            border-color: #c9b9a5;
        }

        .download-item .avatar {
            width: 42px;
            height: 42px;
            border-radius: 11px;
            object-fit: cover;
            border: 1px solid #dfd2c2;
            background: #fff;
            flex-shrink: 0;
        }

        .download-item-main {
            flex: 1;
            min-width: 0;
        }

        .download-item-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .download-item-title {
            font-size: 0.9rem;
            font-weight: 800;
            color: var(--ink);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-item-phase {
            font-size: 0.67rem;
            border-radius: 999px;
            padding: 0.18rem 0.52rem;
            background: #f2e5d7;
            color: #7f4c1f;
            text-transform: uppercase;
            font-weight: 800;
            letter-spacing: 0.4px;
            flex-shrink: 0;
        }

        .download-item-meta {
            font-size: 0.7rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
            margin-bottom: 0.34rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-item-progress-wrap {
            height: 6px;
            background: #eadfce;
            border-radius: 999px;
            overflow: hidden;
            opacity: 0;
            max-height: 0;
            transition: opacity 0.18s ease, max-height 0.22s ease;
        }

        .download-item-progress-wrap.show {
            opacity: 1;
            max-height: 8px;
        }

        .download-item-progress {
            width: 0%;
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            transition: width 0.2s ease;
        }

        .download-item-loader {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(0, 127, 132, 0.22);
            border-top-color: var(--brand-2);
            animation: spinLoop 1s linear infinite;
            display: none;
            flex-shrink: 0;
        }

        .download-item.preparing .download-item-loader,
        .download-item.queued .download-item-loader,
        .download-item.waiting .download-item-loader {
            display: block;
        }

        .download-item.downloading .download-item-progress-wrap {
            opacity: 1;
            max-height: 8px;
        }

        .download-item.ready .download-item-phase,
        .download-item.done .download-item-phase {
            background: #d9f3e7;
            color: #1f7b52;
        }

        .download-item.error .download-item-phase {
            background: #f8ddd9;
            color: #a63a2e;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.45; transform: scale(1.2); }
        }

        @media (max-width: 1120px) {
            .app-container {
                grid-template-columns: 1fr;
                height: auto;
                min-height: 100vh;
            }
            .sidebar {
                border-right: none;
                border-bottom: 1px solid var(--line);
                padding: 0.95rem;
                gap: 0.75rem;
                position: sticky;
                top: 0;
                z-index: 35;
                backdrop-filter: blur(16px);
                background: rgba(255, 250, 242, 0.92);
                background: color-mix(in srgb, var(--paper) 82%, transparent);
            }
            body[data-theme="dark"] .sidebar {
                background: rgba(15, 23, 35, 0.92);
                background: color-mix(in srgb, #0f1723 84%, transparent);
            }
            .sidebar::after { display: none; }
            .nav-menu { flex-direction: row; flex-wrap: wrap; gap: 0.42rem; }
            .nav-item {
                flex: 1 1 calc(33% - 0.5rem);
                justify-content: center;
                padding: 0.72rem 0.75rem;
                border-radius: 12px;
            }
            .main-content { padding: 1.15rem 1rem 6.2rem; }
            .header { flex-direction: column; align-items: stretch; }
            .search-bar { width: 100%; }
            .featured-hero { height: 350px; }
            #details-modal { width: 100%; }
            .explore-spotlight { grid-template-columns: 1fr; }
            .explore-shell {
                gap: 0.85rem;
            }
            .news-hub-board,
            .modal-news-wrap {
                grid-template-columns: 1fr;
            }
            .connection-card,
            .download-dock {
                border-radius: 14px;
                box-shadow: 0 8px 24px rgba(20, 18, 14, 0.1);
            }
        }

        @media (max-width: 720px) {
            body {
                padding-bottom: calc(88px + env(safe-area-inset-bottom));
            }
            .app-container {
                min-height: 100dvh;
                display: block;
            }
            .sidebar {
                padding: 0.72rem 0.72rem 0.6rem;
                gap: 0.55rem;
                border-radius: 0 0 18px 18px;
                border-bottom: 1px solid var(--line);
                box-shadow: 0 10px 28px rgba(20, 16, 13, 0.14);
            }
            .logo {
                font-size: 1.16rem;
                gap: 0.46rem;
            }
            .brand-word {
                min-width: 68px;
            }
            .logo-caption {
                display: block;
                font-size: 0.62rem;
                margin-top: -0.42rem;
                margin-bottom: 0.12rem;
            }
            .nav-menu {
                position: fixed;
                left: 10px;
                right: 10px;
                bottom: calc(8px + env(safe-area-inset-bottom));
                z-index: 120;
                display: grid;
                grid-template-columns: repeat(3, minmax(0, 1fr));
                gap: 0.35rem;
                padding: 0.34rem;
                border-radius: 18px;
                border: 1px solid var(--line);
                background: rgba(255, 250, 242, 0.93);
                background: color-mix(in srgb, var(--paper) 87%, transparent);
                backdrop-filter: blur(18px);
                box-shadow: 0 16px 32px rgba(22, 17, 14, 0.2);
            }
            body[data-theme="dark"] .nav-menu {
                background: rgba(14, 22, 34, 0.93);
                background: color-mix(in srgb, #0e1622 88%, transparent);
                border-color: #2f4259;
                box-shadow: 0 20px 42px rgba(0, 0, 0, 0.48);
            }
            .nav-item {
                position: relative;
                min-width: 0;
                padding: 0.54rem 0.34rem;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                gap: 0.28rem;
                font-size: 0.62rem;
                letter-spacing: 0.2px;
                border-radius: 12px;
                transform: none !important;
                box-shadow: none !important;
            }
            .nav-item i {
                font-size: 0.92rem;
            }
            .nav-item:hover,
            .nav-item.active {
                transform: none;
            }
            .nav-item.active {
                background: linear-gradient(135deg, var(--brand-2), var(--brand));
                border-color: transparent;
                color: #fff;
            }
            .nav-item #update-badge {
                position: absolute;
                top: 4px;
                right: 8px;
                margin-left: 0 !important;
            }
            .theme-toggle-row {
                position: absolute;
                right: 10px;
                top: 10px;
                margin: 0;
                padding: 0;
            }
            .theme-toggle-label { display: none; }
            .connection-card {
                padding: 0.68rem;
                gap: 0.35rem;
                margin-top: 0.36rem;
            }
            .op-mini-currencies {
                grid-template-columns: 1fr 1fr;
                max-height: none;
            }
            .main-content {
                padding: 0.9rem 0.72rem calc(124px + env(safe-area-inset-bottom));
            }
            .header {
                gap: 0.62rem;
                margin-bottom: 1rem;
            }
            .search-bar {
                padding: 0.74rem 0.8rem;
                border-radius: 13px;
                box-shadow: 0 10px 22px rgba(24, 18, 14, 0.09);
            }
            .user-actions {
                width: 100%;
                display: grid !important;
                grid-template-columns: 1fr 1fr;
                gap: 0.55rem !important;
            }
            .user-actions .btn-close-game {
                width: 100%;
                justify-content: center;
                padding: 0.64rem 0.55rem !important;
            }
            .hero-content { padding: 1.4rem; }
            .hero-title { font-size: 1.9rem; }
            .project-grid { grid-template-columns: 1fr; }
            .spotlight-title {
                font-size: 1.7rem;
                line-height: 1.1;
            }
            .spotlight-slider {
                padding: 0.82rem;
            }
            .spotlight-slider-title {
                font-size: 0.98rem;
            }
            .spotlight-slider-text {
                font-size: 0.79rem;
            }
            .spotlight-slider-visual {
                height: 94px;
            }
            .spotlight-slider-footer {
                flex-direction: column;
                align-items: stretch;
            }
            .spotlight-slider-btn {
                width: 100%;
            }
            .spotlight-slider-dots {
                width: 100%;
                justify-content: center;
            }
            .spotlight-subtitle {
                font-size: 0.88rem;
            }
            .spotlight-actions {
                flex-direction: column;
                align-items: stretch;
            }
            .spotlight-actions .btn-install {
                width: 100% !important;
            }
            .spotlight-metrics {
                grid-template-columns: 1fr 1fr;
            }
            .spotlight-panel {
                padding: 0.82rem;
            }
            .spotlight-panel-title {
                font-size: 0.82rem;
            }
            .news-hub-board {
                padding: 0.75rem;
            }
            .modal-news-card {
                min-height: unset;
            }
            .filter-chips {
                overflow-x: auto;
                flex-wrap: nowrap;
                padding-bottom: 0.22rem;
            }
            .filter-chip {
                flex: 0 0 auto;
            }
            .section-title {
                font-size: 1.1rem;
            }
            .ecosystem-row {
                grid-template-columns: 1fr;
                justify-items: start;
                gap: 0.65rem;
            }
            .ecosystem-row .app-icon {
                width: 62px;
                height: 62px;
            }
            .ecosystem-open-btn {
                width: 100%;
            }
            .update-banner {
                left: 10px;
                right: 10px;
                bottom: calc(86px + env(safe-area-inset-bottom));
                min-width: 0;
                transform: none;
                padding: 0.78rem 0.78rem 0.78rem 0.95rem;
                gap: 0.62rem;
                border-radius: 14px;
            }
            .update-banner.visible {
                animation: bannerPopMobile 0.24s ease;
            }
            .update-banner .update-text strong { font-size: 0.85rem; }
            .update-banner .update-text span { font-size: 0.72rem; }
            .update-banner .update-meta { font-size: 0.67rem; }
            .update-banner .update-progress { width: 80px; }
            .update-banner .btn-update { padding: 0.48rem 0.66rem; font-size: 0.7rem; }
            .update-banner .btn-close-update { width: 28px; height: 28px; }
        }

        @keyframes bannerPopMobile {
            from { opacity: 0; transform: translateY(8px) scale(0.985); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes spotlightSlideSwap {
            from { opacity: 0.7; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>

<body>
    <div id="game-overlay">
        <div class="game-controls">
            <button class="btn-close-game" onclick="closeGame()"><i class="fas fa-house"></i> CARGAR STORE</button>
            <button class="btn-close-game" onclick="toggleFullscreen()"><i class="fas fa-expand"></i></button>
        </div>
        <iframe id="game-frame" src="about:blank"></iframe>
    </div>

    <div id="details-modal">
        <button class="btn-close-modal" onclick="closeDetails()"><i class="fas fa-times"></i></button>
        <div class="modal-banner" id="m-banner"></div>
        <div class="modal-header">
            <img src="" class="modal-icon-large" id="m-icon" alt="">
            <div class="modal-title-area">
                <div class="modal-dev">Ocean and Wild Studios</div>
                <div class="modal-title" id="m-title">Project Name</div>
            </div>
        </div>
            <div class="modal-body">
                <p class="modal-description" id="m-desc">Cargando informacion...</p>
                <div class="modal-stats">
                    <div class="stat-box">
                        <div class="stat-label">Version</div>
                    <div class="stat-value" id="m-version">1.0.0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Estado</div>
                    <div class="stat-value" id="m-status">Lanzado</div>
                </div>
            </div>
                <div id="m-platforms" class="modal-platforms" style="display:none;">
                    <div class="stat-label">Plataforma de descarga</div>
                    <div id="m-platform-options" class="modal-platform-options"></div>
                    <div id="m-platform-meta" class="modal-platform-meta"></div>
                </div>
                <div id="m-news-wrap" class="modal-news-wrap">
                    <div class="modal-news-card">
                        <div class="modal-news-title">Changelog del Proyecto</div>
                        <div id="m-changelog-list" class="modal-news-list">
                            <div class="modal-news-empty">Sin datos todavia.</div>
                        </div>
                    </div>
                    <div class="modal-news-card">
                        <div class="modal-news-title">Eventos del Proyecto</div>
                        <div id="m-events-list" class="modal-news-list">
                            <div class="modal-news-empty">Sin eventos cargados.</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-actions" id="m-actions"></div>
        </div>

    <div class="app-container">
        <aside class="sidebar">
            <div class="logo" id="brand-logo" aria-live="polite">
                <i id="brand-logo-icon" class="fas fa-cube"></i>
                <div class="brand-copy">
                    <span class="brand-prefix">OWS</span>
                    <span id="brand-logo-word" class="brand-word">ATLAS</span>
                </div>
            </div>
            <div id="brand-logo-caption" class="logo-caption">Mapa vivo de proyectos y ideas.</div>
            <nav class="nav-menu">
                <li class="nav-item active" onclick="showSection('home', this)"><i class="fas fa-house"></i> Explorar</li>
                <li class="nav-item" onclick="showSection('library', this)"><i class="fas fa-folder-open"></i> Biblioteca</li>
                <li class="nav-item" onclick="showSection('updates', this)"><i class="fas fa-arrow-up-from-bracket"></i> Actualizaciones <span id="update-badge" style="display:none; background:var(--accent-primary); color:var(--bg); border-radius:50%; padding:2px 6px; font-size:10px; margin-left:auto; font-weight:800;">!</span></li>
            </nav>
            <div class="theme-toggle-row">
                <span class="theme-toggle-label">Dark Mode</span>
                <button id="theme-switch" class="theme-switch" onclick="toggleTheme()" aria-label="Cambiar tema"></button>
            </div>
            <div id="sidebar-download-dock" class="download-dock">
                <div class="download-dock-head">
                    <span>Descargas Activas</span>
                    <span id="dock-count-badge" class="download-dock-count">0</span>
                </div>
                <div class="download-dock-body">
                    <img id="dock-item-icon" class="download-dock-icon" src="./build/icon.ico" alt="download icon">
                    <div class="download-dock-info">
                        <div id="dock-item-title" class="download-dock-title">Sin descargas</div>
                        <div id="dock-item-status" class="download-dock-status">En espera</div>
                        <div class="download-dock-progress">
                            <div id="dock-item-progress" class="download-dock-progress-fill"></div>
                        </div>
                    </div>
                    <div id="dock-item-loader" class="download-dock-loader"></div>
                </div>
                <div class="download-dock-controls">
                    <div>
                        <button id="dock-prev-btn" class="download-dock-btn" onclick="cycleSidebarDownload(-1)"><i class="fas fa-chevron-left"></i></button>
                        <button id="dock-next-btn" class="download-dock-btn" onclick="cycleSidebarDownload(1)"><i class="fas fa-chevron-right"></i></button>
                    </div>
                    <span id="dock-item-index" class="download-dock-index">0/0</span>
                </div>
            </div>
            <div class="connection-card" id="oceanpay-placeholder-card">
                <div id="update-indicator-dot" class="update-indicator" style="display:none;"></div>
                <div class="connection-caption">CONECTADO A</div>
                <div class="connection-title"><i class="fas fa-shield-halved"></i> Ocean Pay ID</div>
                <div id="op-placeholder-chip" class="connection-placeholder-badge"><i class="fas fa-hourglass-half"></i> Placeholder</div>
                <div id="op-connection-status" class="op-mini-status">Sin conexion. Inicia sesion para sincronizar Ocean Pay en OWS Store.</div>
                <div id="op-connection-user" class="op-mini-user"></div>
                <div id="op-connection-balance" class="op-mini-balance"></div>
                <div id="op-connection-currencies" class="op-mini-currencies"></div>
                <div id="op-mini-form" class="op-mini-form">
                    <input id="op-mini-username" class="op-mini-input" type="text" autocomplete="username" placeholder="Usuario Ocean Pay">
                    <input id="op-mini-password" class="op-mini-input" type="password" autocomplete="current-password" placeholder="Contrasena">
                </div>
                <div class="op-mini-actions">
                    <button id="op-mini-connect" class="op-mini-btn primary" onclick="connectOceanPayStore()">Conectar</button>
                    <button id="op-mini-refresh" class="op-mini-btn" onclick="refreshOceanPayStore()" disabled>Sincronizar</button>
                    <button id="op-mini-disconnect" class="op-mini-btn warn" onclick="disconnectOceanPayStore()" disabled>Salir</button>
                </div>
                <div id="app-version" style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.25rem;">v-</div>
            </div>
        </aside>

        <!-- Banner de actualizacion (Electron) -->
        <div id="update-banner" class="update-banner state-info">
            <div class="update-icon"><i id="update-icon-glyph" class="fas fa-circle-info"></i></div>
            <div class="update-text">
                <strong id="update-title">Centro de actualizaciones</strong>
                <span id="update-msg">Una nueva version esta lista.</span>
                <div id="update-meta" class="update-meta">Tamano: - | ETA: -</div>
            </div>
            <div id="update-progress-wrap" class="update-progress" style="display:none;">
                <div id="update-progress-fill" class="update-progress-fill"></div>
            </div>
            <button id="btn-close-update-banner" class="btn-close-update" title="Cerrar" onclick="dismissUpdateBanner()">
                <i class="fas fa-times"></i>
            </button>
            <button id="btn-install-update" class="btn-update" style="display:none;" onclick="installUpdate()">
                <i class="fas fa-sync-alt"></i> Reiniciar e instalar
            </button>
        </div>

        <main class="main-content" id="main-view">
            <header class="header">
                <div class="search-bar">
                    <i class="fas fa-search"></i>
                    <input id="search-input" type="text" placeholder="Buscar juegos, herramientas o experiencias...">
                </div>
                <div class="user-actions" style="display: flex; gap: 1rem;">
                    <button class="btn-close-game" style="padding: 0.75rem 1rem;" onclick="syncLibraryNow()"><i class="fas fa-rotate"></i> Sincronizar</button>
                    <button class="btn-close-game" style="padding: 0.75rem 1rem;" onclick="showSection('updates', document.querySelector('.nav-menu .nav-item:nth-child(3)'))"><i class="fas fa-bell"></i> Notificaciones</button>
                </div>
            </header>

            <section id="home-view">
                <div class="explore-shell">
                    <div class="explore-spotlight">
                        <div>
                            <div class="spotlight-chip"><i class="fas fa-sparkles"></i> Ecosistema Multiproyecto</div>
                            <h1 class="spotlight-title">Descubre juegos, herramientas y experimentos inesperados.</h1>
                            <p class="spotlight-subtitle">
                                OWS Store combina lanzamientos estables, builds para Windows y conceptos en evolucion. Instala en cola, sigue el progreso en tiempo real y administra todo desde un solo hub.
                            </p>
                            <div class="spotlight-actions">
                                <button class="btn-install" style="width:auto; padding:0.85rem 1.15rem;" onclick="openWildWeaponAction(event)">
                                    <i class="fas fa-download"></i> Instalar destacado
                                </button>
                                <button class="btn-install btn-hero-secondary" style="width:auto; padding:0.85rem 1.15rem;" onclick="showSection('updates', document.querySelector('.nav-menu .nav-item:nth-child(3)'))">
                                    <i class="fas fa-arrow-down-up-across-line"></i> Ver descargas
                                </button>
                            </div>
                            <div class="spotlight-metrics">
                                <div class="spotlight-metric">
                                    <div id="explore-metric-total" class="spotlight-metric-value">0</div>
                                    <div class="spotlight-metric-label">Proyectos</div>
                                </div>
                                <div class="spotlight-metric">
                                    <div id="explore-metric-installed" class="spotlight-metric-value">0</div>
                                    <div class="spotlight-metric-label">Instalados</div>
                                </div>
                                <div class="spotlight-metric">
                                    <div id="explore-metric-updates" class="spotlight-metric-value">0</div>
                                    <div class="spotlight-metric-label">Con Update</div>
                                </div>
                            </div>
                        </div>
                        <div class="spotlight-side">
                            <div class="spotlight-panel">
                                <div class="spotlight-panel-title">Lanzamientos recientes</div>
                                <div id="explore-release-feed" class="spotlight-list">
                                    <div class="spotlight-list-item"><span>Wild Destiny</span><span>Countdown</span></div>
                                    <div class="spotlight-list-item"><span>WildWeapon Mayhem</span><span>Windows</span></div>
                                    <div class="spotlight-list-item"><span>Savage Space Animals</span><span>Windows</span></div>
                                    <div class="spotlight-list-item"><span>WildTransfer</span><span>Windows</span></div>
                                    <div class="spotlight-list-item"><span>OWS Store</span><span>Core Hub</span></div>
                                </div>
                            </div>
                            <div class="spotlight-panel">
                                <div class="spotlight-panel-title">Estado de descargas</div>
                                <div id="explore-download-preview" class="spotlight-list">
                                    <div class="spotlight-list-item"><span>Sin descargas activas</span><span>Idle</span></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="spotlight-slider" class="spotlight-slider" aria-live="polite">
                        <div id="spotlight-slider-label" class="spotlight-slider-label"><i class="fas fa-bullhorn"></i> Noticias</div>
                        <div id="spotlight-slider-title" class="spotlight-slider-title">Nuevos proyectos en OWS Store</div>
                        <div id="spotlight-slider-text" class="spotlight-slider-text">Explora los lanzamientos recientes y revisa sus fichas para instalar.</div>
                        <div class="spotlight-slider-visual">
                            <canvas id="spotlight-slider-canvas" class="spotlight-slider-canvas" width="640" height="160" aria-hidden="true"></canvas>
                        </div>
                        <div class="spotlight-slider-footer">
                            <button id="spotlight-slider-btn" class="btn-install spotlight-slider-btn" type="button">
                                <i class="fas fa-circle-info"></i> Ver ficha
                            </button>
                            <div id="spotlight-slider-dots" class="spotlight-slider-dots"></div>
                        </div>
                    </div>

                    <div class="explore-controls">
                        <div class="filter-chips">
                            <button id="filter-chip-all" class="filter-chip active" onclick="setProjectFilter('all')">Todo</button>
                            <button id="filter-chip-installed" class="filter-chip" onclick="setProjectFilter('installed')">Instalados</button>
                            <button id="filter-chip-external" class="filter-chip" onclick="setProjectFilter('external')">Windows EXE</button>
                            <button id="filter-chip-updates" class="filter-chip" onclick="setProjectFilter('updates')">Con update</button>
                        </div>
                        <div class="explore-note">Tip: selecciona varios proyectos para encadenar descargas en cola.</div>
                    </div>

                    <div class="section-title">Noticias y Eventos OWS</div>
                    <div class="news-hub-board" id="news-hub-board">
                        <div class="news-hub-col">
                            <div class="news-hub-col-title">Noticias Globales</div>
                            <div id="news-hub-global" class="news-hub-list">
                                <div class="news-hub-item">
                                    <div class="news-hub-item-head">
                                        <div class="news-hub-item-title">Cargando noticias...</div>
                                        <div class="news-hub-item-date">--</div>
                                    </div>
                                    <div class="news-hub-item-meta">Esperando respuesta del servidor.</div>
                                </div>
                            </div>
                        </div>
                        <div class="news-hub-col">
                            <div class="news-hub-col-title">Eventos Destacados</div>
                            <div id="news-hub-events" class="news-hub-list">
                                <div class="news-hub-item">
                                    <div class="news-hub-item-head">
                                        <div class="news-hub-item-title">Sin eventos por ahora</div>
                                        <div class="news-hub-item-date">--</div>
                                    </div>
                                    <div class="news-hub-item-meta">Se mostraran aqui los proximos eventos del ecosistema.</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="section-title">Ecosistema de Estudio <span style="font-size: 0.8rem; color: var(--accent-primary); cursor:pointer;">Ver todos</span></div>
                    <div class="project-grid ecosystem-list" id="projects-container">
                        <div class="app-card" style="opacity: 0.5;">
                            <div style="height: 64px; width: 64px; background: var(--glass); border-radius: 16px; margin-bottom: 1rem;"></div>
                            <div style="height: 20px; width: 60%; background: var(--glass); margin-bottom: 0.5rem;"></div>
                            <div style="height: 12px; width: 40%; background: var(--glass);"></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="library-view" style="display:none;">
                <div class="section-title">Mi Biblioteca Virtual</div>
                <div class="project-grid" id="library-container">
                    <p style="color:var(--text-dim)">No tienes proyectos instalados aun.</p>
                </div>
            </section>
            <section id="updates-view" style="display:none;">
                <div class="section-title">Centro de Actualizaciones</div>
                <div id="downloads-activity-list" class="downloads-activity">
                    <div class="download-item waiting">
                        <img class="avatar" src="./build/icon.ico" alt="OWS">
                        <div class="download-item-main">
                            <div class="download-item-head">
                                <div class="download-item-title">Sin descargas activas</div>
                                <div class="download-item-phase">Idle</div>
                            </div>
                            <div class="download-item-meta">Cuando inicies una descarga o update, aparecera aqui.</div>
                            <div class="download-item-progress-wrap">
                                <div class="download-item-progress"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="display:grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap:1rem; margin-bottom:1rem;">
                    <div class="stat-box">
                        <div class="stat-label">Estado Updater</div>
                        <div class="stat-value" id="updates-status">Esperando verificacion</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Version App</div>
                        <div class="stat-value" id="updates-app-version">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Instalador Externo</div>
                        <div class="stat-value" id="updates-project-status">Sin acciones recientes</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Tamano Update</div>
                        <div class="stat-value" id="updates-size">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Tiempo Estimado</div>
                        <div class="stat-value" id="updates-eta">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">OWS Store Android</div>
                        <div class="stat-value" style="display:flex; flex-direction:column; gap:0.55rem;">
                            <span id="ows-android-release-meta" class="android-release-meta">Buscando release Android...</span>
                            <button class="btn-install" style="width:auto; padding:0.55rem 0.8rem;" onclick="openStoreAndroidDownload()">
                                <i class="fas fa-mobile-screen-button"></i> Descargar Android
                            </button>
                        </div>
                    </div>
                </div>
                <div class="section-title">Actualizaciones de Proyectos</div>
                <div id="project-updates-list" style="display:flex; flex-direction:column; gap:0.6rem; margin-bottom:1rem;">
                    <div class="info-note-card">No hay actualizaciones pendientes.</div>
                </div>
                <div class="section-title">Notificaciones</div>
                <div id="notifications-list" style="display:flex; flex-direction:column; gap:0.6rem;"></div>
                <div class="section-title">OWS Store Changelog y Eventos</div>
                <div id="store-news-timeline" style="display:flex; flex-direction:column; gap:0.6rem;">
                    <div class="info-note-card">Cargando changelogs y eventos de OWS Store...</div>
                </div>
            </section>
        </main>
    </div>

    <script>
        const API_URL = 'https://owsdatabase.onrender.com';
        const OWS_NEWS_UPDATES_API_URL = `${API_URL}/ows-news/updates`;
        const OWS_STORE_ANDROID_API_BASE = `${API_URL}/ows-store/android`;
        const OWS_STORE_ANDROID_SLUG = 'ows-store';
        const FLORET_ANDROID_SLUG = 'floret-shop';
        const WILDWEAPON_RELEASES_URL = 'https://github.com/OceanandWild/wildweapon-mayhem/releases/latest';
        const GITHUB_RELEASES_PROXY_BASE = `${API_URL}/ows-store/github/repos/OceanandWild`;
        const WILDWEAPON_RELEASES_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/wildweapon-mayhem/releases/latest`;
        const WILDWEAPON_LOCAL_ICON = './build/wildweaponmayhem.ico';
        const SSA_RELEASES_URL = 'https://github.com/OceanandWild/savagespaceanimals/releases/latest';
        const SSA_RELEASES_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/savagespaceanimals/releases/latest`;
        const OCEAN_PAY_RELEASES_URL = 'https://github.com/OceanandWild/oceanpay/releases/';
        const OCEAN_PAY_RELEASES_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/oceanpay/releases/latest`;
        const OWS_STORE_RELEASES_URL = 'https://github.com/OceanandWild/owsdatabase/releases';
        const OWS_STORE_RELEASES_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/owsdatabase/releases/latest`;
        const OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL = OWS_STORE_RELEASES_URL;
        const FLORET_RELEASES_URL = 'https://github.com/OceanandWild/floretshop/releases';
        const FLORET_RELEASES_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/floretshop/releases?per_page=20`;
        const WILDTRANSFER_RELEASES_URL = 'https://github.com/OceanandWild/wildtransfer/releases/latest';
        const WILDTRANSFER_RELEASES_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/wildtransfer/releases/latest`;
        const WILDTRANSFER_RELEASES_LIST_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/wildtransfer/releases?per_page=20`;
        const WILDDESTINY_RELEASES_URL = 'https://github.com/OceanandWild/wilddestiny/releases/latest';
        const VELOCITY_SURGE_RELEASES_URL = 'https://github.com/OceanandWild/velocity-surge/releases/latest';
        const VELOCITY_SURGE_RELEASES_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/velocity-surge/releases/latest`;
        const OWSNEWS_RELEASES_URL = 'https://github.com/OceanandWild/ocean-and-wild-studios-news/releases/latest';
        const OWSNEWS_RELEASES_API_URL = `${GITHUB_RELEASES_PROXY_BASE}/ocean-and-wild-studios-news/releases/latest`;
        const SSA_LOCAL_ICON = './build/ssa.ico?v=20260223-0443';
        const OCEAN_PAY_LOCAL_ICON = './build/oceanpay.ico?v=20260223-1825';
        const FLORET_LOCAL_ICON = 'https://raw.githubusercontent.com/OceanandWild/owsdatabase/main/Floret%20Shop/assets/floretshopicon.png?v=20260224-1938';
        const WILDTRANSFER_LOCAL_ICON = './build/wildtransfer.ico?v=20260225-0100';
        const WILDDESTINY_LOCAL_ICON = './build/wilddestiny.ico?v=20260227-1935';
        const VELOCITY_SURGE_LOCAL_ICON = './build/velocitysurge.ico?v=20260227-2415';
        const OWSNEWS_LOCAL_ICON = './build/owsnews.ico?v=20260225-2248';
        const STORE_LOCAL_ICON = './build/icon.ico?v=20260223-0452';
        const STORE_DOWNLOAD_KEY = '__ows_store_update__';
        const STORE_THEME_KEY = 'ows_store_theme';
        const PROJECT_LIBRARY_KEY = 'ows_store_library_owned_slugs_v1';
        const OWS_STORE_ANDROID_INSTALLED_VERSION_KEY = 'ows_store_android_installed_version_name';
        const OWS_STORE_ANDROID_INSTALLED_VERSION_CODE_KEY = 'ows_store_android_installed_version_code';
        const OWS_STORE_ANDROID_UNKNOWN_SOURCES_ACK_KEY = 'ows_store_android_unknown_sources_ack_ts';
        const OWS_STORE_ANDROID_APK_MODE_KEY = 'ows_store_android_apk_mode';
        const OWS_STORE_ANDROID_UNKNOWN_SOURCES_ACK_TTL_MS = 2 * 60 * 1000;
        const OCEAN_PAY_STORAGE_USER = 'opUser';
        const OCEAN_PAY_STORAGE_TOKEN = 'opToken';
        const SSA_PROJECT = {
            slug: 'savagespaceanimals',
            name: 'Savage Space Animals',
            short: 'SSA',
            status: 'launched',
            version: '1.0.0',
            description: 'Combate espacial con fauna extrema y progresion arcade.',
            url: '../Savage Space Animals/index.html',
            icon_url: SSA_LOCAL_ICON
        };
        const FLORET_PROJECT = {
            slug: 'floret-shop',
            name: 'Floret Shop',
            short: 'FLR',
            status: 'launched',
            version: '1.0.0',
            platform: 'android,windows',
            install_type: 'external',
            installer_url: '',
            windows_version: '',
            android_release_url: FLORET_RELEASES_URL,
            android_apk_url: '',
            android_version: '',
            android_version_code: 0,
            description: 'Marketplace de Floret. Disponible para Android y Windows.',
            icon_url: FLORET_LOCAL_ICON
        };
        const WILDTRANSFER_PROJECT = {
            slug: 'wildtransfer',
            name: 'WildTransfer',
            short: 'WTR',
            status: 'launched',
            version: '1.0.0',
            platform: 'android,windows',
            install_type: 'external',
            installer_url: WILDTRANSFER_RELEASES_URL,
            windows_version: '',
            android_release_url: WILDTRANSFER_RELEASES_URL,
            android_apk_url: '',
            android_version: '',
            android_version_code: 0,
            description: 'Transferencia rapida de archivos con codigo unico.',
            icon_url: WILDTRANSFER_LOCAL_ICON
        };
        const WILDDESTINY_PROJECT = {
            slug: 'wild-destiny',
            name: 'Wild Destiny',
            short: 'WD',
            status: 'coming_soon',
            version: '1.0.0',
            platform: 'windows',
            install_type: 'external',
            installer_url: WILDDESTINY_RELEASES_URL,
            installer_available: false,
            pending_release: true,
            release_date: '2026-03-07T18:00:00Z',
            description: 'Action RPG de raids con clases, maestrias y progresion avanzada. Lanzamiento inicial para Windows en preparacion.',
            icon_url: WILDDESTINY_LOCAL_ICON
        };
        const VELOCITY_SURGE_PROJECT = {
            slug: 'velocity-surge',
            name: 'Velocity Surge',
            short: 'VSG',
            status: 'launched',
            version: '1.0.0',
            platform: 'windows',
            install_type: 'external',
            installer_url: VELOCITY_SURGE_RELEASES_URL,
            description: 'Racing arcade competitivo con eventos tematicos, cofres y progresion por corredores.',
            icon_url: VELOCITY_SURGE_LOCAL_ICON
        };
        const OWS_NEWS_CACHE_TTL_MS = 120000;
        const NEW_BADGE_DURATION_MS = 14 * 24 * 60 * 60 * 1000;
        const NEW_BADGE_START_BY_SLUG = {
            'wildtransfer': '2026-02-25T00:00:00Z',
            'velocity-surge': '2026-02-27T00:00:00Z',
        };
        const BRAND_STATES = [
            { word: 'ATLAS', iconClass: 'fa-cube', color: '#d14f2a', caption: 'Mapa vivo de proyectos y ideas.' },
            { word: 'STORE', iconClass: 'fa-store', color: '#007f84', caption: 'Instala juegos, herramientas y experiencias.' },
            { word: 'LABS', iconClass: 'fa-flask', color: '#1f9d63', caption: 'Prototipos inesperados en evolucion constante.' },
            { word: 'ARCADE', iconClass: 'fa-gamepad', color: '#b96700', caption: 'Diversidad de estilos para cada jugador.' },
        ];
        const SPOTLIGHT_SLIDES = [
            {
                key: 'wild-destiny-countdown',
                label: 'Proximo lanzamiento',
                title: 'Wild Destiny llega pronto a OWS Store (Windows)',
                text: 'La ventana de lanzamiento ya tiene fecha. Puedes seguir el countdown desde su ficha en Ecosistema de Estudio.',
                slug: 'wild-destiny',
            },
            {
                key: 'velocity-surge-launch',
                label: 'Nuevo proyecto',
                title: 'Velocity Surge entra a OWS Store para Windows',
                text: 'Carreras arcade con progresion competitiva y eventos de temporada ya disponibles.',
                slug: 'velocity-surge',
            },
            {
                key: 'ows-news-retired',
                label: 'Store Changelog',
                title: 'OWS News fue retirado como app independiente',
                text: 'Noticias y eventos oficiales ahora se gestionan directamente dentro de OWS Store.',
                slug: '',
            },
            {
                key: 'wildtransfer-arrival',
                label: 'Lanzamiento',
                title: 'WildTransfer ya forma parte de OWS Store',
                text: 'Transferencia de archivos con enfoque rapido y mas integrado al ecosistema.',
                slug: 'wildtransfer',
            },
            {
                key: 'store-news-hub',
                label: 'Novedad',
                title: 'Nuevo centro de noticias dentro de OWS Store',
                text: 'Ahora los anuncios, changelogs y eventos viven en un solo lugar: OWS Store.',
                slug: '',
            },
            {
                key: 'ocean-pay-recommend',
                label: 'Recomendado',
                title: 'Se recomienda instalar Ocean Pay',
                text: 'Ocean Pay centraliza identidad y divisas para integraciones entre proyectos OWS.',
                slug: 'ocean-pay',
            },
        ];
        const ONE_SHOT_RECOMMENDED_SLUGS = new Set(['ocean-pay']);
        const ONE_SHOT_RECOMMEND_PREFIX = 'ows_store_recommend_shown_';
        let wildWeaponReleaseCache = null;
        let ssaReleaseCache = null;
        let oceanPayProjectReleaseCache = null;
        let floretProjectReleaseCache = null;
        let wildTransferReleaseCache = null;
        let velocitySurgeReleaseCache = null;
        let owsNewsReleaseCache = null;
        let owsNewsUpdatesCache = [];
        let owsNewsUpdatesFetchedAt = 0;
        let owsStoreAndroidReleaseCache = null;
        let owsStoreWindowsReleaseCache = null;
        let allProjects = [];
        let libraryOwnedSlugs = new Set();
        const notificationLog = [];
        let lastExternalStatusNotification = '';
        let installStateBySlug = {};
        let installRuntimeBySlug = {};
        let uninstallSuppressedBySlug = {};
        let currentSearchTerm = '';
        let currentProjectFilter = 'all';
        let activeSection = 'home';
        let scheduledRenderTimer = null;
        let actionBannerTimer = null;
        let actionBannerSticky = false;
        let appUpdateAvailable = false;
        let appUpdateSizeBytes = 0;
        let appUpdateEtaSeconds = null;
        let owsStoreWindowsManualUpdateUrl = '';
        let owsStoreWindowsManualVersion = '';
        let currentStoreWindowsVersion = '';
        let lastStoreUpdaterCheckSilent = true;
        let lastStoreUpdaterCheckOrigin = 'auto';
        let projectUpdatesCount = 0;
        let brandStateIndex = 0;
        let brandCycleTimer = null;
        let brandSwapCleanupTimer = null;
        let spotlightSlideIndex = 0;
        let spotlightSlideTimer = null;
        let spotlightSlideCleanupTimer = null;
        let spotlightCanvasResizeHandlerBound = false;
        let sidebarDownloadCursor = 0;
        let sidebarSelectedDownloadKey = '';
        let sidebarSelectionPinnedByUser = false;
        let downloadSurfacesRenderQueued = false;
        let downloadSurfacesLastRenderedAt = 0;
        let installQueueProcessing = false;
        let activeInstallTaskKey = '';
        let oceanPayState = {
            user: null,
            token: '',
            balance: 0,
            balances: {},
            loading: false,
            connected: false
        };
        const projectInstallQueue = [];
        const downloadSessions = {};
        const UPDATE_BANNER_STATES = ['checking', 'available', 'downloading', 'ready', 'success', 'error', 'info'];
        const projectUpdateNotified = new Set();
        const externalProgressUiState = {};
        const selectedInstallTargetBySlug = {};
        const owsStoreAndroidState = {
            downloadUrl: OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL,
            directDownloadUrl: '',
            sha256: '',
            version: '',
            versionCode: 0,
            sizeBytes: 0,
            publishedAt: null,
            source: 'release-page',
            warning: '',
            releaseNotes: '',
            resolvable: false
        };
        const STORE_OBSOLETE_GATE_REFRESH_MS = 90000;
        const STORE_OBSOLETE_BLOCK_NOTICE_COOLDOWN_MS = 4000;
        let storeObsoleteGate = {
            blocked: false,
            platform: '',
            currentVersion: '',
            requiredVersion: '',
            reason: '',
            source: '',
            checkedAt: 0
        };
        let storeObsoleteGateRefreshPromise = null;
        let storeObsoleteGateLastNoticeAt = 0;

        function applyTheme(theme) {
            const mode = theme === 'dark' ? 'dark' : 'light';
            document.body.setAttribute('data-theme', mode);
            localStorage.setItem(STORE_THEME_KEY, mode);
            const toggle = document.getElementById('theme-switch');
            if (toggle) toggle.classList.toggle('dark', mode === 'dark');
            renderSpotlightSlider(false);
        }

        function initTheme() {
            const saved = localStorage.getItem(STORE_THEME_KEY);
            if (saved === 'light' || saved === 'dark') {
                applyTheme(saved);
                return;
            }
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            applyTheme(prefersDark ? 'dark' : 'light');
        }

        function toggleTheme() {
            const current = document.body.getAttribute('data-theme') || 'light';
            applyTheme(current === 'dark' ? 'light' : 'dark');
        }

        function loadLibraryOwnedSlugs() {
            try {
                const raw = localStorage.getItem(PROJECT_LIBRARY_KEY) || '[]';
                const list = JSON.parse(raw);
                if (!Array.isArray(list)) return new Set();
                return new Set(
                    list
                        .map((v) => String(v || '').trim())
                        .filter(Boolean)
                );
            } catch (_) {
                return new Set();
            }
        }

        function persistLibraryOwnedSlugs() {
            try {
                localStorage.setItem(PROJECT_LIBRARY_KEY, JSON.stringify([...libraryOwnedSlugs]));
            } catch (_) {}
        }

        function rememberProjectInLibrary(slug = '') {
            const key = String(slug || '').trim();
            if (!key) return;
            if (libraryOwnedSlugs.has(key)) return;
            libraryOwnedSlugs.add(key);
            persistLibraryOwnedSlugs();
        }

        function isProjectInLibrary(slug = '') {
            return libraryOwnedSlugs.has(String(slug || '').trim());
        }

        function seedLibraryFromProjectCatalog() {
            if (libraryOwnedSlugs.size > 0) return;
            const defaults = (Array.isArray(allProjects) ? allProjects : [])
                .filter((p) => isExternalInstallerProject(p) && String(p?.slug || '').toLowerCase() !== 'ows-store')
                .map((p) => String(p.slug || '').trim())
                .filter(Boolean);
            if (!defaults.length) return;
            defaults.forEach((slug) => libraryOwnedSlugs.add(slug));
            persistLibraryOwnedSlugs();
        }

        function getOceanPayToken() {
            if (oceanPayState.token) return oceanPayState.token;
            const fromStorage = localStorage.getItem(OCEAN_PAY_STORAGE_TOKEN) || '';
            if (fromStorage) return fromStorage;
            try {
                const parsed = JSON.parse(localStorage.getItem(OCEAN_PAY_STORAGE_USER) || 'null');
                return parsed?.token || '';
            } catch (_) {
                return '';
            }
        }

        const OCEAN_PAY_CURRENCY_LABELS = {
            aquabux: 'AquaBux',
            ecoxionums: 'Ecoxionums',
            wildcredits: 'WildCredits',
            wildgems: 'WildGems',
            appbux: 'AppBux',
            ecobooks: 'EcoBooks',
            ecotokens: 'EcoTokens',
            ecobits: 'EcoCoreBits',
            ecorebits: 'EcoCoreBits',
            nxb: 'Nexus Bits',
            amber: 'Amber',
            voltbit: 'VoltBits',
            mayhemcoins: 'MayhemCoins',
            cosmicdust: 'Polvora Cosmica'
        };

        const OCEAN_PAY_CURRENCY_ORDER = [
            'aquabux',
            'ecoxionums',
            'wildcredits',
            'wildgems',
            'cosmicdust',
            'appbux',
            'ecobooks',
            'ecotokens',
            'ecorebits',
            'nxb',
            'amber',
            'voltbit',
            'mayhemcoins'
        ];

        function toOceanPayNumber(value) {
            const n = Number(value);
            return Number.isFinite(n) ? n : 0;
        }

        function oceanPaySortRank(code) {
            const idx = OCEAN_PAY_CURRENCY_ORDER.indexOf(code);
            return idx === -1 ? 999 : idx;
        }

        function extractOceanPayBalances(payload = {}) {
            const totals = {};
            const absorb = (source) => {
                if (!source || typeof source !== 'object') return;
                Object.entries(source).forEach(([code, value]) => {
                    const amount = toOceanPayNumber(value);
                    if (!Number.isFinite(amount)) return;
                    totals[code] = toOceanPayNumber(totals[code]) + amount;
                });
            };

            const cards = Array.isArray(payload.cards)
                ? payload.cards
                : (Array.isArray(payload?.user?.cards) ? payload.user.cards : []);

            if (cards.length) cards.forEach((card) => absorb(card?.balances));
            if (!cards.length && payload.balances && typeof payload.balances === 'object') absorb(payload.balances);

            [
                'aquabux', 'ecoxionums', 'wildcredits', 'wildgems', 'appbux',
                'ecobooks', 'ecotokens', 'ecorebits', 'ecobits', 'nxb',
                'amber', 'voltbit', 'mayhemcoins', 'cosmicdust'
            ].forEach((code) => {
                if (totals[code] !== undefined) return;
                const rootValue = payload?.[code];
                const userValue = payload?.user?.[code];
                if (rootValue !== undefined) totals[code] = toOceanPayNumber(rootValue);
                else if (userValue !== undefined) totals[code] = toOceanPayNumber(userValue);
            });

            if (totals.ecorebits === undefined && totals.ecobits !== undefined) totals.ecorebits = totals.ecobits;

            return totals;
        }

        function renderOceanPayCurrencyChips() {
            const container = document.getElementById('op-connection-currencies');
            if (!container) return;
            const connected = Boolean(oceanPayState.connected);
            if (!connected) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            const entries = Object.entries(oceanPayState.balances || {})
                .map(([code, value]) => [code, toOceanPayNumber(value)]);
            const known = OCEAN_PAY_CURRENCY_ORDER.map((code) => [code, toOceanPayNumber(oceanPayState?.balances?.[code])]);
            const knownSet = new Set(OCEAN_PAY_CURRENCY_ORDER);
            const extra = entries
                .filter(([code]) => !knownSet.has(code))
                .sort((a, b) => b[1] - a[1]);
            const renderedEntries = [...known, ...extra];

            const visible = renderedEntries;
            if (!visible.length) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            const chipsHtml = visible.map(([code, value]) => {
                const label = OCEAN_PAY_CURRENCY_LABELS[code] || code.toUpperCase();
                return `
                    <div class="op-mini-currency-chip">
                        <span class="label">${label}</span>
                        <span class="value">${Math.floor(value).toLocaleString()}</span>
                    </div>
                `;
            }).join('');

            container.innerHTML = chipsHtml;
            container.style.display = 'grid';
        }

        function setOceanPaySession({ user = null, token = '', balance = 0, balances = null }) {
            const normalizedBalances = balances && typeof balances === 'object'
                ? { ...balances }
                : (token ? { ...(oceanPayState.balances || {}) } : {});
            const aquabuxFromBalances = toOceanPayNumber(normalizedBalances.aquabux);
            const explicitBalance = toOceanPayNumber(balance);
            oceanPayState = {
                ...oceanPayState,
                user: user || null,
                token: token || '',
                balance: aquabuxFromBalances > 0 ? aquabuxFromBalances : explicitBalance,
                balances: normalizedBalances,
                connected: Boolean(token)
            };
            if (token && user) {
                localStorage.setItem(OCEAN_PAY_STORAGE_TOKEN, token);
                localStorage.setItem(OCEAN_PAY_STORAGE_USER, JSON.stringify({ ...user, token }));
            } else if (!token) {
                localStorage.removeItem(OCEAN_PAY_STORAGE_TOKEN);
                localStorage.removeItem(OCEAN_PAY_STORAGE_USER);
            }
            renderOceanPayCard();
        }

        function renderOceanPayCard() {
            const status = document.getElementById('op-connection-status');
            const userEl = document.getElementById('op-connection-user');
            const balanceEl = document.getElementById('op-connection-balance');
            const form = document.getElementById('op-mini-form');
            const chip = document.getElementById('op-placeholder-chip');
            const btnConnect = document.getElementById('op-mini-connect');
            const btnRefresh = document.getElementById('op-mini-refresh');
            const btnDisconnect = document.getElementById('op-mini-disconnect');
            const connected = Boolean(oceanPayState.connected);
            if (status) {
                if (oceanPayState.loading) status.textContent = 'Sincronizando Ocean Pay...';
                else if (connected) status.textContent = 'Ocean Pay conectado correctamente.';
                else status.textContent = 'Sin conexion. Inicia sesion para sincronizar Ocean Pay en OWS Store.';
            }
            if (userEl) {
                userEl.style.display = connected ? 'block' : 'none';
                userEl.textContent = connected ? `Usuario: ${oceanPayState.user?.username || 'desconocido'}` : '';
            }
            if (balanceEl) {
                balanceEl.style.display = connected ? 'block' : 'none';
                const aquabux = toOceanPayNumber(oceanPayState?.balances?.aquabux ?? oceanPayState.balance);
                balanceEl.textContent = connected ? `AquaBux: ${Math.floor(aquabux).toLocaleString()}` : '';
            }
            renderOceanPayCurrencyChips();
            if (form) form.style.display = connected ? 'none' : 'flex';
            if (chip) chip.style.display = connected ? 'none' : 'inline-flex';
            if (btnConnect) btnConnect.disabled = oceanPayState.loading || connected;
            if (btnRefresh) btnRefresh.disabled = oceanPayState.loading || !connected;
            if (btnDisconnect) btnDisconnect.disabled = oceanPayState.loading || !connected;
        }

        async function oceanPayApi(path, options = {}, retry = true) {
            const token = getOceanPayToken();
            const cfg = { ...options, headers: { ...(options.headers || {}) } };
            if (token) cfg.headers.Authorization = `Bearer ${token}`;
            let res = await fetch(`${API_URL}${path}`, cfg);
            if (res.status === 401 && token && retry) {
                const refreshed = await refreshOceanPayToken();
                if (refreshed) return oceanPayApi(path, options, false);
            }
            return res;
        }

        async function refreshOceanPayToken() {
            const token = getOceanPayToken();
            if (!token) return false;
            try {
                const res = await fetch(`${API_URL}/ocean-pay/refresh-token`, {
                    method: 'POST',
                    headers: { Authorization: `Bearer ${token}` }
                });
                if (!res.ok) return false;
                const data = await res.json();
                if (!data?.token) return false;
                const oldUser = JSON.parse(localStorage.getItem(OCEAN_PAY_STORAGE_USER) || '{}');
                setOceanPaySession({
                    user: { ...oldUser, ...(data.user || {}) },
                    token: data.token,
                    balance: oceanPayState.balance
                });
                return true;
            } catch (_) {
                return false;
            }
        }

        async function refreshOceanPayStore() {
            const token = getOceanPayToken();
            if (!token) {
                setOceanPaySession({ user: null, token: '', balance: 0, balances: {} });
                return false;
            }
            oceanPayState.loading = true;
            renderOceanPayCard();
            try {
                const res = await oceanPayApi('/ocean-pay/me');
                if (!res.ok) throw new Error('Sesion no valida');
                const data = await res.json();
                const currentUser = JSON.parse(localStorage.getItem(OCEAN_PAY_STORAGE_USER) || '{}');
                const balances = extractOceanPayBalances(data);
                setOceanPaySession({
                    user: {
                        ...currentUser,
                        id: data.id || currentUser.id,
                        uid: data.id || currentUser.uid,
                        username: data.username || currentUser.username
                    },
                    token: getOceanPayToken(),
                    balance: toOceanPayNumber(balances.aquabux),
                    balances
                });
                addNotification('Ocean Pay sincronizado.', 'success');
                return true;
            } catch (err) {
                setOceanPaySession({ user: null, token: '', balance: 0, balances: {} });
                addNotification('Sesion de Ocean Pay expirada. Vuelve a iniciar sesion.', 'warning');
                return false;
            } finally {
                oceanPayState.loading = false;
                renderOceanPayCard();
            }
        }

        async function connectOceanPayStore() {
            const userInput = document.getElementById('op-mini-username');
            const passInput = document.getElementById('op-mini-password');
            const username = String(userInput?.value || '').trim();
            const password = String(passInput?.value || '').trim();
            if (!username || !password) {
                addNotification('Completa usuario y contrasena de Ocean Pay.', 'warning');
                return;
            }
            oceanPayState.loading = true;
            renderOceanPayCard();
            try {
                const res = await fetch(`${API_URL}/ocean-pay/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok || !data?.token) throw new Error(data?.error || 'No se pudo iniciar sesion');
                const loginPayload = {
                    ...data,
                    ...(data?.user || {}),
                    cards: data?.cards || data?.user?.cards || []
                };
                const balances = extractOceanPayBalances(loginPayload);
                setOceanPaySession({
                    user: { ...(data.user || {}), username },
                    token: data.token,
                    balance: toOceanPayNumber(balances.aquabux || data?.user?.aquabux || data?.aquabux || 0),
                    balances
                });
                if (userInput) userInput.value = '';
                if (passInput) passInput.value = '';
                await refreshOceanPayStore();
            } catch (err) {
                addNotification(`Ocean Pay: ${err?.message || 'error de conexion'}`, 'error');
            } finally {
                oceanPayState.loading = false;
                renderOceanPayCard();
            }
        }

        function disconnectOceanPayStore() {
            setOceanPaySession({ user: null, token: '', balance: 0, balances: {} });
            addNotification('Sesion de Ocean Pay cerrada en OWS Store.', 'neutral');
        }

        function initOceanPayStore() {
            const token = getOceanPayToken();
            if (token) {
                let user = null;
                try { user = JSON.parse(localStorage.getItem(OCEAN_PAY_STORAGE_USER) || 'null'); } catch (_) {}
                setOceanPaySession({ user, token, balance: 0, balances: {} });
                refreshOceanPayStore();
            } else {
                renderOceanPayCard();
            }
        }

        function formatByteSize(bytes) {
            const n = Number(bytes);
            if (!Number.isFinite(n) || n <= 0) return '-';
            const units = ['B', 'KB', 'MB', 'GB'];
            let value = n;
            let idx = 0;
            while (value >= 1024 && idx < units.length - 1) {
                value /= 1024;
                idx += 1;
            }
            const precision = idx === 0 ? 0 : (value < 10 ? 2 : 1);
            return `${value.toFixed(precision)} ${units[idx]}`;
        }

        function formatEta(seconds) {
            const s = Number(seconds);
            if (!Number.isFinite(s) || s < 0) return '-';
            if (s < 5) return 'menos de 5s';
            if (s < 60) return `${Math.ceil(s)}s`;
            const mins = Math.floor(s / 60);
            const secs = Math.ceil(s % 60);
            if (mins < 60) return `${mins}m ${secs}s`;
            const hours = Math.floor(mins / 60);
            const remMins = mins % 60;
            return `${hours}h ${remMins}m`;
        }

        function extractUpdateSizeBytes(info) {
            const files = Array.isArray(info?.files) ? info.files : [];
            const withSize = files.find((f) => Number.isFinite(Number(f?.size)) && Number(f.size) > 0);
            return withSize ? Number(withSize.size) : 0;
        }

        function setUpdateMetaUI(payload = {}) {
            const sizeEl = document.getElementById('updates-size');
            const etaEl = document.getElementById('updates-eta');
            const metaEl = document.getElementById('update-meta');
            const sizeBytes = Number.isFinite(Number(payload.sizeBytes)) ? Number(payload.sizeBytes) : appUpdateSizeBytes;
            const etaSeconds = Number.isFinite(Number(payload.etaSeconds)) ? Number(payload.etaSeconds) : appUpdateEtaSeconds;
            const transferredBytes = Number.isFinite(Number(payload.transferredBytes)) ? Number(payload.transferredBytes) : null;
            const speedBps = Number(payload.speedBps || 0);

            const sizeText = formatByteSize(sizeBytes);
            const etaText = formatEta(etaSeconds);
            const transferredText = (transferredBytes !== null && sizeBytes > 0)
                ? `${formatByteSize(transferredBytes)} / ${formatByteSize(sizeBytes)}`
                : '';
            const speedText = speedBps > 0 ? `${formatByteSize(speedBps)}/s` : '';

            if (sizeEl) sizeEl.textContent = sizeText;
            if (etaEl) etaEl.textContent = etaText;
            if (metaEl) {
                const parts = [`Tamano: ${sizeText}`, `ETA: ${etaText}`];
                if (transferredText) parts.push(transferredText);
                if (speedText) parts.push(speedText);
                metaEl.textContent = parts.join(' | ');
            }
        }

        function applyBrandState(state, animate = true) {
            const logo = document.getElementById('brand-logo');
            const icon = document.getElementById('brand-logo-icon');
            const word = document.getElementById('brand-logo-word');
            const caption = document.getElementById('brand-logo-caption');
            if (!logo || !icon || !word || !caption || !state) return;

            if (animate) {
                logo.classList.remove('swap');
                void logo.offsetWidth;
                logo.classList.add('swap');
                if (brandSwapCleanupTimer) clearTimeout(brandSwapCleanupTimer);
                brandSwapCleanupTimer = setTimeout(() => logo.classList.remove('swap'), 260);
            }
            icon.className = `fas ${state.iconClass}`;
            icon.style.color = state.color;
            word.textContent = state.word;
            word.style.color = state.color;
            caption.textContent = state.caption;
        }

        function initBrandCycle() {
            if (brandCycleTimer) clearInterval(brandCycleTimer);
            brandStateIndex = 0;
            applyBrandState(BRAND_STATES[brandStateIndex], false);
            brandCycleTimer = setInterval(() => {
                brandStateIndex = (brandStateIndex + 1) % BRAND_STATES.length;
                applyBrandState(BRAND_STATES[brandStateIndex], true);
            }, 3200);
        }

        function getOneShotRecommendKey(slug) {
            return `${ONE_SHOT_RECOMMEND_PREFIX}${String(slug || '').toLowerCase()}`;
        }

        function hasOneShotRecommendShown(slug) {
            if (!slug) return true;
            try {
                return localStorage.getItem(getOneShotRecommendKey(slug)) === '1';
            } catch (_) {
                return false;
            }
        }

        function markOneShotRecommendShown(slug) {
            if (!slug) return;
            try {
                localStorage.setItem(getOneShotRecommendKey(slug), '1');
            } catch (_) {}
        }

        function clearModalRecommendBubble() {
            const bubble = document.getElementById('modal-recommend-bubble');
            if (bubble) bubble.remove();
        }

        function maybeShowRecommendBubble(project) {
            clearModalRecommendBubble();
            if (!project || !ONE_SHOT_RECOMMENDED_SLUGS.has(project.slug)) return;
            if (hasOneShotRecommendShown(project.slug)) return;

            const actions = document.getElementById('m-actions');
            if (!actions) return;

            const bubble = document.createElement('div');
            bubble.id = 'modal-recommend-bubble';
            bubble.className = 'modal-recommend-bubble';
            bubble.innerHTML = `
                <strong><i class="fas fa-circle-info"></i> Proyecto muy recomendable</strong>
                <span>Antes de instalar, revisa la ficha completa y luego usa el boton de descarga.</span>
            `;
            actions.insertBefore(bubble, actions.firstChild);
            markOneShotRecommendShown(project.slug);
        }

        function drawSpotlightCanvasRoundedRect(ctx, x, y, w, h, r) {
            const radius = Math.max(0, Math.min(r, Math.min(w, h) * 0.5));
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
            ctx.lineTo(x + radius, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function renderSpotlightIllustration(slide) {
            const canvas = document.getElementById('spotlight-slider-canvas');
            if (!canvas || !slide) return;
            const rect = canvas.getBoundingClientRect();
            const cssW = Math.max(320, Math.floor(rect.width || 640));
            const cssH = Math.max(88, Math.floor(rect.height || 116));
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const targetW = Math.floor(cssW * dpr);
            const targetH = Math.floor(cssH * dpr);
            if (canvas.width !== targetW) canvas.width = targetW;
            if (canvas.height !== targetH) canvas.height = targetH;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, cssW, cssH);

            const dark = document.body.getAttribute('data-theme') === 'dark';
            const bgGrad = ctx.createLinearGradient(0, 0, cssW, cssH);
            bgGrad.addColorStop(0, dark ? '#122033' : '#fbffff');
            bgGrad.addColorStop(1, dark ? '#0e1624' : '#f0f8f6');
            drawSpotlightCanvasRoundedRect(ctx, 0, 0, cssW, cssH, 14);
            ctx.fillStyle = bgGrad;
            ctx.fill();

            const accentA = dark ? '#52d9df' : '#0aaeb5';
            const accentB = dark ? '#ff9b6a' : '#d96a2e';
            const softLine = dark ? 'rgba(194,220,255,0.2)' : 'rgba(13,49,63,0.18)';

            const glow = ctx.createRadialGradient(cssW * 0.24, cssH * 0.45, 4, cssW * 0.24, cssH * 0.45, cssW * 0.4);
            glow.addColorStop(0, dark ? 'rgba(82,217,223,0.32)' : 'rgba(10,174,181,0.22)');
            glow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glow;
            ctx.fillRect(0, 0, cssW, cssH);

            ctx.strokeStyle = softLine;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(12, cssH - 16);
            ctx.lineTo(cssW - 12, cssH - 16);
            ctx.stroke();

            if (slide.key === 'ows-news-retired') {
                drawSpotlightCanvasRoundedRect(ctx, 22, 22, 106, cssH - 40, 10);
                ctx.fillStyle = dark ? '#1b2a3e' : '#e7f2f7';
                ctx.fill();
                ctx.strokeStyle = accentA;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = dark ? '#9fd8df' : '#1f6f78';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(36, 36 + i * 15, 76, 4);
                }
                ctx.strokeStyle = accentB;
                ctx.lineWidth = 2.4;
                ctx.beginPath();
                ctx.arc(cssW - 64, cssH * 0.5, 11, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cssW - 64, cssH * 0.5, 21, -0.8, 0.8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cssW - 64, cssH * 0.5, 31, -0.8, 0.8);
                ctx.stroke();
            } else if (slide.key === 'wildtransfer-arrival') {
                ctx.strokeStyle = accentA;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(24, cssH * 0.38);
                ctx.lineTo(cssW - 88, cssH * 0.38);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cssW - 102, cssH * 0.28);
                ctx.lineTo(cssW - 78, cssH * 0.38);
                ctx.lineTo(cssW - 102, cssH * 0.48);
                ctx.stroke();

                ctx.strokeStyle = accentB;
                ctx.beginPath();
                ctx.moveTo(cssW - 24, cssH * 0.7);
                ctx.lineTo(88, cssH * 0.7);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(102, cssH * 0.6);
                ctx.lineTo(78, cssH * 0.7);
                ctx.lineTo(102, cssH * 0.8);
                ctx.stroke();

                ctx.fillStyle = dark ? '#96c8ff' : '#335f8c';
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.arc(42 + i * 20, cssH * 0.54, 2.2, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (slide.key === 'store-news-hub') {
                const cx = 72;
                const cy = cssH * 0.5;
                const outer = 28;
                const inner = 12;
                ctx.fillStyle = dark ? '#1f2d43' : '#eaf3ff';
                ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                    const a = (Math.PI / 5) * i - Math.PI / 2;
                    const rr = i % 2 === 0 ? outer : inner;
                    const x = cx + Math.cos(a) * rr;
                    const y = cy + Math.sin(a) * rr;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = accentB;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.strokeStyle = accentA;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(130, cssH * 0.56);
                ctx.lineTo(148, cssH * 0.72);
                ctx.lineTo(184, cssH * 0.4);
                ctx.stroke();
                ctx.strokeStyle = softLine;
                ctx.lineWidth = 2;
                ctx.strokeRect(212, 24, cssW - 236, cssH - 48);
            } else {
                const coinR = 17;
                for (let i = 0; i < 3; i++) {
                    const x = 36 + i * 22;
                    const y = cssH - 34 - i * 8;
                    ctx.fillStyle = dark ? '#1b3247' : '#e7f4ff';
                    ctx.beginPath();
                    ctx.ellipse(x, y, coinR, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = i % 2 ? accentA : accentB;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                const sx = cssW - 84;
                const sy = cssH * 0.5;
                ctx.beginPath();
                ctx.moveTo(sx, sy - 28);
                ctx.lineTo(sx + 24, sy - 14);
                ctx.lineTo(sx + 24, sy + 12);
                ctx.lineTo(sx, sy + 28);
                ctx.lineTo(sx - 24, sy + 12);
                ctx.lineTo(sx - 24, sy - 14);
                ctx.closePath();
                ctx.fillStyle = dark ? '#1b2a3e' : '#edf4fd';
                ctx.fill();
                ctx.strokeStyle = accentA;
                ctx.lineWidth = 2.2;
                ctx.stroke();
                ctx.strokeStyle = accentB;
                ctx.lineWidth = 2.6;
                ctx.beginPath();
                ctx.moveTo(sx - 8, sy + 1);
                ctx.lineTo(sx - 1, sy + 9);
                ctx.lineTo(sx + 11, sy - 8);
                ctx.stroke();
            }
        }

        function restartSpotlightSliderAuto() {
            if (spotlightSlideTimer) clearInterval(spotlightSlideTimer);
            if (SPOTLIGHT_SLIDES.length <= 1) return;
            spotlightSlideTimer = setInterval(() => {
                spotlightSlideIndex = (spotlightSlideIndex + 1) % SPOTLIGHT_SLIDES.length;
                renderSpotlightSlider(true);
            }, 4600);
        }

        function renderSpotlightSlider(animate = true) {
            const wrap = document.getElementById('spotlight-slider');
            const labelEl = document.getElementById('spotlight-slider-label');
            const titleEl = document.getElementById('spotlight-slider-title');
            const textEl = document.getElementById('spotlight-slider-text');
            const btn = document.getElementById('spotlight-slider-btn');
            const dots = document.getElementById('spotlight-slider-dots');
            if (!wrap || !labelEl || !titleEl || !textEl || !btn || !dots || !SPOTLIGHT_SLIDES.length) return;

            const slide = SPOTLIGHT_SLIDES[spotlightSlideIndex % SPOTLIGHT_SLIDES.length];
            if (!slide) return;

            if (animate) {
                wrap.classList.remove('swap');
                void wrap.offsetWidth;
                wrap.classList.add('swap');
                if (spotlightSlideCleanupTimer) clearTimeout(spotlightSlideCleanupTimer);
                spotlightSlideCleanupTimer = setTimeout(() => wrap.classList.remove('swap'), 260);
            }

            labelEl.innerHTML = `<i class="fas fa-bullhorn"></i> ${slide.label}`;
            titleEl.textContent = slide.title;
            textEl.textContent = slide.text;
            const linkedProject = slide.slug ? getProjectBySlug(slide.slug) : null;
            if (linkedProject) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
                btn.innerHTML = '<i class="fas fa-circle-info"></i> Ver ficha';
                btn.onclick = () => openDetails(slide.slug);
            } else {
                btn.disabled = true;
                btn.style.opacity = '0.65';
                btn.style.cursor = 'not-allowed';
                btn.innerHTML = '<i class="fas fa-circle-info"></i> Solo informativo';
                btn.onclick = null;
            }
            renderSpotlightIllustration(slide);

            dots.innerHTML = SPOTLIGHT_SLIDES.map((s, idx) => {
                const active = idx === spotlightSlideIndex ? 'active' : '';
                return `<button type="button" class="spotlight-slider-dot ${active}" title="${s.title.replace(/"/g, '&quot;')}" onclick="setSpotlightSlide(${idx})"></button>`;
            }).join('');
        }

        function setSpotlightSlide(nextIndex) {
            if (!SPOTLIGHT_SLIDES.length) return;
            const safe = Number.isFinite(Number(nextIndex)) ? Number(nextIndex) : 0;
            spotlightSlideIndex = ((safe % SPOTLIGHT_SLIDES.length) + SPOTLIGHT_SLIDES.length) % SPOTLIGHT_SLIDES.length;
            renderSpotlightSlider(true);
            restartSpotlightSliderAuto();
        }

        function initSpotlightSlider() {
            spotlightSlideIndex = 0;
            renderSpotlightSlider(false);
            restartSpotlightSliderAuto();
            if (!spotlightCanvasResizeHandlerBound) {
                window.addEventListener('resize', () => renderSpotlightSlider(false));
                spotlightCanvasResizeHandlerBound = true;
            }
        }

        function getProjectBySlug(slug) {
            return Array.isArray(allProjects) ? allProjects.find((p) => p.slug === slug) : null;
        }

        function getDownloadKeyForProject(project) {
            return `project_${project.slug}`;
        }

        function isActiveDownloadPhase(phase) {
            return ['checking', 'available', 'queued', 'waiting', 'preparing', 'downloading', 'launching'].includes(String(phase || ''));
        }

        function getDownloadPhaseLabel(phase) {
            const p = String(phase || '');
            if (p === 'checking') return 'VERIFICANDO';
            if (p === 'available') return 'DISPONIBLE';
            if (p === 'queued') return 'EN COLA';
            if (p === 'waiting') return 'EN ESPERA';
            if (p === 'preparing') return 'PREPARANDO';
            if (p === 'downloading') return 'DESCARGANDO';
            if (p === 'launching') return 'ABRIENDO';
            if (p === 'ready') return 'LISTO';
            if (p === 'done') return 'FINALIZADO';
            if (p === 'cancelled') return 'CANCELADO';
            if (p === 'error') return 'ERROR';
            return 'IDLE';
        }

        function shouldRefreshExternalProgressUi(key, payload) {
            if (!key) return true;
            if (payload?.phase !== 'downloading') return true;
            const now = Date.now();
            const pct = Math.round(Number(payload?.percent || 0));
            const msg = String(payload?.message || '');
            const prev = externalProgressUiState[key] || { at: 0, pct: -1, msg: '' };
            const byPct = Math.abs(pct - prev.pct) >= 2;
            const byTime = (now - prev.at) >= 900;
            const byMsg = msg && msg !== prev.msg && (now - prev.at) >= 650;
            const isEdge = pct <= 1 || pct >= 99;
            const should = byPct || byTime || byMsg || isEdge;
            if (should) externalProgressUiState[key] = { at: now, pct, msg };
            return should;
        }

        function createDefaultDownloadSession(key) {
            return {
                key,
                name: 'Descarga',
                slug: '',
                icon: STORE_LOCAL_ICON,
                phase: 'idle',
                percent: 0,
                sizeBytes: 0,
                downloadedBytes: 0,
                speedBps: 0,
                etaSeconds: null,
                status: '',
                isApp: false,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                autoRemoveAt: 0,
            };
        }

        function updateDownloadSession(key, patch = {}) {
            if (!key) return;
            const prev = downloadSessions[key] || createDefaultDownloadSession(key);
            const next = {
                ...prev,
                ...patch,
                key,
                updatedAt: Date.now(),
            };
            next.percent = Math.max(0, Math.min(100, Number(next.percent || 0)));
            if (next.phase === 'ready' || next.phase === 'done' || next.phase === 'cancelled') {
                next.autoRemoveAt = Date.now() + 25000;
            } else if (next.phase === 'error') {
                next.autoRemoveAt = Date.now() + 45000;
            } else {
                next.autoRemoveAt = 0;
            }
            downloadSessions[key] = next;
            if (!sidebarSelectedDownloadKey) {
                sidebarSelectedDownloadKey = key;
            }
            requestRenderDownloadSurfaces();
        }

        function removeDownloadSession(key) {
            if (!key || !downloadSessions[key]) return;
            delete downloadSessions[key];
            if (sidebarSelectedDownloadKey === key) {
                sidebarSelectedDownloadKey = '';
                sidebarSelectionPinnedByUser = false;
            }
            requestRenderDownloadSurfaces({ immediate: true });
        }

        function purgeStaleDownloadSessions() {
            const now = Date.now();
            Object.keys(downloadSessions).forEach((key) => {
                const item = downloadSessions[key];
                if (!item) return;
                if (item.autoRemoveAt > 0 && now >= item.autoRemoveAt) {
                    delete downloadSessions[key];
                }
            });
        }

        function getDownloadSessionsList() {
            purgeStaleDownloadSessions();
            return Object.values(downloadSessions).sort((a, b) => {
                const aa = isActiveDownloadPhase(a.phase) ? 1 : 0;
                const bb = isActiveDownloadPhase(b.phase) ? 1 : 0;
                if (aa !== bb) return bb - aa;
                return (a.createdAt || 0) - (b.createdAt || 0);
            });
        }

        function getActiveDownloadSessions() {
            return getDownloadSessionsList().filter((d) => isActiveDownloadPhase(d.phase));
        }

        function cycleSidebarDownload(direction = 1) {
            const list = getActiveDownloadSessions();
            if (!list.length) return;
            const step = Number(direction) >= 0 ? 1 : -1;
            const len = list.length;
            const currentIdx = list.findIndex((item) => item.key === sidebarSelectedDownloadKey);
            const baseIdx = currentIdx >= 0 ? currentIdx : Math.min(Math.max(sidebarDownloadCursor, 0), len - 1);
            const nextIdx = (baseIdx + step + len) % len;
            sidebarDownloadCursor = nextIdx;
            sidebarSelectedDownloadKey = list[nextIdx]?.key || '';
            sidebarSelectionPinnedByUser = true;
            renderSidebarDownloadDock();
        }

        function renderSidebarDownloadDock() {
            const dock = document.getElementById('sidebar-download-dock');
            const countBadge = document.getElementById('dock-count-badge');
            const icon = document.getElementById('dock-item-icon');
            const title = document.getElementById('dock-item-title');
            const status = document.getElementById('dock-item-status');
            const progress = document.getElementById('dock-item-progress');
            const loader = document.getElementById('dock-item-loader');
            const prevBtn = document.getElementById('dock-prev-btn');
            const nextBtn = document.getElementById('dock-next-btn');
            const index = document.getElementById('dock-item-index');
            if (!dock) return;

            const items = getActiveDownloadSessions();
            if (!items.length) {
                dock.classList.remove('visible');
                sidebarDownloadCursor = 0;
                sidebarSelectedDownloadKey = '';
                sidebarSelectionPinnedByUser = false;
                return;
            }

            let selectedIdx = items.findIndex((item) => item.key === sidebarSelectedDownloadKey);
            if (selectedIdx === -1 && !sidebarSelectionPinnedByUser && activeInstallTaskKey) {
                selectedIdx = items.findIndex((item) => item.key === activeInstallTaskKey);
            }
            if (selectedIdx === -1) {
                selectedIdx = Math.min(Math.max(sidebarDownloadCursor, 0), items.length - 1);
            }
            const current = items[selectedIdx];
            sidebarDownloadCursor = selectedIdx;
            sidebarSelectedDownloadKey = current?.key || '';
            dock.classList.add('visible');
            if (countBadge) countBadge.textContent = String(items.length);
            if (icon) icon.src = current.icon || STORE_LOCAL_ICON;
            if (title) title.textContent = current.name || 'Descarga';
            if (status) {
                status.textContent = current.status
                    || `${getDownloadPhaseLabel(current.phase)} ${current.percent > 0 ? `${Math.round(current.percent)}%` : ''}`.trim();
            }
            if (progress) progress.style.width = `${Math.round(current.percent || 0)}%`;
            if (loader) {
                loader.style.display = (current.phase === 'preparing' || current.phase === 'queued' || current.phase === 'waiting') ? 'block' : 'none';
            }
            if (prevBtn) prevBtn.disabled = items.length < 2;
            if (nextBtn) nextBtn.disabled = items.length < 2;
            if (index) index.textContent = `${selectedIdx + 1}/${items.length}`;
        }

        function renderDownloadsActivityList() {
            const container = document.getElementById('downloads-activity-list');
            if (!container) return;
            const entries = getDownloadSessionsList();
            if (!entries.length) {
                container.innerHTML = `
                    <div class="download-item waiting">
                        <img class="avatar" src="${STORE_LOCAL_ICON}" alt="OWS">
                        <div class="download-item-main">
                            <div class="download-item-head">
                                <div class="download-item-title">Sin descargas activas</div>
                                <div class="download-item-phase">IDLE</div>
                            </div>
                            <div class="download-item-meta">Cuando inicies una descarga o update, aparecera aqui.</div>
                            <div class="download-item-progress-wrap">
                                <div class="download-item-progress"></div>
                            </div>
                        </div>
                    </div>`;
                return;
            }

            container.innerHTML = entries.map((item) => {
                const sizeText = formatByteSize(item.sizeBytes || 0);
                const downloadedText = item.downloadedBytes > 0 ? formatByteSize(item.downloadedBytes) : '-';
                const speedText = item.speedBps > 0 ? `${formatByteSize(item.speedBps)}/s` : '-';
                const etaText = formatEta(item.etaSeconds);
                const phaseLabel = getDownloadPhaseLabel(item.phase);
                const showProgress = item.phase === 'downloading' || item.phase === 'launching' || item.phase === 'ready' || item.phase === 'done';
                const metaText = item.status
                    || `Tamano ${sizeText} | Recibido ${downloadedText} | Velocidad ${speedText} | ETA ${etaText}`;
                return `
                    <div class="download-item ${item.phase}">
                        <img class="avatar" src="${item.icon || STORE_LOCAL_ICON}" alt="${item.name}">
                        <div class="download-item-main">
                            <div class="download-item-head">
                                <div class="download-item-title">${item.name}</div>
                                <div class="download-item-phase">${phaseLabel}</div>
                            </div>
                            <div class="download-item-meta">${metaText}</div>
                            <div class="download-item-progress-wrap ${showProgress ? 'show' : ''}">
                                <div class="download-item-progress" style="width:${Math.round(item.percent || 0)}%"></div>
                            </div>
                        </div>
                        <div class="download-item-loader"></div>
                    </div>`;
            }).join('');
        }

        function renderExploreInsights() {
            const totalEl = document.getElementById('explore-metric-total');
            const installedEl = document.getElementById('explore-metric-installed');
            const updatesEl = document.getElementById('explore-metric-updates');
            const releaseFeed = document.getElementById('explore-release-feed');
            const downloadPreview = document.getElementById('explore-download-preview');

            if (totalEl) totalEl.textContent = String(allProjects.length || 0);
            if (installedEl) {
                const installedCount = allProjects.filter((p) => Boolean(installStateBySlug[p.slug]?.installed)).length;
                installedEl.textContent = String(installedCount);
            }
            if (updatesEl) updatesEl.textContent = String(getPendingProjectUpdates().length);

            if (releaseFeed) {
                const top = [...allProjects]
                    .sort((a, b) => {
                        const ad = Date.parse(a?.last_update_at || '') || 0;
                        const bd = Date.parse(b?.last_update_at || '') || 0;
                        return bd - ad;
                    })
                    .slice(0, 4);
                if (!top.length) {
                    releaseFeed.innerHTML = `<div class="spotlight-list-item"><span>Sin datos de releases</span><span>--</span></div>`;
                } else {
                    releaseFeed.innerHTML = top.map((p) => `
                        <div class="spotlight-list-item">
                            <span>${p.name}</span>
                            <span>v${p.version || '1.0.0'}</span>
                        </div>`).join('');
                }
            }

            if (downloadPreview) {
                const active = getActiveDownloadSessions().slice(0, 3);
                if (!active.length) {
                    downloadPreview.innerHTML = `<div class="spotlight-list-item"><span>Sin descargas activas</span><span>Idle</span></div>`;
                } else {
                    downloadPreview.innerHTML = active.map((d) => `
                        <div class="spotlight-list-item">
                            <span>${d.name}</span>
                            <span>${Math.round(d.percent || 0)}%</span>
                        </div>`).join('');
                }
            }
        }

        function renderDownloadSurfaces() {
            renderDownloadsActivityList();
            renderSidebarDownloadDock();
            renderExploreInsights();
        }

        function requestRenderDownloadSurfaces(options = {}) {
            const immediate = Boolean(options.immediate);
            if (immediate) {
                downloadSurfacesRenderQueued = false;
                downloadSurfacesLastRenderedAt = Date.now();
                renderDownloadSurfaces();
                return;
            }
            if (downloadSurfacesRenderQueued) return;
            const elapsed = Date.now() - downloadSurfacesLastRenderedAt;
            const waitMs = elapsed >= 280 ? 0 : (280 - elapsed);
            downloadSurfacesRenderQueued = true;
            setTimeout(() => {
                downloadSurfacesRenderQueued = false;
                downloadSurfacesLastRenderedAt = Date.now();
                renderDownloadSurfaces();
            }, waitMs);
        }

        function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function isProjectQueued(slug) {
            return projectInstallQueue.some((item) => item.slug === slug);
        }

        function syncQueueMarkers() {
            const pending = [...projectInstallQueue];
            pending.forEach((item, idx) => {
                updateDownloadSession(item.key, {
                    phase: idx === 0 && !activeInstallTaskKey ? 'waiting' : 'queued',
                    status: idx === 0 && !activeInstallTaskKey
                        ? 'En espera para iniciar descarga...'
                        : `En cola (#${idx + 1})`,
                    percent: 0,
                });
                setRuntimeState(item.slug, { phase: idx === 0 && !activeInstallTaskKey ? 'preparing' : 'queued', percent: 0, taskId: `install_${item.slug}` });
            });
            requestRenderDownloadSurfaces({ immediate: true });
        }

        async function processProjectInstallQueue() {
            if (installQueueProcessing) return;
            if (!projectInstallQueue.length) {
                syncQueueMarkers();
                return;
            }
            installQueueProcessing = true;
            while (projectInstallQueue.length) {
                const item = projectInstallQueue.shift();
                if (!item) break;
                const project = getProjectBySlug(item.slug);
                if (!project) continue;
                const blockedByStore = await ensureStoreIsUpToDateForProjectAction(`instalar o actualizar ${project.name}`, { openUpdates: false });
                if (blockedByStore) {
                    const blockedStatus = 'Bloqueado por OWS Store obsoleta. Actualiza OWS Store para continuar.';
                    const blockedItems = [item, ...projectInstallQueue.splice(0)];
                    blockedItems.forEach((queued) => {
                        const queuedProject = getProjectBySlug(queued.slug);
                        setRuntimeState(queued.slug, { phase: 'idle', percent: 0, taskId: '' });
                        updateDownloadSession(queued.key, {
                            phase: 'error',
                            percent: 0,
                            status: blockedStatus,
                        });
                        if (queuedProject) {
                            addNotification(`Instalacion bloqueada para ${queuedProject.name}: OWS Store necesita update.`, 'warning');
                        }
                    });
                    const updatesStatusBlocked = document.getElementById('updates-project-status');
                    if (updatesStatusBlocked) updatesStatusBlocked.textContent = blockedStatus;
                    activeInstallTaskKey = '';
                    syncQueueMarkers();
                    break;
                }
                activeInstallTaskKey = item.key;
                const updatesStatus = document.getElementById('updates-project-status');
                if (updatesStatus) updatesStatus.textContent = 'Preparando instalador de ' + project.name + '...';
                setRuntimeState(project.slug, { phase: 'preparing', percent: 0, taskId: `install_${project.slug}` });
                updateDownloadSession(item.key, {
                    name: project.name,
                    slug: project.slug,
                    icon: getProjectIcon(project, 64),
                    phase: 'preparing',
                    percent: 0,
                    status: 'Preparando instalador...',
                    sizeBytes: 0,
                    downloadedBytes: 0,
                    speedBps: 0,
                    etaSeconds: null,
                });
                showActionMessage('Preparando instalador de ' + project.name + '...', { sticky: true, state: 'checking', title: project.name });
                requestRenderDownloadSurfaces({ immediate: true });
                await sleep(120);

                if (item.platform === 'android') {
                    const useExternalCompat = shouldUseAndroidExternalInstallCompat();
                    if (useExternalCompat) {
                        if (updatesStatus) updatesStatus.textContent = 'Descargando APK de ' + project.name + ' (modo compatibilidad)...';
                        setRuntimeState(project.slug, { phase: 'launching', percent: 100, taskId: `install_${project.slug}` });
                        updateDownloadSession(item.key, {
                            phase: 'launching',
                            percent: 100,
                            status: 'Abriendo descarga externa del APK (modo compatibilidad)...',
                            downloadedBytes: Number(item.sizeBytes || 0),
                            etaSeconds: 0,
                        });
                        showActionMessage('Abriendo descarga externa de ' + project.name + ' (modo compatibilidad)...', {
                            sticky: true,
                            state: 'downloading',
                            title: project.name,
                            showProgress: true,
                        });
                        openExternal(item.url);
                        persistAndroidInstallMarker(project, item);
                        setRuntimeState(project.slug, { phase: 'ready', percent: 100, taskId: '' });
                        updateDownloadSession(item.key, {
                            phase: 'ready',
                            percent: 100,
                            status: 'APK enviado a descarga externa. Completa la instalacion desde Descargas.',
                            etaSeconds: 0,
                            downloadedBytes: Number(item.sizeBytes || 0),
                        });
                        if (updatesStatus) updatesStatus.textContent = 'APK enviado a descarga externa para ' + project.name;
                        addNotification('Modo compatibilidad: APK de ' + project.name + ' enviado a descarga externa.', 'success');
                        showActionMessage('APK de ' + project.name + ' enviado a descarga externa. Instala desde Descargas.', { state: 'ready' });
                        await refreshInstallationStates();
                        scheduleSectionRender({ projects: true, library: true, immediate: true });
                        activeInstallTaskKey = '';
                        syncQueueMarkers();
                        continue;
                    }

                    if (!window.owsUpdater?.installExternalInstaller && isNativeAndroidRuntime()) {
                        if (updatesStatus) updatesStatus.textContent = 'Descargando APK de ' + project.name + ' en OWS Store...';
                        showActionMessage('Descargando APK de ' + project.name + ' en OWS Store...', {
                            sticky: true,
                            state: 'downloading',
                            title: project.name,
                            showProgress: true,
                        });
                        const nativeResult = await installAndroidApkInApp({
                            url: item.url,
                            fileName: item.fileName || `${project.name || 'android-app'}.apk`,
                            taskId: `install_${project.slug}`,
                            sessionKey: item.key,
                            slug: project.slug,
                            projectName: project.name,
                            expectedSize: Number(item.sizeBytes || 0),
                            expectedSha256: String(item.sha256 || ''),
                            sessionIsApp: false,
                        });
                        if (!nativeResult?.ok) {
                            if (nativeResult?.code === 'unknown_sources_not_confirmed') {
                                const waitMsg = 'Instalacion pausada. Habilita "Instalar apps desconocidas" para OWS Store y reintenta.';
                                setRuntimeState(project.slug, { phase: 'idle', percent: 0, taskId: '' });
                                updateDownloadSession(item.key, {
                                    phase: 'ready',
                                    status: waitMsg,
                                });
                                if (updatesStatus) updatesStatus.textContent = waitMsg;
                                addNotification(waitMsg, 'warning');
                                showActionMessage(waitMsg, { state: 'info' });
                                await refreshInstallationStates();
                                scheduleSectionRender({ projects: true, library: true, immediate: true });
                                activeInstallTaskKey = '';
                                syncQueueMarkers();
                                continue;
                            }
                            const errorDetail = formatInstallErrorDetail(nativeResult, 'desconocido');
                            setRuntimeState(project.slug, { phase: 'idle', percent: 0, taskId: '' });
                            updateDownloadSession(item.key, {
                                phase: 'error',
                                status: 'Error instalando APK en app: ' + errorDetail,
                            });
                            if (updatesStatus) updatesStatus.textContent = 'Error instalando APK de ' + project.name;
                            addNotification('Error instalando APK de ' + project.name + ': ' + errorDetail, 'error');
                            showActionMessage('Error instalando APK de ' + project.name + ': ' + errorDetail, { state: 'error' });
                            await refreshInstallationStates();
                            scheduleSectionRender({ projects: true, library: true, immediate: true });
                            activeInstallTaskKey = '';
                            syncQueueMarkers();
                            continue;
                        }
                    } else if (window.owsUpdater?.installExternalInstaller) {
                        if (updatesStatus) updatesStatus.textContent = 'Descargando APK de ' + project.name + '...';
                        showActionMessage('Descargando APK de ' + project.name + '...', {
                            sticky: true,
                            state: 'downloading',
                            title: project.name,
                            showProgress: true,
                        });
                        const result = await window.owsUpdater.installExternalInstaller({
                            url: item.url,
                            name: item.fileName || `${project.name || 'android-app'}.apk`,
                            taskId: `install_${project.slug}`,
                            expectedSize: Number(item.sizeBytes || 0),
                        });
                        if (!result?.ok) {
                            const errorDetail = formatInstallErrorDetail(result, 'desconocido');
                            setRuntimeState(project.slug, { phase: 'idle', percent: 0, taskId: '' });
                            updateDownloadSession(item.key, {
                                phase: 'error',
                                status: 'Error al descargar APK: ' + errorDetail,
                            });
                            if (updatesStatus) updatesStatus.textContent = 'Error descargando APK de ' + project.name;
                            addNotification('Error al descargar APK de ' + project.name + ': ' + errorDetail, 'error');
                            showActionMessage('Error al descargar APK de ' + project.name + ': ' + errorDetail, { state: 'error' });
                            await refreshInstallationStates();
                            scheduleSectionRender({ projects: true, library: true, immediate: true });
                            activeInstallTaskKey = '';
                            syncQueueMarkers();
                            continue;
                        }
                    } else {
                        if (updatesStatus) updatesStatus.textContent = 'Iniciando instalador APK de ' + project.name + '...';
                        setRuntimeState(project.slug, { phase: 'launching', percent: 100, taskId: `install_${project.slug}` });
                        updateDownloadSession(item.key, {
                            phase: 'launching',
                            percent: 100,
                            status: 'Abriendo instalador Android...',
                            downloadedBytes: Number(item.sizeBytes || 0),
                            etaSeconds: 0,
                        });
                        showActionMessage('Abriendo instalador Android de ' + project.name + '...', {
                            sticky: true,
                            state: 'downloading',
                            title: project.name,
                            showProgress: true,
                        });
                        openExternal(item.url);
                    }

                    // Android confirms install outside app; persist target metadata now to keep update tracking coherent.
                    persistAndroidInstallMarker(project, item);
                    setRuntimeState(project.slug, { phase: 'ready', percent: 100, taskId: '' });
                    updateDownloadSession(item.key, {
                        phase: 'ready',
                        percent: 100,
                        status: 'APK abierto. Completa la instalacion en Android.',
                        etaSeconds: 0,
                        downloadedBytes: Number(item.sizeBytes || 0),
                    });
                    if (updatesStatus) updatesStatus.textContent = 'APK abierto para ' + project.name;
                    addNotification('APK abierto para ' + project.name + '. Completa la instalacion en Android.', 'success');
                    showActionMessage('APK abierto para ' + project.name + '.', { state: 'ready' });
                    await refreshInstallationStates();
                    scheduleSectionRender({ projects: true, library: true, immediate: true });
                    activeInstallTaskKey = '';
                    syncQueueMarkers();
                    continue;
                }

                if (!window.owsUpdater?.installExternalInstaller) {
                    updateDownloadSession(item.key, { phase: 'error', status: 'Updater no disponible para instalar externo.' });
                    setRuntimeState(project.slug, { phase: 'idle', percent: 0, taskId: '' });
                    addNotification('Updater no disponible para instalar ' + project.name + '.', 'error');
                    continue;
                }

                if (updatesStatus) updatesStatus.textContent = 'Descargando instalador de ' + project.name + '...';
                showActionMessage('Descargando instalador de ' + project.name + '...', { sticky: true, state: 'downloading', title: project.name, showProgress: true });
                const result = await window.owsUpdater.installExternalInstaller({
                    url: item.url,
                    name: item.fileName,
                    taskId: `install_${project.slug}`,
                    expectedSize: Number(item.sizeBytes || 0),
                });
                if (!result?.ok) {
                    const errorDetail = formatInstallErrorDetail(result, 'desconocido');
                    setRuntimeState(project.slug, { phase: 'idle', percent: 0, taskId: '' });
                    updateDownloadSession(item.key, {
                        phase: 'error',
                        status: 'Error al instalar: ' + errorDetail,
                    });
                    if (updatesStatus) updatesStatus.textContent = 'Error instalando ' + project.name;
                    addNotification('Error al instalar ' + project.name + ': ' + errorDetail, 'error');
                    showActionMessage('Error al instalar ' + project.name + ': ' + errorDetail, { state: 'error' });
                    await refreshInstallationStates();
                    scheduleSectionRender({ projects: true, library: true, immediate: true });
                    activeInstallTaskKey = '';
                    syncQueueMarkers();
                    continue;
                }
                localStorage.setItem(`installed_${project.slug}`, project.version || 'latest');
                localStorage.setItem(`installed_platform_${project.slug}`, 'windows');
                localStorage.removeItem(`installed_version_code_${project.slug}`);
                setInstalledReleasePublishedAt(
                    project.slug,
                    'windows',
                    item.releasePublishedAt || project.windows_last_update_at || project.last_update_at || ''
                );
                setRuntimeState(project.slug, { phase: 'installed', percent: 100, taskId: '' });
                updateDownloadSession(item.key, {
                    phase: 'done',
                    percent: 100,
                    status: 'Instalador abierto para continuar.',
                    etaSeconds: 0,
                    downloadedBytes: item.sizeBytes || 0,
                });
                if (updatesStatus) updatesStatus.textContent = 'Instalador abierto para ' + project.name;
                addNotification('Instalador abierto para ' + project.name + '.', 'success');
                showActionMessage('Instalador abierto para ' + project.name + '.', { state: 'ready' });
                await refreshInstallationStates();
                scheduleSectionRender({ projects: true, library: true, immediate: true });
                activeInstallTaskKey = '';
                syncQueueMarkers();
            }
            installQueueProcessing = false;
            activeInstallTaskKey = '';
            requestRenderDownloadSurfaces({ immediate: true });
        }

        function addNotification(text, tone = 'neutral') {
            const colorMap = {
                neutral: '#595a66',
                success: '#1f9d63',
                warning: '#b96700',
                error: '#c0392b',
            };
            notificationLog.unshift({
                text,
                tone,
                at: new Date(),
            });
            if (notificationLog.length > 20) notificationLog.length = 20;

            const list = document.getElementById('notifications-list');
            if (!list) return;
            list.innerHTML = notificationLog.map((item) => {
                const stamp = item.at.toLocaleTimeString();
                const color = colorMap[item.tone] || colorMap.neutral;
                return `<div class="notification-card" style="--tone-color:${color};">
                    <div class="notification-time">${stamp}</div>
                    <div class="notification-text">${item.text}</div>
                </div>`;
            }).join('');
        }

        function setUpdateBannerVisual(options = {}) {
            const banner = document.getElementById('update-banner');
            const titleEl = document.getElementById('update-title');
            const msgEl = document.getElementById('update-msg');
            const metaEl = document.getElementById('update-meta');
            const iconEl = document.getElementById('update-icon-glyph');
            const normalizedState = UPDATE_BANNER_STATES.includes(options.state) ? options.state : 'info';
            if (!banner) return;

            UPDATE_BANNER_STATES.forEach((s) => banner.classList.remove(`state-${s}`));
            banner.classList.add(`state-${normalizedState}`);

            if (titleEl && typeof options.title === 'string') titleEl.textContent = options.title;
            if (msgEl && typeof options.message === 'string') msgEl.textContent = options.message;
            if (metaEl && typeof options.meta === 'string') metaEl.textContent = options.meta;

            if (iconEl) {
                iconEl.className = `fas ${options.iconClass || 'fa-circle-info'}`;
                iconEl.classList.toggle('spin', Boolean(options.iconSpin));
            }
        }

        function dismissUpdateBanner(force = false) {
            const banner = document.getElementById('update-banner');
            if (!banner) return;
            if (actionBannerSticky && !force) return;
            banner.classList.remove('visible');
            if (actionBannerTimer) {
                clearTimeout(actionBannerTimer);
                actionBannerTimer = null;
            }
            actionBannerSticky = false;
        }

        function inferActionBannerState(text = '', options = {}) {
            if (options.state && UPDATE_BANNER_STATES.includes(options.state)) return options.state;
            const sample = String(text || '').toLowerCase();
            if (sample.includes('error') || sample.includes('fall')) return 'error';
            if (sample.includes('cancelad')) return 'info';
            if (sample.includes('descargando') || sample.includes('instalando')) return 'downloading';
            if (sample.includes('abriendo') || sample.includes('completa') || sample.includes('lista')) return 'ready';
            return options.sticky ? 'downloading' : 'info';
        }

        function showActionMessage(text, options = {}) {
            const banner = document.getElementById('update-banner');
            const closeBtn = document.getElementById('btn-close-update-banner');
            const installBtn = document.getElementById('btn-install-update');
            const progressWrap = document.getElementById('update-progress-wrap');
            if (!banner) return;
            const sticky = Boolean(options?.sticky);
            const state = inferActionBannerState(text, options);
            const stateMap = {
                checking: { title: 'Verificando', icon: 'fa-magnifying-glass', spin: true },
                available: { title: 'Update disponible', icon: 'fa-arrow-up', spin: false },
                downloading: { title: 'Descargando', icon: 'fa-download', spin: true },
                ready: { title: 'Accion requerida', icon: 'fa-circle-check', spin: false },
                success: { title: 'Completado', icon: 'fa-circle-check', spin: false },
                error: { title: 'Error', icon: 'fa-triangle-exclamation', spin: false },
                info: { title: 'Estado', icon: 'fa-circle-info', spin: false },
            };
            const cfg = stateMap[state] || stateMap.info;

            actionBannerSticky = sticky;
            if (installBtn && !options.keepInstallButton) installBtn.style.display = 'none';
            if (progressWrap && !options.showProgress) progressWrap.style.display = 'none';
            if (closeBtn) {
                closeBtn.disabled = sticky;
                closeBtn.style.opacity = sticky ? '0.45' : '1';
                closeBtn.style.cursor = sticky ? 'not-allowed' : 'pointer';
            }
            setUpdateBannerVisual({
                state,
                title: options.title || cfg.title,
                message: text,
                iconClass: options.iconClass || cfg.icon,
                iconSpin: options.iconSpin ?? cfg.spin,
                meta: typeof options.meta === 'string' ? options.meta : document.getElementById('update-meta')?.textContent || '',
            });
            banner.classList.add('visible');

            if (actionBannerTimer) {
                clearTimeout(actionBannerTimer);
                actionBannerTimer = null;
            }
            if (!sticky) {
                actionBannerTimer = setTimeout(() => dismissUpdateBanner(true), options.durationMs || 4800);
            }
        }

        function getRuntimeState(slug) {
            return installRuntimeBySlug[slug] || { phase: 'idle', percent: 0, taskId: '' };
        }

        function isInstallingPhase(phase) {
            return phase === 'preparing' || phase === 'downloading' || phase === 'launching';
        }

        function patchInstallProgressUI(slug) {
            if (!slug) return;
            const runtime = getRuntimeState(slug);
            const installing = isInstallingPhase(runtime.phase);
            const pct = Math.max(0, Math.min(100, Math.round(Number(runtime.percent || 0))));
            const queued = runtime.phase === 'queued';
            const preparing = runtime.phase === 'preparing';

            const ecoText = document.getElementById(`installing-text-${slug}`);
            if (ecoText) {
                ecoText.style.display = (installing || queued || preparing) ? 'block' : 'none';
                if (queued) ecoText.textContent = 'En cola para descarga...';
                else if (preparing) ecoText.textContent = 'Preparando instalador...';
                else ecoText.textContent = `Instalando: ${pct}%`;
            }

            const libStatus = document.getElementById(`lib-status-${slug}`);
            if (libStatus) {
                if (queued) libStatus.textContent = 'EN COLA';
                else if (preparing) libStatus.textContent = 'PREPARANDO';
                else libStatus.textContent = installing ? `DESCARGANDO ${pct}%` : 'INSTALADO';
            }

            const libProgress = document.getElementById(`lib-progress-${slug}`);
            const libFill = document.getElementById(`lib-fill-${slug}`);
            if (libProgress && libFill) {
                libProgress.style.display = installing ? 'block' : 'none';
                libFill.style.width = `${pct}%`;
            }
        }

        function setRuntimeState(slug, next) {
            installRuntimeBySlug[slug] = { ...getRuntimeState(slug), ...next };
            patchInstallProgressUI(slug);
        }

        function isBusyInstalling(slug) {
            const phase = getRuntimeState(slug).phase;
            return isInstallingPhase(phase) || phase === 'queued' || phase === 'waiting';
        }

        function normalizeVersionParts(v) {
            const parts = String(v || '').match(/\d+/g);
            return Array.isArray(parts) ? parts.map(n => Number(n)) : [];
        }

        function compareVersionLike(a, b) {
            const pa = normalizeVersionParts(a);
            const pb = normalizeVersionParts(b);
            const len = Math.max(pa.length, pb.length);
            for (let i = 0; i < len; i++) {
                const av = pa[i] || 0;
                const bv = pb[i] || 0;
                if (av > bv) return 1;
                if (av < bv) return -1;
            }
            return 0;
        }

        function extractVersionFromText(value) {
            const text = String(value || '');
            const match = text.match(/(\d+(?:[.-]\d+){2,}(?:-[A-Za-z]*\d{3,8})?)/);
            return match ? match[1] : '';
        }

        function isInstallableAndroidApkAsset(assetName) {
            const n = String(assetName || '').toLowerCase();
            if (!n.endsWith('.apk')) return false;
            if (n.includes('unsigned')) return false;
            if (n.includes('debug')) return false;
            return true;
        }

        function scoreAndroidAssetName(name, type = 'apk') {
            const n = String(name || '').toLowerCase();
            let score = 0;
            if (type === 'apk' && n.endsWith('.apk')) score += 12;
            if (type === 'aab' && n.endsWith('.aab')) score += 12;
            if (n.includes('signed')) score += 10;
            if (n.includes('release') && !n.includes('unsigned')) score += 6;
            if (n.includes('universal')) score += 2;
            if (n.includes('debug')) score -= 18;
            if (n.includes('unsigned')) score -= 30;
            return score;
        }

        function scoreWindowsAssetName(name) {
            const n = String(name || '').toLowerCase();
            let score = 0;
            if (n.endsWith('.exe')) score += 14;
            if (n.includes('setup') || n.includes('installer')) score += 8;
            if (n.includes('floret')) score += 8;
            if (n.includes('shop')) score += 4;
            if (n.includes('portable')) score -= 4;
            if (n.includes('unsigned')) score -= 16;
            if (n.includes('debug')) score -= 16;
            return score;
        }

        function pickLatestDate(...values) {
            let best = null;
            values.forEach((v) => {
                const t = Date.parse(v || '');
                if (Number.isNaN(t)) return;
                if (!best || t > best.time) best = { time: t, value: v };
            });
            return best?.value || null;
        }

        function normalizeDateVersionString(rawValue) {
            const raw = String(rawValue || '').trim();
            if (!raw) return '';
            const m = raw.match(/(\d{4})[.-](\d{1,2})[.-](\d{1,2})(?:[-_]?(\d{3,4}))?/);
            if (!m) return raw;
            const year = Number(m[1]);
            const month = Number(m[2]);
            const day = Number(m[3]);
            const suffix = m[4] ? Number(m[4]) : 0;
            if (!year || !month || !day) return raw;
            return suffix > 0
                ? `${year}.${month}.${day}-${suffix}`
                : `${year}.${month}.${day}`;
        }

        function deriveVersionCodeFromVersionName(versionName) {
            const m = String(versionName || '').match(/(\d{4})\.(\d{1,2})\.(\d{1,2})-(\d{3,4})/);
            if (!m) return 0;
            const yy = String(m[1]).slice(-2).padStart(2, '0');
            const mm = String(Number(m[2])).padStart(2, '0');
            const dd = String(Number(m[3])).padStart(2, '0');
            const hhmm = String(Number(m[4])).padStart(4, '0');
            return Number(`${yy}${mm}${dd}${hhmm}`) || 0;
        }

        function pickNewestAndroidRelease(primary, fallback) {
            if (!primary) return fallback || null;
            if (!fallback) return primary;
            const primaryVersion = String(primary.version || '').trim();
            const fallbackVersion = String(fallback.version || '').trim();
            if (primaryVersion && fallbackVersion) {
                const cmp = compareVersionLike(primaryVersion, fallbackVersion);
                if (cmp !== 0) return cmp > 0 ? primary : fallback;
            }
            const primaryCode = Number(primary.versionCode || 0);
            const fallbackCode = Number(fallback.versionCode || 0);
            if (primaryCode > 0 && fallbackCode > 0 && primaryCode !== fallbackCode) {
                return primaryCode > fallbackCode ? primary : fallback;
            }
            const primaryDate = Date.parse(primary.publishedAt || '') || 0;
            const fallbackDate = Date.parse(fallback.publishedAt || '') || 0;
            if (primaryDate !== fallbackDate) return primaryDate > fallbackDate ? primary : fallback;
            return compareVersionLike(primary.version, fallback.version) >= 0 ? primary : fallback;
        }

        function getProjectDisplayVersion(project) {
            if (!project) return '1.0.0';
            if (isNativeAndroidRuntime() && supportsAndroidDownloads(project)) {
                return project.android_version || project.version || project.windows_version || '1.0.0';
            }
            if (supportsWindowsInstaller(project)) {
                return project.windows_version || project.version || project.android_version || '1.0.0';
            }
            return project.version || '1.0.0';
        }

        function normalizeNewsUpdateRecord(entry) {
            if (!entry || typeof entry !== 'object') return null;
            const updateDate = entry.update_date || entry.created_at || entry.updated_at || null;
            const changes = Array.isArray(entry.changes)
                ? entry.changes
                : String(entry.changes || '')
                    .split(/\r?\n/)
                    .map((line) => line.trim())
                    .filter(Boolean);
            const projects = Array.isArray(entry.project_names)
                ? entry.project_names.map((p) => String(p || '').toLowerCase()).filter(Boolean)
                : [];
            const title = String(entry.title || '').trim();
            if (!title) return null;
            const description = String(entry.description || '').trim();
            const searchText = `${title} ${description} ${changes.join(' ')} ${projects.join(' ')}`.toLowerCase();
            const isEvent = searchText.includes('evento') || searchText.includes('event') || searchText.includes('temporada');
            const platformHint = detectNewsPlatforms(`${title}\n${description}\n${changes.join('\n')}\n${projects.join(' ')}`);
            return {
                id: Number(entry.id || 0),
                title,
                description,
                changes,
                projectNames: projects,
                updateDate,
                isEvent,
                platforms: platformHint,
            };
        }

        function detectNewsPlatforms(rawText = '') {
            const text = String(rawText || '').toLowerCase();
            const hasAndroid = /\bandroid\b|\.apk\b|\.aab\b|play\s*store|mobile\b/.test(text);
            const hasWindows = /\bwindows\b|\.exe\b|desktop\b|pc\b|win32\b/.test(text);
            const explicitAll = /all platforms|cross[-\s]?platform|multi[-\s]?platform|todas las plataformas|ambas plataformas|windows y android|android y windows|both platforms/.test(text);
            if (explicitAll || (hasAndroid && hasWindows)) return ['windows', 'android'];
            if (hasAndroid) return ['android'];
            if (hasWindows) return ['windows'];
            return ['all'];
        }

        function getPlatformLabelFromKinds(kinds = []) {
            const set = new Set((Array.isArray(kinds) ? kinds : []).map((k) => String(k || '').toLowerCase()).filter(Boolean));
            if (set.has('windows') && set.has('android')) return 'Windows + Android';
            if (set.has('windows')) return 'Windows';
            if (set.has('android')) return 'Android';
            return 'Todas';
        }

        function getNewsPlatformsBadgeHtml(platformKinds = []) {
            const label = getPlatformLabelFromKinds(platformKinds);
            return `<span class="platform-pill is-disabled" style="display:inline-flex; align-items:center; gap:0.35rem; cursor:default; padding:0.22rem 0.58rem; font-size:0.64rem;">${label}</span>`;
        }

        function summarizeReleaseNotes(rawText = '', fallback = 'Sin notas detalladas.') {
            const lines = String(rawText || '')
                .split(/\r?\n/)
                .map((l) => l.replace(/^[#*\-\s>]+/, '').trim())
                .filter(Boolean);
            return lines[0] || fallback;
        }

        function getReleaseDerivedProjectEntries(project) {
            if (!project) return [];
            if (!isWildTransferProject(project) && !isFloretProject(project)) return [];
            const entries = [];
            const projectName = String(project.name || 'Proyecto');

            if (project.windows_version || project.windows_last_update_at || project.last_update_at) {
                entries.push({
                    id: 0,
                    title: `${projectName} Windows v${project.windows_version || project.version || '-'}`,
                    description: summarizeReleaseNotes(project.windows_release_notes, 'Version de Windows publicada en GitHub Releases.'),
                    changes: [],
                    projectNames: [String(project.slug || '').toLowerCase(), String(project.name || '').toLowerCase()],
                    updateDate: project.windows_last_update_at || project.last_update_at || null,
                    isEvent: false,
                    platforms: ['windows'],
                });
            }

            if (project.android_version || project.android_last_update_at || project.last_update_at) {
                entries.push({
                    id: 0,
                    title: `${projectName} Android v${project.android_version || project.version || '-'}`,
                    description: summarizeReleaseNotes(project.android_release_notes, 'Version de Android publicada en GitHub Releases.'),
                    changes: [],
                    projectNames: [String(project.slug || '').toLowerCase(), String(project.name || '').toLowerCase()],
                    updateDate: project.android_last_update_at || project.last_update_at || null,
                    isEvent: false,
                    platforms: ['android'],
                });
            }

            return entries;
        }

        async function fetchOWSNewsUpdates(force = false) {
            const now = Date.now();
            if (!force && owsNewsUpdatesCache.length && (now - owsNewsUpdatesFetchedAt) < OWS_NEWS_CACHE_TTL_MS) {
                return owsNewsUpdatesCache;
            }
            const res = await fetch(`${OWS_NEWS_UPDATES_API_URL}?nocache=${now}`);
            if (!res.ok) throw new Error(`OWS News API ${res.status}`);
            const payload = await res.json();
            const list = (Array.isArray(payload) ? payload : [])
                .map(normalizeNewsUpdateRecord)
                .filter(Boolean)
                .sort((a, b) => (Date.parse(b.updateDate || '') || 0) - (Date.parse(a.updateDate || '') || 0));
            owsNewsUpdatesCache = list;
            owsNewsUpdatesFetchedAt = now;
            return list;
        }

        function getProjectNewsAlias(project) {
            if (!project) return [];
            const aliases = new Set();
            aliases.add(String(project.slug || '').toLowerCase());
            aliases.add(String(project.name || '').toLowerCase());
            if (isWildWeaponProject(project)) {
                aliases.add('wildweapon');
                aliases.add('wildweapon mayhem');
            }
            if (isSSAProject(project)) aliases.add('savage space animals');
            if (isFloretProject(project)) aliases.add('floret');
            if (isWildTransferProject(project)) aliases.add('wild transfer');
            if (isVelocitySurgeProject(project)) aliases.add('velocity surge');
            if (isOceanPayProject(project)) aliases.add('ocean pay');
            if (isOWSNewsProject(project)) aliases.add('ows news');
            return [...aliases].filter(Boolean);
        }

        function doesNewsEntryMatchProject(entry, project) {
            if (!entry || !project) return false;
            const aliases = getProjectNewsAlias(project);
            if (!aliases.length) return false;
            const projectNames = Array.isArray(entry.projectNames) ? entry.projectNames : [];
            if (projectNames.some((p) => aliases.some((a) => p.includes(a) || a.includes(p)))) return true;
            const text = `${entry.title} ${entry.description} ${(entry.changes || []).join(' ')}`.toLowerCase();
            return aliases.some((alias) => alias && text.includes(alias));
        }

        function renderNewsHub() {
            const globalWrap = document.getElementById('news-hub-global');
            const eventsWrap = document.getElementById('news-hub-events');
            if (!globalWrap || !eventsWrap) return;
            const list = Array.isArray(owsNewsUpdatesCache) ? owsNewsUpdatesCache : [];
            const globals = list.filter((n) => !n.isEvent).slice(0, 4);
            const events = list.filter((n) => n.isEvent).slice(0, 4);

            const renderList = (items, fallbackText) => {
                if (!items.length) {
                    return `<div class="news-hub-item"><div class="news-hub-item-head"><div class="news-hub-item-title">${fallbackText}</div><div class="news-hub-item-date">--</div></div><div class="news-hub-item-meta">Los datos apareceran aqui en cuanto haya publicaciones.</div></div>`;
                }
                return items.map((item) => `
                    <div class="news-hub-item">
                        <div class="news-hub-item-head">
                            <div class="news-hub-item-title">${item.title}</div>
                            <div class="news-hub-item-date">${formatDateTime(item.updateDate)}</div>
                        </div>
                        <div class="news-hub-item-meta">${item.description || (item.changes[0] || 'Sin descripcion')}</div>
                        <div style="margin-top:0.35rem;">${getNewsPlatformsBadgeHtml(item.platforms || ['all'])}</div>
                    </div>
                `).join('');
            };

            globalWrap.innerHTML = renderList(globals, 'Sin noticias globales');
            eventsWrap.innerHTML = renderList(events, 'Sin eventos activos');
        }

        function renderProjectNewsInModal(project) {
            const changelogWrap = document.getElementById('m-changelog-list');
            const eventsWrap = document.getElementById('m-events-list');
            const newsWrap = document.getElementById('m-news-wrap');
            if (!changelogWrap || !eventsWrap || !newsWrap) return;
            const owsNewsEntries = (owsNewsUpdatesCache || []).filter((entry) => doesNewsEntryMatchProject(entry, project));
            const releaseEntries = getReleaseDerivedProjectEntries(project);
            const entries = [...releaseEntries, ...owsNewsEntries]
                .sort((a, b) => (Date.parse(b?.updateDate || '') || 0) - (Date.parse(a?.updateDate || '') || 0));
            const changelog = entries.filter((entry) => !entry.isEvent).slice(0, 4);
            const events = entries.filter((entry) => entry.isEvent).slice(0, 3);
            newsWrap.style.display = 'grid';
            changelogWrap.innerHTML = changelog.length
                ? changelog.map((item) => `
                    <div class="modal-news-item">
                        <strong>${item.title}</strong>
                        <span style="margin-bottom:0.2rem;">${getNewsPlatformsBadgeHtml(item.platforms || ['all'])}</span>
                        <span>${item.description || (item.changes[0] || 'Sin descripcion')}</span>
                        <span>${formatDateTime(item.updateDate)}</span>
                    </div>
                `).join('')
                : '<div class="modal-news-empty">Sin changelogs vinculados a este proyecto.</div>';
            eventsWrap.innerHTML = events.length
                ? events.map((item) => `
                    <div class="modal-news-item">
                        <strong>${item.title}</strong>
                        <span style="margin-bottom:0.2rem;">${getNewsPlatformsBadgeHtml(item.platforms || ['all'])}</span>
                        <span>${item.description || (item.changes[0] || 'Sin descripcion')}</span>
                        <span>${formatDateTime(item.updateDate)}</span>
                    </div>
                `).join('')
                : '<div class="modal-news-empty">Sin eventos vinculados a este proyecto.</div>';
        }

        function normalizePlatformKind(rawValue) {
            const raw = String(rawValue || '').toLowerCase();
            if (raw.includes('android')) return 'android';
            if (raw.includes('win')) return 'windows';
            return '';
        }

        function detectVersionFamily(versionText = '') {
            const value = String(versionText || '').trim();
            if (!value) return '';
            if (/^\d{4}[.-]\d{1,2}[.-]\d{1,2}(?:[-_]\d{3,4})?$/.test(value)) return 'date';
            if (/^\d+(?:\.\d+){1,3}(?:[-+][a-z0-9.\-_]+)?$/i.test(value)) return 'semver';
            return 'other';
        }

        function getPreferredInstalledPlatform(project, state = null) {
            if (!project) return '';
            const explicit = normalizePlatformKind(getInstalledPlatform(project.slug));
            if (explicit) {
                const device = detectCurrentDevicePlatform();
                if (device.platform === 'android' && explicit === 'windows' && supportsAndroidDownloads(project)) return 'android';
                if (device.platform === 'windows' && explicit === 'android' && supportsWindowsInstaller(project)) return 'windows';
                return explicit;
            }
            const current = state || installStateBySlug[project.slug] || {};
            if (current?.exePath) return 'windows';
            const device = detectCurrentDevicePlatform();
            if (device.platform === 'android' && supportsAndroidDownloads(project)) return 'android';
            if (device.platform === 'windows' && supportsWindowsInstaller(project)) return 'windows';
            if (supportsAndroidDownloads(project) && !supportsWindowsInstaller(project)) return 'android';
            if (supportsWindowsInstaller(project) && !supportsAndroidDownloads(project)) return 'windows';
            if (supportsWindowsInstaller(project)) return 'windows';
            if (supportsAndroidDownloads(project)) return 'android';
            return '';
        }

        function getResolvedUpdatePlatforms(info = null) {
            const entries = Array.isArray(info?.updatePlatforms) ? info.updatePlatforms : [];
            const normalized = entries
                .map((d) => normalizePlatformKind(d?.platform))
                .filter(Boolean);
            if (normalized.length) return [...new Set(normalized)];
            const installedPlatform = normalizePlatformKind(info?.installedPlatform || '');
            return installedPlatform ? [installedPlatform] : [];
        }

        function getPrimaryUpdatePlatformLabel(info = null) {
            const kinds = getResolvedUpdatePlatforms(info);
            if (!kinds.length) return 'Windows';
            if (kinds.length > 1) return kinds.includes('windows') && kinds.includes('android') ? 'Windows + Android' : kinds.join(' + ').toUpperCase();
            return kinds[0] === 'android' ? 'Android' : 'Windows';
        }

        function detectCurrentDevicePlatform() {
            if (isNativeAndroidRuntime()) {
                return { platform: 'android', label: 'Android', source: 'capacitor', detected: true };
            }
            if (typeof window.owsUpdater !== 'undefined') {
                return { platform: 'windows', label: 'Windows', source: 'electron', detected: true };
            }
            const ua = String(navigator.userAgent || '').toLowerCase();
            if (ua.includes('android')) return { platform: 'android', label: 'Android', source: 'user-agent', detected: true };
            if (ua.includes('windows nt')) return { platform: 'windows', label: 'Windows', source: 'user-agent', detected: true };
            return { platform: '', label: 'No detectada', source: 'unknown', detected: false };
        }

        function resolveProjectUpdateAction(project, info = null, requestedPlatform = '') {
            const forced = normalizePlatformKind(requestedPlatform);
            const details = Array.isArray(info?.platformDetails) ? info.platformDetails : [];
            const availableFromDetails = details
                .filter((d) => d.available)
                .map((d) => normalizePlatformKind(d.platform))
                .filter(Boolean);
            const availableFromTargets = getProjectInstallTargets(project)
                .filter((t) => t.available)
                .map((t) => normalizePlatformKind(t.kind))
                .filter(Boolean);
            const available = [...new Set([...availableFromDetails, ...availableFromTargets])];
            const installedPlatform = normalizePlatformKind(info?.installedPlatform || getInstalledPlatform(project?.slug || ''));
            const device = detectCurrentDevicePlatform();

            const build = (platform, reason) => ({
                platform,
                label: platform === 'android' ? 'Android' : 'Windows',
                requiresChoice: false,
                options: [],
                reason,
                device,
            });

            if (forced && available.includes(forced)) return build(forced, 'forced');
            if (installedPlatform && available.includes(installedPlatform)) return build(installedPlatform, 'installed');
            if (device.platform && available.includes(device.platform)) return build(device.platform, 'device');
            if (available.length === 1) return build(available[0], 'single');

            return {
                platform: '',
                label: '',
                requiresChoice: available.length > 1,
                options: available.map((p) => (p === 'android' ? 'Android' : 'Windows')),
                reason: 'choose',
                device,
            };
        }

        function evaluatePlatformUpdate({
            platform = '',
            installedVersion = '',
            installedVersionCode = 0,
            latestVersion = '',
            latestVersionCode = 0,
            installedReleasePublishedAt = '',
            latestReleasePublishedAt = '',
            allowMissingReleaseMetadataBootstrap = false,
            installedOnThisDevice = false,
            available = false,
        } = {}) {
            let needsUpdate = false;
            if (installedOnThisDevice && available) {
                if (platform === 'android' && Number(latestVersionCode) > 0) {
                    if (Number(installedVersionCode) > 0) {
                        needsUpdate = Number(latestVersionCode) > Number(installedVersionCode);
                    } else if (installedVersion && latestVersion) {
                        const installedFamily = detectVersionFamily(installedVersion);
                        const latestFamily = detectVersionFamily(latestVersion);
                        if (installedFamily && latestFamily && installedFamily !== latestFamily) {
                            // One-time correction for legacy Android markers stored with date-style versions.
                            needsUpdate = true;
                        } else {
                            needsUpdate = compareVersionLike(installedVersion, latestVersion) < 0;
                        }
                    }
                } else if (installedVersion && latestVersion) {
                    needsUpdate = compareVersionLike(installedVersion, latestVersion) < 0;
                }

                if (!needsUpdate && installedVersion && latestVersion) {
                    const sameVersion = compareVersionLike(installedVersion, latestVersion) === 0;
                    if (sameVersion) {
                        const latestReleaseTs = Date.parse(String(latestReleasePublishedAt || '')) || 0;
                        const installedReleaseTs = Date.parse(String(installedReleasePublishedAt || '')) || 0;
                        if (latestReleaseTs > 0) {
                            if (installedReleaseTs > 0) {
                                needsUpdate = latestReleaseTs > installedReleaseTs;
                            } else if (allowMissingReleaseMetadataBootstrap) {
                                // One-time bootstrap for users installed before release metadata tracking.
                                needsUpdate = true;
                            }
                        }
                    }
                }
            }
            return needsUpdate;
        }

        function getPendingProjectUpdates() {
            return allProjects
                .map((p) => ({ project: p, info: getProjectUpdateInfo(p) }))
                .filter((x) => x.info.needsUpdate)
                .sort((a, b) => String(a.project?.name || '').localeCompare(String(b.project?.name || '')));
        }

        function isSSAProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('savagespaceanimals') || slug.includes('savage-space-animals') || name.includes('savage space animals');
        }

        function isOceanPayProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('ocean-pay') || slug.includes('oceanpay') || name.includes('ocean pay');
        }

        function isFloretProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('floret') || name.includes('floret shop');
        }

        function isWildTransferProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('wildtransfer') || slug.includes('wild-transfer') || name.includes('wildtransfer') || name.includes('wild transfer');
        }

        function isOWSNewsProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('ows-news') || slug.includes('owsnews') || name.includes('ows news');
        }

        function isWildDestinyProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('wild-destiny') || slug.includes('wilddestiny') || name.includes('wild destiny');
        }

        function isVelocitySurgeProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('velocity-surge') || slug.includes('velocitysurge') || name.includes('velocity surge');
        }

        function isReleaseTrackedProject(project) {
            return isWildWeaponProject(project)
                || isSSAProject(project)
                || isOceanPayProject(project)
                || isFloretProject(project)
                || isWildTransferProject(project)
                || isVelocitySurgeProject(project);
        }

        function getProjectShort(project) {
            if (isSSAProject(project)) return 'SSA';
            if (isFloretProject(project)) return 'FLR';
            if (isWildTransferProject(project)) return 'WTR';
            if (isWildDestinyProject(project)) return 'WD';
            if (isVelocitySurgeProject(project)) return 'VSG';
            return '';
        }

        function ensureSSAProject(projects) {
            if (!Array.isArray(projects)) return [];
            const list = [...projects];
            const idx = list.findIndex(isSSAProject);
            if (idx === -1) {
                list.unshift({ ...SSA_PROJECT });
            } else {
                list[idx] = { ...SSA_PROJECT, ...list[idx], short: 'SSA', status: 'launched' };
            }
            return list;
        }

        function ensureFloretProject(projects) {
            if (!Array.isArray(projects)) return [];
            const list = [...projects];
            const idx = list.findIndex(isFloretProject);
            if (idx === -1) {
                list.unshift({ ...FLORET_PROJECT });
            } else {
                list[idx] = { ...FLORET_PROJECT, ...list[idx], short: 'FLR', status: 'launched' };
            }
            return list;
        }

        function ensureWildTransferProject(projects) {
            if (!Array.isArray(projects)) return [];
            const list = [...projects];
            const idx = list.findIndex(isWildTransferProject);
            if (idx === -1) {
                list.unshift({ ...WILDTRANSFER_PROJECT });
            } else {
                list[idx] = { ...WILDTRANSFER_PROJECT, ...list[idx], short: 'WTR', status: 'launched' };
            }
            return list;
        }

        function ensureWildDestinyProject(projects) {
            if (!Array.isArray(projects)) return [];
            const list = [...projects];
            const idx = list.findIndex(isWildDestinyProject);
            if (idx === -1) {
                list.unshift({ ...WILDDESTINY_PROJECT });
            } else {
                list[idx] = {
                    ...WILDDESTINY_PROJECT,
                    ...list[idx],
                    short: 'WD',
                    status: list[idx].status || 'coming_soon',
                    pending_release: true,
                    icon_url: WILDDESTINY_LOCAL_ICON
                };
            }
            return list;
        }

        function ensureVelocitySurgeProject(projects) {
            if (!Array.isArray(projects)) return [];
            const list = [...projects];
            const idx = list.findIndex(isVelocitySurgeProject);
            if (idx === -1) {
                list.unshift({ ...VELOCITY_SURGE_PROJECT });
            } else {
                list[idx] = {
                    ...VELOCITY_SURGE_PROJECT,
                    ...list[idx],
                    short: 'VSG',
                    status: list[idx].status || 'launched',
                    icon_url: VELOCITY_SURGE_LOCAL_ICON
                };
            }
            return list;
        }

        function hasNewBadge(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const startIso = NEW_BADGE_START_BY_SLUG[slug];
            if (!startIso) return false;
            const startMs = Date.parse(startIso);
            if (!Number.isFinite(startMs)) return false;
            return (Date.now() - startMs) <= NEW_BADGE_DURATION_MS;
        }

        function syncUpdatesBadge() {
            const badge = document.getElementById('update-badge');
            if (!badge) return;
            const hasAny = appUpdateAvailable || projectUpdatesCount > 0;
            badge.style.display = hasAny ? 'inline-flex' : 'none';
            if (projectUpdatesCount > 0 && appUpdateAvailable) {
                badge.textContent = `${projectUpdatesCount}+`;
            } else if (projectUpdatesCount > 0) {
                badge.textContent = String(projectUpdatesCount);
            } else {
                badge.textContent = '!';
            }
        }

        function isStoreObsoleteGateActive() {
            return Boolean(storeObsoleteGate?.blocked);
        }

        function getStoreObsoleteGateMessage(actionText = 'instalar o actualizar proyectos') {
            const platformLabel = storeObsoleteGate.platform === 'android' ? 'Android' : 'Windows';
            const currentText = storeObsoleteGate.currentVersion ? `v${storeObsoleteGate.currentVersion}` : 'version instalada';
            const requiredText = storeObsoleteGate.requiredVersion ? `v${storeObsoleteGate.requiredVersion}` : 'la ultima version';
            return `OWS Store ${platformLabel} esta obsoleta (${currentText}). Debes actualizar a ${requiredText} antes de ${actionText}.`;
        }

        function setStoreObsoleteGateBlocked({
            platform = '',
            currentVersion = '',
            requiredVersion = '',
            reason = '',
            source = '',
        } = {}) {
            storeObsoleteGate = {
                blocked: true,
                platform: normalizePlatformKind(platform) || (isNativeAndroidRuntime() ? 'android' : 'windows'),
                currentVersion: String(currentVersion || '').trim(),
                requiredVersion: String(requiredVersion || '').trim(),
                reason: String(reason || '').trim(),
                source: String(source || '').trim(),
                checkedAt: Date.now(),
            };
        }

        function clearStoreObsoleteGate({ platform = '', reason = '', source = '' } = {}) {
            const keepPlatform = normalizePlatformKind(platform) || storeObsoleteGate.platform || (isNativeAndroidRuntime() ? 'android' : 'windows');
            storeObsoleteGate = {
                blocked: false,
                platform: keepPlatform,
                currentVersion: storeObsoleteGate.currentVersion || '',
                requiredVersion: '',
                reason: String(reason || '').trim(),
                source: String(source || '').trim(),
                checkedAt: Date.now(),
            };
        }

        async function refreshStoreObsoleteGateIfNeeded({ force = false } = {}) {
            if (!force && storeObsoleteGateRefreshPromise) return storeObsoleteGate;
            const now = Date.now();
            if (!force && storeObsoleteGate.checkedAt > 0 && (now - storeObsoleteGate.checkedAt) < STORE_OBSOLETE_GATE_REFRESH_MS) {
                return storeObsoleteGate;
            }

            const run = async () => {
                try {
                    if (isNativeAndroidRuntime() && typeof window.owsUpdater === 'undefined') {
                        await checkOWSStoreAndroidUpdate({ silent: true, origin: 'guard' });
                    } else if (window.owsUpdater?.checkForUpdates) {
                        await requestWindowsUpdaterCheck({ silent: true, origin: 'guard' });
                        const currentVersion = String(await window.owsUpdater.getAppVersion?.().catch(() => currentStoreWindowsVersion || '') || currentStoreWindowsVersion || '').trim();
                        if (currentVersion) currentStoreWindowsVersion = currentVersion;
                        await applyWindowsManualUpdateSignal(currentStoreWindowsVersion, { silent: true }).catch(() => {});
                    } else {
                        clearStoreObsoleteGate({ source: 'guard-no-updater', reason: 'updater-unavailable' });
                    }
                } catch (_) {}
                if (!storeObsoleteGate.checkedAt) {
                    storeObsoleteGate.checkedAt = Date.now();
                }
            };

            storeObsoleteGateRefreshPromise = run().finally(() => {
                storeObsoleteGateRefreshPromise = null;
            });
            await storeObsoleteGateRefreshPromise;
            return storeObsoleteGate;
        }

        function showStoreObsoleteBlockMessage(actionText = 'instalar o actualizar proyectos', { openUpdates = true } = {}) {
            const message = getStoreObsoleteGateMessage(actionText);
            const now = Date.now();
            if ((now - storeObsoleteGateLastNoticeAt) >= STORE_OBSOLETE_BLOCK_NOTICE_COOLDOWN_MS) {
                addNotification(message, 'warning');
                storeObsoleteGateLastNoticeAt = now;
            }
            const status = document.getElementById('updates-project-status');
            if (status) status.textContent = 'Bloqueado: actualiza OWS Store para continuar';
            showActionMessage(message, {
                state: 'available',
                title: 'OWS Store obsoleta',
                iconClass: 'fa-shield-halved',
                iconSpin: false,
            });
            if (openUpdates && activeSection !== 'updates') {
                const updatesNav = document.querySelector('.nav-menu .nav-item:nth-child(3)');
                showSection('updates', updatesNav || null);
            }
            return message;
        }

        async function ensureStoreIsUpToDateForProjectAction(actionText = 'instalar o actualizar proyectos', { openUpdates = true, forceCheck = false } = {}) {
            await refreshStoreObsoleteGateIfNeeded({ force: forceCheck });
            if (!isStoreObsoleteGateActive()) return false;
            showStoreObsoleteBlockMessage(actionText, { openUpdates });
            return true;
        }

        function triggerStoreObsoleteNotice(slug = '') {
            const project = getProjectBySlug(slug);
            const actionText = project
                ? `instalar o actualizar ${project.name}`
                : 'instalar o actualizar proyectos';
            showStoreObsoleteBlockMessage(actionText, { openUpdates: true });
        }

        function getProjectUpdateInfo(project) {
            const state = installStateBySlug[project.slug] || {};
            const installedVersion = String(state.version || getInstalledVersion(project.slug) || '').trim();
            const installedVersionCode = Number(state.versionCode || getInstalledVersionCode(project.slug) || 0);
            const installed = Boolean(state.installed || installedVersion);
            const installedPlatform = installed ? getPreferredInstalledPlatform(project, state) : '';
            const windowsInstalledReleasePublishedAt = getInstalledReleasePublishedAt(project.slug, 'windows');
            const androidInstalledReleasePublishedAt = getInstalledReleasePublishedAt(project.slug, 'android');

            const windowsLatestVersion = String(project.windows_version || project.version || '').trim();
            const androidLatestVersion = String(project.android_version || project.version || '').trim();
            const androidLatestVersionCode = Number(project.android_version_code || project.version_code || 0);
            const windowsLatestReleasePublishedAt = String(project.windows_last_update_at || project.last_update_at || '').trim();
            const androidLatestReleasePublishedAt = String(project.android_last_update_at || project.last_update_at || '').trim();

            const platformDetails = [];
            if (supportsWindowsInstaller(project)) {
                const available = Boolean(getProjectInstallTargets(project).some((t) => t.kind === 'windows' && t.available));
                const installedOnThisDevice = installed && installedPlatform === 'windows';
                const needsUpdate = evaluatePlatformUpdate({
                    platform: 'windows',
                    installedVersion,
                    latestVersion: windowsLatestVersion,
                    installedReleasePublishedAt: windowsInstalledReleasePublishedAt,
                    latestReleasePublishedAt: windowsLatestReleasePublishedAt,
                    allowMissingReleaseMetadataBootstrap: true,
                    installedOnThisDevice,
                    available,
                });
                platformDetails.push({
                    platform: 'windows',
                    label: 'Windows',
                    available,
                    installedOnThisDevice,
                    installedVersion: installedOnThisDevice ? installedVersion : '',
                    installedVersionCode: 0,
                    latestVersion: windowsLatestVersion,
                    latestVersionCode: 0,
                    installedReleasePublishedAt: installedOnThisDevice ? windowsInstalledReleasePublishedAt : '',
                    latestReleasePublishedAt: windowsLatestReleasePublishedAt,
                    needsUpdate,
                });
            }

            if (supportsAndroidDownloads(project)) {
                const available = Boolean(getProjectInstallTargets(project).some((t) => t.kind === 'android' && t.available));
                const installedOnThisDevice = installed && installedPlatform === 'android';
                const needsUpdate = evaluatePlatformUpdate({
                    platform: 'android',
                    installedVersion,
                    installedVersionCode,
                    latestVersion: androidLatestVersion,
                    latestVersionCode: androidLatestVersionCode,
                    installedReleasePublishedAt: androidInstalledReleasePublishedAt,
                    latestReleasePublishedAt: androidLatestReleasePublishedAt,
                    installedOnThisDevice,
                    available,
                });
                platformDetails.push({
                    platform: 'android',
                    label: 'Android',
                    available,
                    installedOnThisDevice,
                    installedVersion: installedOnThisDevice ? installedVersion : '',
                    installedVersionCode: installedOnThisDevice ? installedVersionCode : 0,
                    latestVersion: androidLatestVersion,
                    latestVersionCode: androidLatestVersionCode,
                    installedReleasePublishedAt: installedOnThisDevice ? androidInstalledReleasePublishedAt : '',
                    latestReleasePublishedAt: androidLatestReleasePublishedAt,
                    needsUpdate,
                });
            }

            const targetDetail = platformDetails.find((d) => d.installedOnThisDevice) || platformDetails[0] || null;
            const needsUpdate = platformDetails.some((d) => d.installedOnThisDevice && d.needsUpdate);
            const updatePlatforms = platformDetails.filter((d) => d.needsUpdate && d.installedOnThisDevice);

            return {
                installed,
                installedPlatform,
                needsUpdate,
                installedVersion,
                installedVersionCode,
                latestVersion: targetDetail?.latestVersion || '',
                latestVersionCode: Number(targetDetail?.latestVersionCode || 0),
                platformDetails,
                updatePlatforms,
            };
        }

        function getVisibleProjects() {
            const q = currentSearchTerm.trim().toLowerCase();
            return allProjects.filter((p) => {
                const searchOk = !q || String(p.name || '').toLowerCase().includes(q) || String(p.description || '').toLowerCase().includes(q);
                if (!searchOk) return false;
                if (currentProjectFilter === 'installed') return Boolean(installStateBySlug[p.slug]?.installed);
                if (currentProjectFilter === 'external') return isExternalInstallerProject(p);
                if (currentProjectFilter === 'updates') return getProjectUpdateInfo(p).needsUpdate;
                return true;
            });
        }

        function renderVisibleProjects() {
            renderProjects(getVisibleProjects());
            renderExploreInsights();
            renderNewsHub();
        }

        function renderProjectUpdatesList() {
            const list = document.getElementById('project-updates-list');
            if (!list) return;
            const updates = getPendingProjectUpdates();
            const gateBlocked = isStoreObsoleteGateActive();
            const gateNoticeHtml = gateBlocked
                ? `<div class="info-note-card" style="border-color:#b96700; background:rgba(185,103,0,0.08);">\
                    <strong style="display:block; margin-bottom:0.25rem; color:#b96700;">OWS Store obsoleta</strong>\
                    <span>${getStoreObsoleteGateMessage('instalar o actualizar proyectos')}</span>\
                </div>`
                : '';
            projectUpdatesCount = updates.length;
            syncUpdatesBadge();

            if (!updates.length) {
                const appHint = appUpdateAvailable
                    ? `<div style="margin-top:0.5rem; color:var(--brand-2);">Hay una actualizacion de OWS Store disponible en el banner superior.</div>`
                    : '';
                list.innerHTML = `${gateNoticeHtml}<div class="info-note-card">No hay actualizaciones pendientes de proyectos.${appHint}</div>`;
                return;
            }

            const formatPlatformRow = (detail) => {
                const rowClasses = [
                    'project-update-platform-row',
                    detail.installedOnThisDevice ? 'is-target' : '',
                    detail.needsUpdate ? 'is-updating' : '',
                    !detail.available ? 'is-unavailable' : '',
                ].filter(Boolean).join(' ');

                let statusText = 'Sin release publicada';
                if (detail.available) {
                    if (detail.installedOnThisDevice) {
                        if (detail.platform === 'android' && detail.installedVersionCode > 0 && detail.latestVersionCode > 0) {
                            statusText = detail.needsUpdate
                                ? `Code ${detail.installedVersionCode} -> ${detail.latestVersionCode}`
                                : `Code ${detail.latestVersionCode} (al dia)`;
                        } else {
                            const releaseRefreshOnly = detail.needsUpdate
                                && detail.installedVersion
                                && detail.latestVersion
                                && compareVersionLike(detail.installedVersion, detail.latestVersion) === 0;
                            statusText = detail.needsUpdate
                                ? (releaseRefreshOnly
                                    ? `v${detail.latestVersion || '-'} (release renovada)`
                                    : `v${detail.installedVersion || '-'} -> v${detail.latestVersion || '-'}`)
                                : `v${detail.latestVersion || '-'} (al dia)`;
                        }
                    } else {
                        statusText = detail.latestVersion
                            ? `No instalada en este dispositivo (ultima: v${detail.latestVersion})`
                            : 'No instalada en este dispositivo';
                    }
                }

                return `
                    <div class="${rowClasses}">
                        <div class="project-update-platform-label">
                            <span class="dot"></span>
                            <span>${detail.label}${detail.installedOnThisDevice ? ' (instalada)' : ''}</span>
                        </div>
                        <div class="project-update-platform-status">${statusText}</div>
                    </div>
                `;
            };

            list.innerHTML = updates.map(({ project, info }) => {
                const action = resolveProjectUpdateAction(project, info);
                const targetLabel = action.label || getPrimaryUpdatePlatformLabel(info);
                const metaText = gateBlocked
                    ? getStoreObsoleteGateMessage(`actualizar ${project.name}`)
                    : (action.requiresChoice
                        ? `No se pudo detectar plataforma automaticamente. Elige ${action.options.join(' o ')} antes de actualizar.`
                        : (action.reason === 'device'
                            ? `Actualizacion recomendada para ${targetLabel} (dispositivo detectado: ${action.device.label}).`
                            : `Actualizacion detectada para ${targetLabel}.`));
                const buttonLabel = gateBlocked
                    ? 'Actualizar OWS Store'
                    : (action.requiresChoice ? 'Elegir plataforma' : `Actualizar ${targetLabel}`);
                const buttonIcon = gateBlocked
                    ? 'fa-shield-halved'
                    : (action.requiresChoice ? 'fa-layer-group' : 'fa-arrow-up');
                const buttonClass = gateBlocked ? 'btn-install unavailable' : 'btn-install';
                const buttonAction = gateBlocked
                    ? `triggerStoreObsoleteNotice('${project.slug}')`
                    : `triggerProjectUpdate('${project.slug}', '${action.platform || ''}')`;

                return `
                    <div class="project-update-card">
                        <div>
                            <div class="project-update-title">${project.name}</div>
                            <div class="project-update-meta">${metaText}</div>
                            <div class="project-update-platforms">${info.platformDetails.map((d) => formatPlatformRow(d)).join('')}</div>
                        </div>
                        <button class="${buttonClass}" style="width:auto; padding:0.55rem 0.8rem;" onclick="${buttonAction}"><i class="fas ${buttonIcon}"></i> ${buttonLabel}</button>
                    </div>
                `;
            }).join('');

            list.innerHTML = `${gateNoticeHtml}${list.innerHTML}`;
        }

        function renderStoreNewsTimeline() {
            const container = document.getElementById('store-news-timeline');
            if (!container) return;
            const entries = [];
            const pickSummary = (rawText, fallback = 'Sin notas detalladas.') => {
                const line = String(rawText || '')
                    .split(/\r?\n/)
                    .map((l) => l.replace(/^[#*\-\s>]+/, '').trim())
                    .find(Boolean);
                return line || fallback;
            };

            const storeWindows = owsStoreWindowsReleaseCache || null;
            if (storeWindows?.version) {
                entries.push({
                    type: 'changelog',
                    tone: 'info',
                    title: `OWS Store Windows v${storeWindows.version}`,
                    date: storeWindows.publishedAt || null,
                    text: pickSummary(storeWindows.releaseNotes, 'Release de Windows publicada en GitHub Releases.'),
                    platforms: ['windows'],
                });
            }

            if (owsStoreAndroidState.version || owsStoreAndroidState.versionCode > 0) {
                entries.push({
                    type: 'changelog',
                    tone: 'success',
                    title: `OWS Store Android ${owsStoreAndroidState.version ? `v${owsStoreAndroidState.version}` : `(code ${owsStoreAndroidState.versionCode})`}`,
                    date: owsStoreAndroidState.publishedAt || null,
                    text: pickSummary(owsStoreAndroidState.releaseNotes, 'Build Android sincronizada con metadata oficial.'),
                    platforms: ['android'],
                });
            }

            entries.push({
                type: 'changelog',
                tone: 'warning',
                title: 'OWS News retirado como app independiente',
                date: '2026-02-26T00:00:00Z',
                text: 'OWS News fue integrado en OWS Store. Desde ahora, noticias y eventos se consultan dentro de OWS Store.',
                platforms: ['windows', 'android'],
            });

            const storeNews = (owsNewsUpdatesCache || []).filter((entry) => {
                const keys = Array.isArray(entry.projectNames) ? entry.projectNames : [];
                if (keys.some((k) => k.includes('ows-store') || k.includes('ows store'))) return true;
                const blob = `${entry.title} ${entry.description} ${(entry.changes || []).join(' ')}`.toLowerCase();
                return blob.includes('ows store');
            });
            storeNews.slice(0, 6).forEach((entry) => {
                entries.push({
                    type: entry.isEvent ? 'evento' : 'changelog',
                    tone: entry.isEvent ? 'warning' : 'neutral',
                    title: entry.title,
                    date: entry.updateDate || null,
                    text: entry.description || entry.changes[0] || 'Sin descripcion.',
                    platforms: entry.platforms || ['all'],
                });
            });

            const launchEvents = [...allProjects]
                .filter((project) => !project.pending_release && project.last_update_at && !isOWSNewsProject(project))
                .sort((a, b) => (Date.parse(b.last_update_at || '') || 0) - (Date.parse(a.last_update_at || '') || 0))
                .slice(0, 6);
            launchEvents.forEach((project) => {
                entries.push({
                    type: 'lanzamiento',
                    tone: 'success',
                    title: `${project.name} disponible en OWS Store`,
                    date: project.last_update_at || null,
                    text: `Version ${getProjectDisplayVersion(project)} | ${getProjectPlatformLabel(project)}`,
                    platforms: (function () {
                        const tokens = getPlatformTokens(project);
                        const kinds = [];
                        if (tokens.has('windows') || supportsWindowsInstaller(project)) kinds.push('windows');
                        if (tokens.has('android') || supportsAndroidDownloads(project)) kinds.push('android');
                        return kinds.length ? kinds : ['all'];
                    })(),
                });
            });

            const sorted = entries
                .filter((e) => e.title)
                .sort((a, b) => (Date.parse(b.date || '') || 0) - (Date.parse(a.date || '') || 0))
                .slice(0, 12);

            if (!sorted.length) {
                container.innerHTML = '<div class="info-note-card">Sin changelogs o eventos de Store por ahora.</div>';
                return;
            }

            const toneColors = {
                success: '#1f9d63',
                warning: '#b96700',
                info: '#007f84',
                neutral: '#5a6470',
            };
            container.innerHTML = sorted.map((item) => {
                const tone = toneColors[item.tone] || toneColors.neutral;
                return `
                    <div class="notification-card" style="--tone-color:${tone};">
                        <div class="notification-time">${formatDateTime(item.date)} · ${String(item.type || 'dato').toUpperCase()} · ${getPlatformLabelFromKinds(item.platforms || ['all'])}</div>
                        <div class="notification-text">${item.title}</div>
                        <div class="notification-time" style="margin-top:0.2rem;">${item.text}</div>
                    </div>
                `;
            }).join('');
        }

        async function triggerProjectUpdate(slug, platform = '') {
            const project = allProjects.find((p) => p.slug === slug);
            if (!project) return;
            if (await ensureStoreIsUpToDateForProjectAction(`actualizar ${project.name}`, { openUpdates: false, forceCheck: true })) {
                return;
            }
            const info = getProjectUpdateInfo(project);
            const resolved = resolveProjectUpdateAction(project, info, platform);
            if (!resolved.platform) {
                const opts = resolved.options?.length ? resolved.options.join(' / ') : 'Windows / Android';
                openDetails(slug);
                addNotification(`Selecciona plataforma para actualizar ${project.name}: ${opts}.`, 'warning');
                showActionMessage(`No se pudo detectar plataforma automaticamente. Selecciona ${opts} para ${project.name}.`, { state: 'info' });
                return;
            }
            const normalizedPlatform = normalizePlatformKind(resolved.platform) || 'windows';
            selectedInstallTargetBySlug[slug] = normalizedPlatform === 'android' ? 'android-apk' : 'windows';
            await reinstallFromLibrary(slug);
        }

        async function checkProjectUpdatesAndNotify() {
            await applyLatestInstallerData(allProjects);
            await refreshInstallationStates();
            renderProjectUpdatesList();
            const updates = getPendingProjectUpdates();

            updates.forEach(({ project, info }) => {
                const platformLabel = getPrimaryUpdatePlatformLabel(info);
                const platformKey = getResolvedUpdatePlatforms(info).join('+') || platformLabel.toLowerCase();
                const key = `${project.slug}:${platformKey}:${info.installedVersion}->${info.latestVersion}`;
                if (projectUpdateNotified.has(key)) return;
                projectUpdateNotified.add(key);
                addNotification(`Actualizacion disponible para ${project.name} [${platformLabel}]: v${info.latestVersion}.`, 'warning');
            });
        }

        function renderIfVisible(target) {
            if (target === 'projects' && activeSection === 'home') renderVisibleProjects();
            if (target === 'library' && activeSection === 'library') renderLibrary();
            if (target === 'updates' && activeSection === 'updates') {
                renderProjectUpdatesList();
                renderStoreNewsTimeline();
            }
        }

        function scheduleSectionRender({ projects = false, library = false, immediate = false } = {}) {
            const run = () => {
                if (projects) renderIfVisible('projects');
                if (library) renderIfVisible('library');
                renderProjectUpdatesList();
                renderStoreNewsTimeline();
                renderDownloadSurfaces();
            };
            if (immediate) {
                if (scheduledRenderTimer) {
                    clearTimeout(scheduledRenderTimer);
                    scheduledRenderTimer = null;
                }
                run();
                return;
            }
            if (scheduledRenderTimer) return;
            scheduledRenderTimer = setTimeout(() => {
                scheduledRenderTimer = null;
                run();
            }, 220);
        }

        function setProjectFilter(filter) {
            currentProjectFilter = filter || 'all';
            const ids = ['all', 'installed', 'external', 'updates'];
            ids.forEach((id) => {
                const el = document.getElementById(`filter-chip-${id}`);
                if (el) el.classList.toggle('active', currentProjectFilter === id);
            });
            renderVisibleProjects();
            renderExploreInsights();
        }

        async function syncLibraryNow() {
            addNotification('Sincronizando biblioteca...', 'neutral');
            await refreshInstallationStates();
            scheduleSectionRender({ projects: true, library: true, immediate: true });
            addNotification('Biblioteca sincronizada.', 'success');
            renderExploreInsights();
        }

        async function loadProjects() {
            try {
                const res = await fetch(`${API_URL}/ows-store/projects`);
                allProjects = await res.json();
            } catch (err) {
                console.error("Error cargando proyectos:", err);
                allProjects = [
                    { ...SSA_PROJECT },
                    { ...WILDTRANSFER_PROJECT },
                    { ...FLORET_PROJECT },
                    { ...VELOCITY_SURGE_PROJECT },
                    { slug: 'wildweapon', name: 'WildWeapon Mayhem', status: 'launched', version: '22.2.26-1900', platform: 'windows', install_type: 'external', installer_url: WILDWEAPON_RELEASES_URL, description: 'Combate tactico definitivo, ahora disponible en ejecutable para Windows.' },
                    { slug: 'ocean-pay', name: 'Ocean Pay', status: 'launched', version: '3.1.0', platform: 'windows', install_type: 'external', installer_url: OCEAN_PAY_RELEASES_URL, icon_url: OCEAN_PAY_LOCAL_ICON, description: 'Pasarela universal.' }
                ];
            }
            allProjects = Array.isArray(allProjects) ? allProjects.filter((p) => !isOWSNewsProject(p)) : [];
            allProjects = ensureVelocitySurgeProject(ensureWildDestinyProject(ensureWildTransferProject(ensureFloretProject(ensureSSAProject(allProjects)))));
            await applyLatestInstallerData(allProjects);
            seedLibraryFromProjectCatalog();
            try {
                await fetchOWSNewsUpdates(true);
            } catch (err) {
                console.log('No se pudieron cargar noticias OWS:', err?.message || err);
                owsNewsUpdatesCache = [];
            }
            await refreshInstallationStates();
            renderVisibleProjects();
            renderLibrary();
            renderProjectUpdatesList();
            renderStoreNewsTimeline();
            requestRenderDownloadSurfaces({ immediate: true });
            await checkProjectUpdatesAndNotify();
        }

        async function fetchLatestWildWeaponRelease() {
            const now = Date.now();
            if (wildWeaponReleaseCache && (now - wildWeaponReleaseCache.checkedAt) < 120000) {
                return wildWeaponReleaseCache;
            }

            const res = await fetch(WILDWEAPON_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
            const scoredCandidates = exeCandidates.map((a) => ({
                asset: a,
                version: extractVersionFromText(a.name),
                updatedAtMs: Date.parse(a.updated_at || '') || 0,
                hasWildWeaponName: /wildweapon/i.test(String(a.name || '')),
            }));

            // Prefer explicit wildweapon installers, then matching-tag version, then highest parsed version.
            scoredCandidates.sort((x, y) => {
                if (x.hasWildWeaponName !== y.hasWildWeaponName) return x.hasWildWeaponName ? -1 : 1;
                const cmp = compareVersionLike(y.version, x.version);
                if (cmp !== 0) return cmp;
                return y.updatedAtMs - x.updatedAtMs;
            });
            let selected = scoredCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = scoredCandidates.find(c => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const exeAsset = selected?.asset || null;
            const versionFromAsset = selected?.version || '';
            const staleInstaller = Boolean(versionFromTag && versionFromAsset && compareVersionLike(versionFromAsset, versionFromTag) < 0);
            const warning = staleInstaller
                ? `Release latest apunta a tag ${versionFromTag}, pero el instalador publicado es ${versionFromAsset}.`
                : '';
            const payload = {
                version: versionFromTag || versionFromAsset || null,
                tagVersion: versionFromTag || null,
                assetVersion: versionFromAsset || null,
                installerUrl: exeAsset?.browser_download_url || '',
                installerSize: Number(exeAsset?.size || 0),
                installerAvailable: Boolean(exeAsset?.browser_download_url) && !staleInstaller,
                publishedAt: data.published_at || data.created_at || null,
                warning,
                checkedAt: now,
            };
            wildWeaponReleaseCache = payload;
            return payload;
        }

        async function fetchLatestSSARelease() {
            const now = Date.now();
            if (ssaReleaseCache && (now - ssaReleaseCache.checkedAt) < 120000) {
                return ssaReleaseCache;
            }

            const res = await fetch(SSA_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
            const scoredCandidates = exeCandidates.map((a) => ({
                asset: a,
                version: extractVersionFromText(a.name),
                updatedAtMs: Date.parse(a.updated_at || '') || 0,
                hasSSAName: /savage|space|animals|ssa/i.test(String(a.name || '')),
            }));

            scoredCandidates.sort((x, y) => {
                if (x.hasSSAName !== y.hasSSAName) return x.hasSSAName ? -1 : 1;
                const cmp = compareVersionLike(y.version, x.version);
                if (cmp !== 0) return cmp;
                return y.updatedAtMs - x.updatedAtMs;
            });
            let selected = scoredCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = scoredCandidates.find(c => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const exeAsset = selected?.asset || null;
            const versionFromAsset = selected?.version || '';
            const staleInstaller = Boolean(versionFromTag && versionFromAsset && compareVersionLike(versionFromAsset, versionFromTag) < 0);
            const warning = staleInstaller
                ? `Release latest apunta a tag ${versionFromTag}, pero el instalador publicado es ${versionFromAsset}.`
                : '';

            const payload = {
                version: versionFromTag || versionFromAsset || null,
                tagVersion: versionFromTag || null,
                assetVersion: versionFromAsset || null,
                installerUrl: exeAsset?.browser_download_url || '',
                installerSize: Number(exeAsset?.size || 0),
                installerAvailable: Boolean(exeAsset?.browser_download_url) && !staleInstaller,
                publishedAt: data.published_at || data.created_at || null,
                warning,
                checkedAt: now,
            };
            ssaReleaseCache = payload;
            return payload;
        }

        async function fetchLatestWildTransferAndroidFromGitHub() {
            const res = await fetch(WILDTRANSFER_RELEASES_LIST_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const releases = await res.json();
            const list = Array.isArray(releases) ? releases : [];
            let best = null;

            for (const rel of list) {
                const assets = Array.isArray(rel?.assets) ? rel.assets : [];
                const apk = assets
                    .filter((a) => isInstallableAndroidApkAsset(a?.name))
                    .map((a) => ({
                        asset: a,
                        score: scoreAndroidAssetName(a?.name, 'apk'),
                    }))
                    .sort((a, b) => b.score - a.score)[0]?.asset || null;
                if (!apk) continue;

                const rawTag = String(rel?.tag_name || '').trim();
                const versionFromTag = normalizeDateVersionString(rawTag.replace(/^.*?v/i, ''));
                const versionFromAsset = normalizeDateVersionString(extractVersionFromText(apk?.name || ''));
                const version = versionFromTag || versionFromAsset || '';
                const candidate = {
                    version,
                    versionCode: deriveVersionCodeFromVersionName(version),
                    packageId: '',
                    downloadUrl: apk?.browser_download_url || '',
                    directDownloadUrl: apk?.browser_download_url || '',
                    sizeBytes: Number(apk?.size || 0),
                    sha256: '',
                    minStoreVersion: '',
                    mandatory: false,
                    notes: String(rel?.body || '').trim(),
                    publishedAt: rel?.published_at || rel?.created_at || null,
                    source: 'github-releases',
                    warning: '',
                };

                if (!best) {
                    best = candidate;
                    continue;
                }
                best = pickNewestAndroidRelease(best, candidate);
            }

            if (!best || !best.downloadUrl) {
                throw new Error('No se encontro release Android en GitHub para WildTransfer.');
            }
            return best;
        }

        async function fetchLatestWildTransferRelease() {
            const now = Date.now();
            if (wildTransferReleaseCache && (now - wildTransferReleaseCache.checkedAt) < 120000) {
                return wildTransferReleaseCache;
            }
            const [windowsResult, androidResult, androidGithubResult] = await Promise.allSettled([
                (async () => {
                    const res = await fetch(WILDTRANSFER_RELEASES_API_URL, {
                        headers: { 'Accept': 'application/vnd.github+json' }
                    });
                    if (!res.ok) throw new Error(`GitHub API ${res.status}`);
                    const data = await res.json();
                    const assets = Array.isArray(data.assets) ? data.assets : [];
                    const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
                    const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
                    const scoredCandidates = exeCandidates.map((a) => ({
                        asset: a,
                        version: extractVersionFromText(a.name),
                        updatedAtMs: Date.parse(a.updated_at || '') || 0,
                        hasWildTransferName: /wildtransfer|wild-transfer/i.test(String(a.name || '')),
                    }));

                    scoredCandidates.sort((x, y) => {
                        if (x.hasWildTransferName !== y.hasWildTransferName) return x.hasWildTransferName ? -1 : 1;
                        const cmp = compareVersionLike(y.version, x.version);
                        if (cmp !== 0) return cmp;
                        return y.updatedAtMs - x.updatedAtMs;
                    });

                    const selected = scoredCandidates[0] || null;
                    const exeAsset = selected?.asset || null;
                    const versionFromAsset = selected?.version || '';
                    return {
                        version: versionFromTag || versionFromAsset || null,
                        installerUrl: exeAsset?.browser_download_url || '',
                        installerSize: Number(exeAsset?.size || 0),
                        installerAvailable: Boolean(exeAsset?.browser_download_url),
                        releaseUrl: data.html_url || WILDTRANSFER_RELEASES_URL,
                        publishedAt: data.published_at || data.created_at || null,
                        releaseNotes: String(data.body || '').trim(),
                        warning: Boolean(exeAsset?.browser_download_url) ? '' : 'No se encontro release Windows (.exe) para WildTransfer.',
                    };
                })(),
                fetchLatestAndroidReleaseFromStoreApi('wildtransfer', WILDTRANSFER_RELEASES_URL),
                fetchLatestWildTransferAndroidFromGitHub(),
            ]);

            const windowsData = windowsResult.status === 'fulfilled'
                ? windowsResult.value
                : {
                    version: '',
                    installerUrl: '',
                    installerSize: 0,
                    installerAvailable: false,
                    releaseUrl: WILDTRANSFER_RELEASES_URL,
                    publishedAt: null,
                    releaseNotes: '',
                    warning: 'No se pudo resolver release Windows desde GitHub.',
                };

            const androidDataFromApi = androidResult.status === 'fulfilled'
                ? androidResult.value
                : {
                    version: '',
                    versionCode: 0,
                    downloadUrl: '',
                    directDownloadUrl: '',
                    sizeBytes: 0,
                    notes: '',
                    publishedAt: null,
                    warning: 'No se pudo resolver release Android desde OWS Store API.',
                };
            const androidDataFromGithub = androidGithubResult.status === 'fulfilled'
                ? androidGithubResult.value
                : null;
            const androidData = pickNewestAndroidRelease(androidDataFromApi, androidDataFromGithub) || androidDataFromApi;

            const warnings = [windowsData.warning, androidData.warning].filter(Boolean).join(' | ');
            const payload = {
                version: windowsData.version || androidData.version || null,
                windowsVersion: windowsData.version || '',
                androidVersion: androidData.version || '',
                windowsPublishedAt: windowsData.publishedAt || null,
                androidPublishedAt: androidData.publishedAt || null,
                versionCode: Number(androidData.versionCode || 0),
                installerUrl: windowsData.installerUrl || '',
                installerSize: Number(windowsData.installerSize || 0),
                installerAvailable: Boolean(windowsData.installerAvailable && windowsData.installerUrl),
                androidApkUrl: androidData.directDownloadUrl || androidData.downloadUrl || '',
                androidApkDirectUrl: androidData.directDownloadUrl || '',
                androidApkProxyUrl: androidData.downloadUrl || '',
                androidSha256: androidData.sha256 || '',
                androidApkSize: Number(androidData.sizeBytes || 0),
                androidAabUrl: '',
                androidAabSize: 0,
                androidAvailable: Boolean(androidData.directDownloadUrl || androidData.downloadUrl),
                windowsReleaseNotes: windowsData.releaseNotes || '',
                androidReleaseNotes: androidData.notes || '',
                releaseUrl: windowsData.releaseUrl || WILDTRANSFER_RELEASES_URL,
                publishedAt: pickLatestDate(windowsData.publishedAt, androidData.publishedAt),
                warning: warnings,
                checkedAt: now,
            };
            wildTransferReleaseCache = payload;
            return payload;
        }

        async function fetchLatestVelocitySurgeRelease() {
            const now = Date.now();
            if (velocitySurgeReleaseCache && (now - velocitySurgeReleaseCache.checkedAt) < 120000) {
                return velocitySurgeReleaseCache;
            }

            const res = await fetch(VELOCITY_SURGE_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
            const scoredCandidates = exeCandidates.map((a) => ({
                asset: a,
                version: extractVersionFromText(a.name),
                updatedAtMs: Date.parse(a.updated_at || '') || 0,
                hasVelocityName: /velocity|surge|velocity[-_\s]*surge/i.test(String(a.name || '')),
            }));

            scoredCandidates.sort((x, y) => {
                if (x.hasVelocityName !== y.hasVelocityName) return x.hasVelocityName ? -1 : 1;
                const cmp = compareVersionLike(y.version, x.version);
                if (cmp !== 0) return cmp;
                return y.updatedAtMs - x.updatedAtMs;
            });

            let selected = scoredCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = scoredCandidates.find(c => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const exeAsset = selected?.asset || null;
            const versionFromAsset = selected?.version || '';
            const staleInstaller = Boolean(versionFromTag && versionFromAsset && compareVersionLike(versionFromAsset, versionFromTag) < 0);
            const warning = staleInstaller
                ? `Release latest apunta a tag ${versionFromTag}, pero el instalador publicado es ${versionFromAsset}.`
                : '';

            const payload = {
                version: versionFromTag || versionFromAsset || null,
                tagVersion: versionFromTag || null,
                assetVersion: versionFromAsset || null,
                installerUrl: exeAsset?.browser_download_url || '',
                installerSize: Number(exeAsset?.size || 0),
                installerAvailable: Boolean(exeAsset?.browser_download_url) && !staleInstaller,
                publishedAt: data.published_at || data.created_at || null,
                warning,
                checkedAt: now,
            };
            velocitySurgeReleaseCache = payload;
            return payload;
        }

        async function fetchLatestOceanPayRelease() {
            const now = Date.now();
            if (oceanPayProjectReleaseCache && (now - oceanPayProjectReleaseCache.checkedAt) < 120000) {
                return oceanPayProjectReleaseCache;
            }

            const res = await fetch(OCEAN_PAY_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
            const scoredCandidates = exeCandidates.map((a) => ({
                asset: a,
                version: extractVersionFromText(a.name),
                updatedAtMs: Date.parse(a.updated_at || '') || 0,
                hasOceanPayName: /ocean\s*pay|oceanpay/i.test(String(a.name || '')),
            }));

            scoredCandidates.sort((x, y) => {
                if (x.hasOceanPayName !== y.hasOceanPayName) return x.hasOceanPayName ? -1 : 1;
                const cmp = compareVersionLike(y.version, x.version);
                if (cmp !== 0) return cmp;
                return y.updatedAtMs - x.updatedAtMs;
            });
            let selected = scoredCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = scoredCandidates.find(c => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const exeAsset = selected?.asset || null;
            const versionFromAsset = selected?.version || '';
            const staleInstaller = Boolean(versionFromTag && versionFromAsset && compareVersionLike(versionFromAsset, versionFromTag) < 0);
            const warning = staleInstaller
                ? `Release latest apunta a tag ${versionFromTag}, pero el instalador publicado es ${versionFromAsset}.`
                : '';

            const payload = {
                version: versionFromTag || versionFromAsset || null,
                tagVersion: versionFromTag || null,
                assetVersion: versionFromAsset || null,
                installerUrl: exeAsset?.browser_download_url || '',
                installerSize: Number(exeAsset?.size || 0),
                installerAvailable: Boolean(exeAsset?.browser_download_url) && !staleInstaller,
                publishedAt: data.published_at || data.created_at || null,
                warning,
                checkedAt: now,
            };
            oceanPayProjectReleaseCache = payload;
            return payload;
        }

        async function fetchLatestOWSNewsRelease() {
            const now = Date.now();
            if (owsNewsReleaseCache && (now - owsNewsReleaseCache.checkedAt) < 120000) {
                return owsNewsReleaseCache;
            }

            const res = await fetch(OWSNEWS_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
            const scoredCandidates = exeCandidates.map((a) => ({
                asset: a,
                version: extractVersionFromText(a.name),
                updatedAtMs: Date.parse(a.updated_at || '') || 0,
                hasOWSNewsName: /ows[-_.\s]*news|ocean[-_.\s]*and[-_.\s]*wild[-_.\s]*studios[-_.\s]*news/i.test(String(a.name || '')),
            }));

            scoredCandidates.sort((x, y) => {
                if (x.hasOWSNewsName !== y.hasOWSNewsName) return x.hasOWSNewsName ? -1 : 1;
                const cmp = compareVersionLike(y.version, x.version);
                if (cmp !== 0) return cmp;
                return y.updatedAtMs - x.updatedAtMs;
            });

            let selected = scoredCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = scoredCandidates.find(c => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const exeAsset = selected?.asset || null;
            const versionFromAsset = selected?.version || '';
            const staleInstaller = Boolean(versionFromTag && versionFromAsset && compareVersionLike(versionFromAsset, versionFromTag) < 0);
            const warning = staleInstaller
                ? `Release latest apunta a tag ${versionFromTag}, pero el instalador publicado es ${versionFromAsset}.`
                : '';

            const payload = {
                version: versionFromTag || versionFromAsset || null,
                tagVersion: versionFromTag || null,
                assetVersion: versionFromAsset || null,
                installerUrl: exeAsset?.browser_download_url || '',
                installerSize: Number(exeAsset?.size || 0),
                installerAvailable: Boolean(exeAsset?.browser_download_url) && !staleInstaller,
                publishedAt: data.published_at || data.created_at || null,
                warning,
                checkedAt: now,
            };
            owsNewsReleaseCache = payload;
            return payload;
        }

        async function fetchLatestAndroidReleaseFromStoreApi(slug, fallbackReleaseUrl = '') {
            const cacheBust = Date.now();
            const res = await fetch(`${OWS_STORE_ANDROID_API_BASE}/releases/${encodeURIComponent(slug)}/latest?nocache=${cacheBust}`);
            if (!res.ok) throw new Error(`OWS Android API ${res.status}`);
            const data = await res.json();
            const release = data?.release || null;
            if (!release) throw new Error('Release Android sin payload.');
            const proxyDownloadUrl = `${OWS_STORE_ANDROID_API_BASE}/releases/${encodeURIComponent(slug)}/latest/download?versionCode=${encodeURIComponent(release.version_code || 'latest')}&nocache=${cacheBust}`;
            const directDownloadUrl = String(release.apk_url || '').trim();
            return {
                version: release.version_name || '',
                versionCode: Number(release.version_code || 0),
                packageId: release.package_id || '',
                downloadUrl: selectAndroidDownloadUrl(proxyDownloadUrl, directDownloadUrl) || (fallbackReleaseUrl || ''),
                directDownloadUrl,
                sizeBytes: Number(release.size_bytes || 0),
                sha256: release.sha256 || '',
                minStoreVersion: release.min_store_version || '',
                mandatory: Boolean(release.is_mandatory),
                notes: release.release_notes || '',
                publishedAt: release.published_at || null,
                source: 'ows-store-api',
                warning: release.apk_url ? '' : 'Release Android publicada sin apk_url.',
            };
        }

        async function fetchLatestFloretWindowsRelease() {
            const res = await fetch(FLORET_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const releases = await res.json();
            const list = Array.isArray(releases) ? releases : [];

            for (const rel of list) {
                const assets = Array.isArray(rel?.assets) ? rel.assets : [];
                const exeCandidates = assets
                    .filter((a) => typeof a?.name === 'string' && /\.exe$/i.test(a.name))
                    .map((a) => ({
                        asset: a,
                        score: scoreWindowsAssetName(a.name),
                        version: extractVersionFromText(a.name),
                        updatedAtMs: Date.parse(a.updated_at || '') || 0,
                    }))
                    .sort((x, y) => {
                        if (y.score !== x.score) return y.score - x.score;
                        const cmp = compareVersionLike(y.version, x.version);
                        if (cmp !== 0) return cmp;
                        return y.updatedAtMs - x.updatedAtMs;
                    });

                if (!exeCandidates.length) continue;
                const selected = exeCandidates[0];
                const versionFromTag = String(rel?.tag_name || '').replace(/^v/i, '');
                const versionFromAsset = selected?.version || '';
                return {
                    version: versionFromAsset || versionFromTag || null,
                    installerUrl: selected?.asset?.browser_download_url || '',
                    installerSize: Number(selected?.asset?.size || 0),
                    installerAvailable: Boolean(selected?.asset?.browser_download_url),
                    releaseNotes: String(rel?.body || '').trim(),
                    releaseUrl: rel?.html_url || FLORET_RELEASES_URL,
                    publishedAt: rel?.published_at || rel?.created_at || null,
                    warning: '',
                };
            }

            return {
                version: null,
                installerUrl: '',
                installerSize: 0,
                installerAvailable: false,
                releaseNotes: '',
                releaseUrl: FLORET_RELEASES_URL,
                publishedAt: null,
                warning: 'No se encontro release Windows (.exe) para Floret Shop.',
            };
        }

        async function fetchLatestFloretRelease() {
            const now = Date.now();
            if (floretProjectReleaseCache && (now - floretProjectReleaseCache.checkedAt) < 120000) {
                return floretProjectReleaseCache;
            }

            const [androidResult, windowsResult] = await Promise.allSettled([
                fetchLatestAndroidReleaseFromStoreApi(FLORET_ANDROID_SLUG, FLORET_RELEASES_URL),
                fetchLatestFloretWindowsRelease(),
            ]);

            const androidData = androidResult.status === 'fulfilled'
                ? androidResult.value
                : {
                    version: '',
                    versionCode: 0,
                    downloadUrl: '',
                    directDownloadUrl: '',
                    sizeBytes: 0,
                    publishedAt: null,
                    warning: 'No se pudo resolver release Android desde OWS Store API.',
                };

            const windowsData = windowsResult.status === 'fulfilled'
                ? windowsResult.value
                : {
                    version: '',
                    installerUrl: '',
                    installerSize: 0,
                    installerAvailable: false,
                    releaseNotes: '',
                    releaseUrl: FLORET_RELEASES_URL,
                    publishedAt: null,
                    warning: 'No se pudo resolver release Windows desde GitHub Releases.',
                };

            const warnings = [windowsData.warning, androidData.warning].filter(Boolean).join(' | ');
            const payload = {
                version: windowsData.version || androidData.version || null,
                windowsVersion: windowsData.version || '',
                androidVersion: androidData.version || '',
                windowsPublishedAt: windowsData.publishedAt || null,
                androidPublishedAt: androidData.publishedAt || null,
                versionCode: Number(androidData.versionCode || 0),
                installerUrl: windowsData.installerUrl || '',
                installerSize: Number(windowsData.installerSize || 0),
                installerAvailable: Boolean(windowsData.installerAvailable && windowsData.installerUrl),
                windowsReleaseNotes: windowsData.releaseNotes || '',
                androidReleaseNotes: androidData.notes || '',
                androidApkUrl: androidData.directDownloadUrl || androidData.downloadUrl || '',
                androidApkDirectUrl: androidData.directDownloadUrl || '',
                androidApkProxyUrl: androidData.downloadUrl || '',
                androidSha256: androidData.sha256 || '',
                androidApkSize: Number(androidData.sizeBytes || 0),
                androidAabUrl: '',
                androidAabSize: 0,
                androidAvailable: Boolean(androidData.directDownloadUrl || androidData.downloadUrl),
                releaseUrl: windowsData.releaseUrl || FLORET_RELEASES_URL,
                publishedAt: pickLatestDate(windowsData.publishedAt, androidData.publishedAt),
                warning: warnings,
                checkedAt: now,
            };
            floretProjectReleaseCache = payload;
            return payload;
        }

        async function fetchLatestOWSStoreAndroidRelease() {
            const now = Date.now();
            if (owsStoreAndroidReleaseCache && (now - owsStoreAndroidReleaseCache.checkedAt) < 120000) {
                return owsStoreAndroidReleaseCache;
            }

            try {
                const latest = await fetchLatestAndroidReleaseFromStoreApi(OWS_STORE_ANDROID_SLUG, OWS_STORE_RELEASES_URL);
                const payload = {
                    version: latest.version || '',
                    versionCode: Number(latest.versionCode || 0),
                    downloadUrl: latest.downloadUrl || OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL,
                    directDownloadUrl: latest.directDownloadUrl || '',
                    sha256: latest.sha256 || '',
                    sizeBytes: Number(latest.sizeBytes || 0),
                    publishedAt: latest.publishedAt || null,
                    source: latest.source || 'ows-store-api',
                    warning: latest.warning || '',
                    releaseNotes: latest.notes || '',
                    resolvable: Boolean((latest.version || '').trim() || Number(latest.versionCode || 0) > 0),
                    checkedAt: now
                };
                owsStoreAndroidReleaseCache = payload;
                return payload;
            } catch (err) {
                const fallback = {
                    version: '',
                    versionCode: 0,
                    downloadUrl: OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL,
                    directDownloadUrl: '',
                    sha256: '',
                    sizeBytes: 0,
                    publishedAt: null,
                    source: 'release-page',
                    warning: 'No se pudo resolver release Android desde OWS Store API.',
                    releaseNotes: '',
                    resolvable: false,
                    checkedAt: now
                };
                owsStoreAndroidReleaseCache = fallback;
                return fallback;
            }
        }

        async function fetchLatestOWSStoreWindowsRelease() {
            const now = Date.now();
            if (owsStoreWindowsReleaseCache && (now - owsStoreWindowsReleaseCache.checkedAt) < 120000) {
                return owsStoreWindowsReleaseCache;
            }

            const res = await fetch(OWS_STORE_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets
                .filter((a) => typeof a?.name === 'string' && /\.exe$/i.test(a.name))
                .map((a) => {
                    const name = String(a?.name || '').toLowerCase();
                    let score = scoreWindowsAssetName(name);
                    if (name.includes('ows.store') || name.includes('ows store') || name.includes('nexus store')) score += 18;
                    return {
                        asset: a,
                        version: extractVersionFromText(a.name),
                        updatedAtMs: Date.parse(a.updated_at || '') || 0,
                        score,
                    };
                })
                .sort((x, y) => {
                    if (y.score !== x.score) return y.score - x.score;
                    const cmp = compareVersionLike(y.version, x.version);
                    if (cmp !== 0) return cmp;
                    return y.updatedAtMs - x.updatedAtMs;
                });

            let selected = exeCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = exeCandidates.find((c) => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const versionFromAsset = selected?.version || '';
            const payload = {
                version: versionFromTag || versionFromAsset || '',
                tagVersion: versionFromTag || '',
                assetVersion: versionFromAsset || '',
                downloadUrl: selected?.asset?.browser_download_url || OWS_STORE_RELEASES_URL,
                sizeBytes: Number(selected?.asset?.size || 0),
                publishedAt: data.published_at || data.created_at || null,
                releaseNotes: String(data.body || '').trim(),
                warning: selected?.asset?.browser_download_url ? '' : 'No se encontro instalador Windows (.exe) en latest release.',
                checkedAt: now,
            };
            owsStoreWindowsReleaseCache = payload;
            return payload;
        }

        function renderOWSStoreAndroidMeta() {
            const meta = document.getElementById('ows-android-release-meta');
            if (!meta) return;
            const versionText = owsStoreAndroidState.version
                ? `Tag ${owsStoreAndroidState.version}${owsStoreAndroidState.versionCode > 0 ? ` (code ${owsStoreAndroidState.versionCode})` : ''}`
                : 'Tag sin resolver';
            const sizeText = owsStoreAndroidState.sizeBytes > 0 ? formatByteSize(owsStoreAndroidState.sizeBytes) : '-';
            const dateText = owsStoreAndroidState.publishedAt ? formatDateTime(owsStoreAndroidState.publishedAt) : 'sin fecha';
            const sourceText = owsStoreAndroidState.source === 'ows-store-api'
                ? 'source: OWS API'
                : (owsStoreAndroidState.source === 'release-asset'
                    ? 'source: release asset'
                    : 'source: release page');
            const warningText = owsStoreAndroidState.warning ? ` | ${owsStoreAndroidState.warning}` : '';
            meta.textContent = `${versionText} | ${sizeText} | ${dateText} | ${sourceText}${warningText}`;
        }

        async function refreshStoreAndroidReleaseLink() {
            const payload = await fetchLatestOWSStoreAndroidRelease();
            owsStoreAndroidState.downloadUrl = payload?.downloadUrl || OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL;
            owsStoreAndroidState.directDownloadUrl = payload?.directDownloadUrl || '';
            owsStoreAndroidState.sha256 = payload?.sha256 || '';
            owsStoreAndroidState.version = payload?.version || '';
            owsStoreAndroidState.versionCode = Number(payload?.versionCode || 0);
            owsStoreAndroidState.sizeBytes = Number(payload?.sizeBytes || 0);
            owsStoreAndroidState.publishedAt = payload?.publishedAt || null;
            owsStoreAndroidState.source = payload?.source || 'release-page';
            owsStoreAndroidState.warning = payload?.warning || '';
            owsStoreAndroidState.releaseNotes = payload?.releaseNotes || '';
            owsStoreAndroidState.resolvable = Boolean(payload?.resolvable || (payload?.version || '').trim() || Number(payload?.versionCode || 0) > 0);
            renderOWSStoreAndroidMeta();
        }

        function getStoredStoreAndroidInstalledVersion() {
            const versionName = String(localStorage.getItem(OWS_STORE_ANDROID_INSTALLED_VERSION_KEY) || '').trim();
            const versionCode = Number(localStorage.getItem(OWS_STORE_ANDROID_INSTALLED_VERSION_CODE_KEY) || 0);
            return {
                versionName,
                versionCode: Number.isFinite(versionCode) ? versionCode : 0,
            };
        }

        function clearStoredStoreAndroidInstalledVersion() {
            localStorage.removeItem(OWS_STORE_ANDROID_INSTALLED_VERSION_KEY);
            localStorage.removeItem(OWS_STORE_ANDROID_INSTALLED_VERSION_CODE_KEY);
        }

        function persistStoreAndroidInstalledVersion(versionName = '', versionCode = 0) {
            const cleanedName = String(versionName || '').trim();
            const cleanedCode = Number(versionCode || 0);
            if (cleanedName) localStorage.setItem(OWS_STORE_ANDROID_INSTALLED_VERSION_KEY, cleanedName);
            if (Number.isFinite(cleanedCode) && cleanedCode > 0) {
                localStorage.setItem(OWS_STORE_ANDROID_INSTALLED_VERSION_CODE_KEY, String(cleanedCode));
            }
        }

        async function resolveCurrentStoreAndroidVersionInfo() {
            const fallback = getStoredStoreAndroidInstalledVersion();
            let versionName = fallback.versionName;
            let versionCode = fallback.versionCode;
            let source = versionName || versionCode > 0 ? 'local-storage' : 'unknown';

            const AppPlugin = getCapacitorPlugin('App');
            if (AppPlugin?.getInfo) {
                try {
                    const info = await AppPlugin.getInfo();
                    const pluginName = String(info?.version || '').trim();
                    const pluginCode = Number(info?.build || 0);
                    if (pluginName) versionName = pluginName;
                    if (Number.isFinite(pluginCode) && pluginCode > 0) versionCode = pluginCode;
                    if (pluginName || pluginCode > 0) {
                        source = 'capacitor-app';
                        persistStoreAndroidInstalledVersion(pluginName, pluginCode);
                    }
                } catch (_) {}
            }

            return { versionName, versionCode, source };
        }

        function isCurrentStoreAndroidVersionKnown(current = null) {
            const name = String(current?.versionName || '').trim();
            const code = Number(current?.versionCode || 0);
            return Boolean(name || (Number.isFinite(code) && code > 0));
        }

        function isStoreAndroidUpdateNeeded(current, latest) {
            const latestCode = Number(latest?.versionCode || 0);
            const currentCode = Number(current?.versionCode || 0);
            if (latestCode > 0 && currentCode > 0) {
                return latestCode > currentCode;
            }
            const latestName = String(latest?.version || '').trim();
            const currentName = String(current?.versionName || '').trim();
            if (latestName && currentName) {
                return compareVersionLike(currentName, latestName) < 0;
            }
            return false;
        }

        async function applyWindowsManualUpdateSignal(currentVersion = '', { silent = false } = {}) {
            const latest = await fetchLatestOWSStoreWindowsRelease();
            const current = String(currentVersion || '').trim();
            const latestVersion = String(latest?.version || '').trim();
            if (!current || !latestVersion) {
                clearStoreObsoleteGate({ platform: 'windows', source: 'windows-manual-check', reason: 'insufficient-version-data' });
                owsStoreWindowsManualUpdateUrl = '';
                owsStoreWindowsManualVersion = '';
                return { needsUpdate: false, latest, current };
            }

            const needsUpdate = compareVersionLike(current, latestVersion) < 0;
            if (!needsUpdate) {
                clearStoreObsoleteGate({ platform: 'windows', source: 'windows-manual-check', reason: 'up-to-date' });
                owsStoreWindowsManualUpdateUrl = '';
                owsStoreWindowsManualVersion = '';
                return { needsUpdate: false, latest, current };
            }

            setStoreObsoleteGateBlocked({
                platform: 'windows',
                currentVersion: current,
                requiredVersion: latestVersion,
                reason: 'store-outdated',
                source: 'windows-manual-check',
            });
            owsStoreWindowsManualUpdateUrl = latest?.downloadUrl || OWS_STORE_RELEASES_URL;
            owsStoreWindowsManualVersion = latestVersion;
            appUpdateAvailable = true;
            appUpdateSizeBytes = Number(latest?.sizeBytes || 0);
            appUpdateEtaSeconds = null;
            syncUpdatesBadge();

            const btn = document.getElementById('btn-install-update');
            const closeBtn = document.getElementById('btn-close-update-banner');
            const status = document.getElementById('updates-status');
            if (btn) {
                btn.style.display = 'flex';
                btn.innerHTML = '<i class="fas fa-download"></i> Descargar update manual';
            }
            if (closeBtn) {
                closeBtn.disabled = false;
                closeBtn.style.opacity = '1';
                closeBtn.style.cursor = 'pointer';
            }
            if (status) status.textContent = `Update disponible: v${latestVersion} (manual)`;
            setUpdateBannerVisual({
                state: 'available',
                title: 'Actualizacion disponible',
                message: `Version v${latestVersion} detectada (actual: v${current}). Descarga manual recomendada.`,
                iconClass: 'fa-download',
                iconSpin: false,
            });
            setUpdateMetaUI({ sizeBytes: appUpdateSizeBytes, etaSeconds: null, transferredBytes: null, speedBps: 0 });
            updateDownloadSession(STORE_DOWNLOAD_KEY, {
                name: 'OWS Store',
                icon: STORE_LOCAL_ICON,
                isApp: true,
                phase: 'available',
                percent: 0,
                sizeBytes: appUpdateSizeBytes,
                downloadedBytes: 0,
                speedBps: 0,
                etaSeconds: null,
                status: `Update manual v${latestVersion} disponible`,
            });
            if (!silent) addNotification(`Update manual disponible: v${latestVersion}.`, 'warning');
            return { needsUpdate: true, latest, current };
        }

        async function requestWindowsUpdaterCheck({ silent = false, origin = '' } = {}) {
            if (!window.owsUpdater?.checkForUpdates) return { ok: false, reason: 'updater-unavailable' };
            lastStoreUpdaterCheckSilent = Boolean(silent);
            lastStoreUpdaterCheckOrigin = String(origin || (silent ? 'auto' : 'manual'));
            let response = null;
            try {
                response = await window.owsUpdater.checkForUpdates();
            } catch (err) {
                response = {
                    ok: false,
                    reason: 'check-crash',
                    message: err?.message || String(err || 'desconocido'),
                };
            }

            if (response && response.ok === false) {
                const msg = response.message || response.reason || 'desconocido';
                const status = document.getElementById('updates-status');
                if (status) status.textContent = 'Error de verificacion';
                setUpdateBannerVisual({
                    state: 'error',
                    title: 'Error de actualizacion',
                    message: 'No se pudo verificar updates automÃ¡ticas: ' + msg,
                    iconClass: 'fa-triangle-exclamation',
                    iconSpin: false,
                });
                if (!silent) addNotification('No se pudo verificar updater automÃ¡tico: ' + msg, 'warning');
                const currentVersion = String(await window.owsUpdater.getAppVersion?.().catch(() => '') || '').trim();
                if (currentVersion) currentStoreWindowsVersion = currentVersion;
                await applyWindowsManualUpdateSignal(currentStoreWindowsVersion, { silent: true }).catch(() => {});
            }
            return response;
        }

        async function checkOWSStoreAndroidUpdate({ silent = false, origin = '' } = {}) {
            const status = document.getElementById('updates-status');
            const btn = document.getElementById('btn-install-update');
            const closeBtn = document.getElementById('btn-close-update-banner');
            const wrap = document.getElementById('update-progress-wrap');
            const checkOrigin = String(origin || (silent ? 'auto' : 'manual'));
            if (btn) {
                btn.style.display = 'none';
                btn.innerHTML = '<i class="fas fa-mobile-screen-button"></i> Descargar update Android';
            }
            if (wrap) wrap.style.display = 'none';

            const latest = await fetchLatestOWSStoreAndroidRelease();
            owsStoreAndroidState.downloadUrl = latest?.downloadUrl || OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL;
            owsStoreAndroidState.directDownloadUrl = latest?.directDownloadUrl || '';
            owsStoreAndroidState.sha256 = latest?.sha256 || '';
            owsStoreAndroidState.version = latest?.version || '';
            owsStoreAndroidState.versionCode = Number(latest?.versionCode || 0);
            owsStoreAndroidState.sizeBytes = Number(latest?.sizeBytes || 0);
            owsStoreAndroidState.publishedAt = latest?.publishedAt || null;
            owsStoreAndroidState.source = latest?.source || 'release-page';
            owsStoreAndroidState.warning = latest?.warning || '';
            owsStoreAndroidState.resolvable = Boolean(latest?.resolvable || (latest?.version || '').trim() || Number(latest?.versionCode || 0) > 0);
            renderOWSStoreAndroidMeta();

            const current = await resolveCurrentStoreAndroidVersionInfo();
            const latestResolvable = Boolean(owsStoreAndroidState.resolvable);
            if (!latestResolvable) {
                clearStoreObsoleteGate({ platform: 'android', source: 'android-check', reason: 'latest-not-resolved' });
                appUpdateAvailable = false;
                appUpdateSizeBytes = 0;
                appUpdateEtaSeconds = null;
                syncUpdatesBadge();
                if (status) status.textContent = 'No se pudo confirmar updates Android';
                if (closeBtn) {
                    closeBtn.disabled = false;
                    closeBtn.style.opacity = '1';
                    closeBtn.style.cursor = 'pointer';
                }
                setUpdateBannerVisual({
                    state: 'info',
                    title: 'Estado de updates Android no concluyente',
                    message: 'No se pudo resolver la Ãºltima release Android. Reintenta en unos segundos.',
                    iconClass: 'fa-circle-info',
                    iconSpin: false,
                });
                setUpdateMetaUI({ sizeBytes: 0, etaSeconds: null, transferredBytes: null, speedBps: 0 });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    name: 'OWS Store Android',
                    icon: STORE_LOCAL_ICON,
                    isApp: true,
                    phase: 'error',
                    percent: 0,
                    status: 'No se pudo resolver la metadata Android de la Ãºltima release.',
                    sizeBytes: 0,
                    downloadedBytes: 0,
                    speedBps: 0,
                    etaSeconds: null,
                });
                if (!silent) addNotification('No se pudo confirmar updates Android (metadata no resoluble).', 'warning');
                return { needsUpdate: false, latest, current, uncertain: true };
            }
            const currentKnown = isCurrentStoreAndroidVersionKnown(current);
            const needsUpdate = isStoreAndroidUpdateNeeded(current, latest);
            appUpdateAvailable = Boolean(needsUpdate);
            appUpdateSizeBytes = Number(latest?.sizeBytes || 0);
            appUpdateEtaSeconds = null;
            syncUpdatesBadge();

            const currentLabel = current.versionName
                ? `${current.versionName}${current.versionCode > 0 ? ` (code ${current.versionCode})` : ''}`
                : (current.versionCode > 0 ? `code ${current.versionCode}` : 'desconocida');
            const latestLabel = latest?.version
                ? `${latest.version}${Number(latest?.versionCode || 0) > 0 ? ` (code ${Number(latest.versionCode || 0)})` : ''}`
                : 'desconocida';
            const appVersionLabel = current.versionName || (current.versionCode > 0 ? String(current.versionCode) : '');
            if (appVersionLabel) {
                const appVersionEl = document.getElementById('app-version');
                const updatesVersionEl = document.getElementById('updates-app-version');
                if (appVersionEl) appVersionEl.textContent = `v${appVersionLabel}`;
                if (updatesVersionEl) updatesVersionEl.textContent = `v${appVersionLabel}`;
            }

            if (!currentKnown) {
                clearStoreObsoleteGate({ platform: 'android', source: 'android-check', reason: 'installed-version-unknown' });
                appUpdateAvailable = true;
                syncUpdatesBadge();
                if (status) status.textContent = `No se pudo leer version instalada. Release detectada: ${latestLabel}`;
                if (btn) btn.style.display = 'flex';
                if (closeBtn) {
                    closeBtn.disabled = false;
                    closeBtn.style.opacity = '1';
                    closeBtn.style.cursor = 'pointer';
                }
                setUpdateBannerVisual({
                    state: 'available',
                    title: 'Verificacion Android incompleta',
                    message: `No se pudo leer la version instalada. Descarga recomendada: ${latestLabel}.`,
                    iconClass: 'fa-mobile-screen-button',
                    iconSpin: false,
                });
                setUpdateMetaUI({ sizeBytes: appUpdateSizeBytes, etaSeconds: null, transferredBytes: null, speedBps: 0 });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    name: 'OWS Store Android',
                    icon: STORE_LOCAL_ICON,
                    isApp: true,
                    phase: 'available',
                    percent: 0,
                    sizeBytes: appUpdateSizeBytes,
                    downloadedBytes: 0,
                    speedBps: 0,
                    etaSeconds: null,
                    status: `Comparacion no concluyente. Release ${latestLabel} disponible.`,
                });
                if (!silent) addNotification('No se pudo leer la version instalada de OWS Store Android. Se recomienda actualizar.', 'warning');
                return { needsUpdate: true, latest, current, uncertainCurrent: true };
            }

            if (needsUpdate) {
                setStoreObsoleteGateBlocked({
                    platform: 'android',
                    currentVersion: current.versionName || (current.versionCode > 0 ? String(current.versionCode) : ''),
                    requiredVersion: latest?.version || (Number(latest?.versionCode || 0) > 0 ? String(latest.versionCode) : ''),
                    reason: 'store-outdated',
                    source: 'android-check',
                });
                if (status) status.textContent = `Update Android disponible: ${latestLabel}`;
                if (btn) btn.style.display = 'flex';
                if (closeBtn) {
                    closeBtn.disabled = false;
                    closeBtn.style.opacity = '1';
                    closeBtn.style.cursor = 'pointer';
                }
                setUpdateBannerVisual({
                    state: 'available',
                    title: 'Actualizacion Android disponible',
                    message: `Version ${latestLabel} disponible (actual: ${currentLabel}).`,
                    iconClass: 'fa-mobile-screen-button',
                    iconSpin: false,
                });
                setUpdateMetaUI({ sizeBytes: appUpdateSizeBytes, etaSeconds: null, transferredBytes: null, speedBps: 0 });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    name: 'OWS Store Android',
                    icon: STORE_LOCAL_ICON,
                    isApp: true,
                    phase: 'available',
                    percent: 0,
                    sizeBytes: appUpdateSizeBytes,
                    downloadedBytes: 0,
                    speedBps: 0,
                    etaSeconds: null,
                    status: `Update disponible ${currentLabel} -> ${latestLabel}`,
                });
                if (!silent) addNotification(`Update Android disponible: ${currentLabel} -> ${latestLabel}.`, 'warning');
                return { needsUpdate, latest, current };
            }

            const autoCheck = checkOrigin === 'auto' || Boolean(silent);
            clearStoreObsoleteGate({ platform: 'android', source: 'android-check', reason: 'up-to-date' });
            if (status) status.textContent = autoCheck
                ? 'Verificacion automatica completada: sin actualizaciones nuevas.'
                : 'No hay actualizaciones pendientes.';
            if (closeBtn) {
                closeBtn.disabled = false;
                closeBtn.style.opacity = '1';
                closeBtn.style.cursor = 'pointer';
            }
            setUpdateBannerVisual({
                state: 'success',
                title: autoCheck ? 'Verificacion automatica completada' : 'No hay actualizaciones pendientes',
                message: autoCheck
                    ? 'Sin novedades de update en esta verificacion.'
                    : 'Tu OWS Store esta al dia.',
                iconClass: 'fa-circle-check',
                iconSpin: false,
            });
            setUpdateMetaUI({ sizeBytes: 0, etaSeconds: null, transferredBytes: null, speedBps: 0 });
            removeDownloadSession(STORE_DOWNLOAD_KEY);
            if (!silent) addNotification('No hay actualizaciones pendientes.', 'neutral');
            return { needsUpdate, latest, current };
        }

        function formatDateTime(value) {
            if (!value) return 'Sin fecha';
            const d = new Date(value);
            if (Number.isNaN(d.getTime())) return 'Sin fecha';
            return d.toLocaleString();
        }

        function getProjectIcon(project, size = 64) {
            if (isWildWeaponProject(project)) return WILDWEAPON_LOCAL_ICON;
            if (isSSAProject(project)) return project?.icon_url || `https://placehold.co/${size}/0f172a/00f3ff?text=SSA`;
            if (isOceanPayProject(project)) return project?.icon_url || OCEAN_PAY_LOCAL_ICON;
            if (isFloretProject(project)) return project?.icon_url || FLORET_LOCAL_ICON || `https://placehold.co/${size}/2b0a45/f2a3ff?text=FLR`;
            if (isWildTransferProject(project)) return project?.icon_url || WILDTRANSFER_LOCAL_ICON || `https://placehold.co/${size}/0a1120/35d7ff?text=WTR`;
            if (isWildDestinyProject(project)) return project?.icon_url || WILDDESTINY_LOCAL_ICON || `https://placehold.co/${size}/111827/67e8f9?text=WD`;
            if (isVelocitySurgeProject(project)) return project?.icon_url || VELOCITY_SURGE_LOCAL_ICON || `https://placehold.co/${size}/0a0f1e/26e0ff?text=VSG`;
            return project?.icon_url || `https://placehold.co/${size}/0f172a/00f3ff?text=OWS`;
        }

        function isWildWeaponProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('wildweapon') || name.includes('wildweapon mayhem');
        }

        function getPlatformTokens(project) {
            const raw = [project?.platform, project?.platforms]
                .filter(Boolean)
                .join(',')
                .toLowerCase();
            return new Set(
                raw
                    .split(/[\s,;/|]+/)
                    .map((x) => x.trim())
                    .filter(Boolean)
            );
        }

        function supportsWindowsInstaller(project) {
            if (!project) return false;
            const tokens = getPlatformTokens(project);
            if (isWildWeaponProject(project) || isSSAProject(project) || isOceanPayProject(project) || isWildTransferProject(project) || isVelocitySurgeProject(project)) return true;
            if (tokens.has('windows') || tokens.has('win')) return true;
            return Boolean(project.installer_url || project.release_url || project.windows_installer_url);
        }

        function supportsAndroidDownloads(project) {
            if (!project) return false;
            const tokens = getPlatformTokens(project);
            if (tokens.has('android')) return true;
            if (isFloretProject(project)) return true;
            return Boolean(project.android_apk_url || project.android_aab_url || project.android_release_url);
        }

        function selectAndroidDownloadUrl(proxyUrl = '', directUrl = '') {
            const proxy = String(proxyUrl || '').trim();
            const direct = String(directUrl || '').trim();
            if (isNativeAndroidRuntime()) return direct || proxy || '';
            return proxy || direct || '';
        }

        function getProjectInstallTargets(project) {
            if (!project) return [];
            const targets = [];
            if (supportsWindowsInstaller(project)) {
                const winUrl = getInstallerUrl(project);
                const winPending = project.pending_release || project.installer_available === false;
                targets.push({
                    id: 'windows',
                    kind: 'windows',
                    label: 'Windows (.exe)',
                    actionLabel: 'Instalar en Windows',
                    url: winUrl,
                    sizeBytes: Number(project.installer_size || 0),
                    version: project.windows_version || project.version || '',
                    available: Boolean(winUrl) && !winPending,
                    pending: Boolean(winPending),
                });
            }

            if (supportsAndroidDownloads(project)) {
                const apkProxyUrl = String(project.android_apk_proxy_url || '').trim();
                const apkDirectUrl = String(project.android_apk_direct_url || '').trim();
                const apkUrl = selectAndroidDownloadUrl(apkProxyUrl || project.android_apk_url || '', apkDirectUrl);
                targets.push({
                    id: 'android-apk',
                    kind: 'android',
                    label: 'Android (APK)',
                    actionLabel: 'Descargar APK',
                    url: apkUrl,
                    directUrl: apkDirectUrl,
                    proxyUrl: apkProxyUrl,
                    sha256: String(project.android_sha256 || '').trim(),
                    sizeBytes: Number(project.android_apk_size || 0),
                    version: project.android_version || project.version || '',
                    available: Boolean(apkUrl),
                    pending: !apkUrl,
                });
            }
            return targets;
        }

        function getSelectedInstallTarget(project) {
            const targets = getProjectInstallTargets(project);
            if (!targets.length) return null;
            const selectedId = selectedInstallTargetBySlug[project.slug];
            if (selectedId) {
                const selected = targets.find((t) => t.id === selectedId);
                if (selected) return selected;
            }
            const installedPlatform = normalizePlatformKind(getInstalledPlatform(project.slug));
            if (installedPlatform === 'android') {
                const androidTarget = targets.find((t) => t.kind === 'android');
                if (androidTarget) return androidTarget;
            }
            if (installedPlatform === 'windows') {
                const windowsTarget = targets.find((t) => t.kind === 'windows');
                if (windowsTarget) return windowsTarget;
            }
            if (isNativeAndroidRuntime()) {
                const androidTarget = targets.find((t) => t.kind === 'android');
                if (androidTarget) return androidTarget;
            } else {
                const windowsTarget = targets.find((t) => t.kind === 'windows');
                if (windowsTarget) return windowsTarget;
            }
            return targets.find((t) => t.available) || targets[0];
        }

        function selectInstallTarget(slug, targetId) {
            selectedInstallTargetBySlug[slug] = targetId;
            openDetails(slug);
        }

        function getProjectPlatformLabel(project) {
            const targets = getProjectInstallTargets(project);
            const hasWin = targets.some((t) => t.kind === 'windows');
            const hasAndroid = targets.some((t) => t.kind === 'android');
            const anyAvailable = targets.some((t) => t.available);
            if (!anyAvailable && (project.pending_release || project.installer_available === false)) return 'PENDING RELEASE';
            if (hasWin && hasAndroid) return 'WIN + ANDROID';
            if (hasAndroid) return 'ANDROID';
            if (hasWin) return 'WINDOWS';
            return (project.status || 'launched').toUpperCase();
        }

        async function applyLatestInstallerData(projects) {
            if (!Array.isArray(projects)) return;
            const wildWeapon = projects.find(p => isWildWeaponProject(p));
            const ssa = projects.find(p => isSSAProject(p));
            const oceanPay = projects.find(p => isOceanPayProject(p));
            const floret = projects.find(p => isFloretProject(p));
            const wildTransfer = projects.find(p => isWildTransferProject(p));
            const velocitySurge = projects.find(p => isVelocitySurgeProject(p));

            if (wildWeapon) {
                wildWeapon.platform = 'windows';
                wildWeapon.install_type = 'external';
                if (!wildWeapon.installer_url) wildWeapon.installer_url = WILDWEAPON_RELEASES_URL;
                wildWeapon.icon_url = WILDWEAPON_LOCAL_ICON;
                wildWeapon.installer_available = false;
                wildWeapon.last_update_at = null;
                wildWeapon.windows_last_update_at = null;
                wildWeapon.android_last_update_at = null;
                wildWeapon.pending_release = false;
                wildWeapon.installer_size = Number(wildWeapon.installer_size || 0);

                try {
                    const latest = await fetchLatestWildWeaponRelease();
                    if (latest?.version) wildWeapon.version = latest.version;
                    if (latest?.installerUrl) wildWeapon.installer_url = latest.installerUrl;
                    wildWeapon.installer_size = Number(latest?.installerSize || 0);
                    wildWeapon.installer_available = Boolean(latest?.installerAvailable);
                    wildWeapon.last_update_at = latest?.publishedAt || null;
                    wildWeapon.windows_last_update_at = latest?.publishedAt || null;
                    wildWeapon.pending_release = !wildWeapon.installer_available;
                    if (latest?.warning) {
                        wildWeapon.pending_release = true;
                        wildWeapon.release_warning = latest.warning;
                    } else {
                        wildWeapon.release_warning = '';
                    }
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de WildWeapon:', err?.message || err);
                    wildWeapon.pending_release = true;
                    wildWeapon.release_warning = 'No se pudo validar el instalador de la ultima release.';
                }
            }

            if (ssa) {
                ssa.platform = 'windows';
                ssa.install_type = 'external';
                if (!ssa.installer_url) ssa.installer_url = SSA_RELEASES_URL;
                ssa.icon_url = SSA_LOCAL_ICON;
                ssa.installer_available = false;
                ssa.last_update_at = null;
                ssa.windows_last_update_at = null;
                ssa.android_last_update_at = null;
                ssa.pending_release = false;
                ssa.short = 'SSA';
                ssa.installer_size = Number(ssa.installer_size || 0);

                try {
                    const latest = await fetchLatestSSARelease();
                    if (latest?.version) ssa.version = latest.version;
                    if (latest?.installerUrl) ssa.installer_url = latest.installerUrl;
                    ssa.installer_size = Number(latest?.installerSize || 0);
                    ssa.installer_available = Boolean(latest?.installerAvailable);
                    ssa.last_update_at = latest?.publishedAt || null;
                    ssa.windows_last_update_at = latest?.publishedAt || null;
                    ssa.pending_release = !ssa.installer_available;
                    if (latest?.warning) {
                        ssa.pending_release = true;
                        ssa.release_warning = latest.warning;
                    } else {
                        ssa.release_warning = '';
                    }
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de SSA:', err?.message || err);
                    ssa.pending_release = true;
                    ssa.release_warning = 'No se pudo validar el instalador de la ultima release.';
                }
            }

            if (oceanPay) {
                oceanPay.platform = 'windows';
                oceanPay.install_type = 'external';
                if (!oceanPay.installer_url) oceanPay.installer_url = OCEAN_PAY_RELEASES_URL;
                oceanPay.icon_url = OCEAN_PAY_LOCAL_ICON;
                oceanPay.installer_available = false;
                oceanPay.last_update_at = null;
                oceanPay.windows_last_update_at = null;
                oceanPay.android_last_update_at = null;
                oceanPay.pending_release = false;
                oceanPay.installer_size = Number(oceanPay.installer_size || 0);

                try {
                    const latest = await fetchLatestOceanPayRelease();
                    if (latest?.version) oceanPay.version = latest.version;
                    if (latest?.installerUrl) oceanPay.installer_url = latest.installerUrl;
                    oceanPay.installer_size = Number(latest?.installerSize || 0);
                    oceanPay.installer_available = Boolean(latest?.installerAvailable);
                    oceanPay.last_update_at = latest?.publishedAt || null;
                    oceanPay.windows_last_update_at = latest?.publishedAt || null;
                    oceanPay.pending_release = !oceanPay.installer_available;
                    if (latest?.warning) {
                        oceanPay.pending_release = true;
                        oceanPay.release_warning = latest.warning;
                    } else {
                        oceanPay.release_warning = '';
                    }
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de Ocean Pay:', err?.message || err);
                    oceanPay.pending_release = true;
                    oceanPay.release_warning = 'No se pudo validar el instalador de la ultima release.';
                }
            }

            if (floret) {
                floret.platform = 'android,windows';
                floret.install_type = 'external';
                if (!floret.android_release_url) floret.android_release_url = FLORET_RELEASES_URL;
                if (!floret.android_apk_url) floret.android_apk_url = '';
                if (!floret.android_apk_direct_url) floret.android_apk_direct_url = '';
                if (!floret.android_apk_proxy_url) floret.android_apk_proxy_url = '';
                if (!floret.android_sha256) floret.android_sha256 = '';
                if (!floret.windows_version) floret.windows_version = floret.version || '';
                if (!floret.android_version) floret.android_version = '';
                floret.icon_url = floret.icon_url || FLORET_LOCAL_ICON;
                floret.installer_available = false;
                floret.android_available = false;
                floret.last_update_at = null;
                floret.windows_last_update_at = null;
                floret.android_last_update_at = null;
                floret.pending_release = false;
                floret.installer_size = Number(floret.installer_size || 0);
                floret.android_apk_size = Number(floret.android_apk_size || 0);
                floret.android_aab_size = Number(floret.android_aab_size || 0);
                if (!floret.windows_release_notes) floret.windows_release_notes = '';
                if (!floret.android_release_notes) floret.android_release_notes = '';

                try {
                    const latest = await fetchLatestFloretRelease();
                    const preferredFloretVersion = isNativeAndroidRuntime()
                        ? (latest?.androidVersion || latest?.windowsVersion || floret.version)
                        : (latest?.windowsVersion || latest?.androidVersion || floret.version);
                    if (preferredFloretVersion) floret.version = preferredFloretVersion;
                    floret.windows_version = latest?.windowsVersion || floret.windows_version || floret.version || '';
                    floret.android_version = latest?.androidVersion || floret.android_version || '';
                    floret.android_version_code = Number(latest?.versionCode || 0);
                    if (latest?.installerUrl) floret.installer_url = latest.installerUrl;
                    if (latest?.releaseUrl) floret.android_release_url = latest.releaseUrl;
                    if (latest?.androidApkUrl) floret.android_apk_url = latest.androidApkUrl;
                    floret.android_apk_direct_url = latest?.androidApkDirectUrl || floret.android_apk_direct_url || '';
                    floret.android_apk_proxy_url = latest?.androidApkProxyUrl || floret.android_apk_proxy_url || '';
                    floret.android_sha256 = latest?.androidSha256 || floret.android_sha256 || '';
                    if (latest?.androidAabUrl) floret.android_aab_url = latest.androidAabUrl;
                    floret.installer_size = Number(latest?.installerSize || 0);
                    floret.installer_available = Boolean(latest?.installerAvailable);
                    floret.windows_release_notes = latest?.windowsReleaseNotes || floret.windows_release_notes || '';
                    floret.android_release_notes = latest?.androidReleaseNotes || floret.android_release_notes || '';
                    floret.android_apk_size = Number(latest?.androidApkSize || 0);
                    floret.android_aab_size = Number(latest?.androidAabSize || 0);
                    floret.android_available = Boolean(latest?.androidAvailable || floret.android_apk_url || floret.android_aab_url);
                    floret.last_update_at = latest?.publishedAt || null;
                    floret.windows_last_update_at = latest?.windowsPublishedAt || null;
                    floret.android_last_update_at = latest?.androidPublishedAt || null;
                    floret.pending_release = !floret.installer_available && !floret.android_available;
                    floret.release_warning = latest?.warning || '';
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de Floret Shop:', err?.message || err);
                    floret.pending_release = false;
                    floret.release_warning = 'No se pudo validar la release de Floret Shop (Windows/Android).';
                }
            }

            if (wildTransfer) {
                wildTransfer.platform = 'android,windows';
                wildTransfer.install_type = 'external';
                if (!wildTransfer.installer_url) wildTransfer.installer_url = WILDTRANSFER_RELEASES_URL;
                if (!wildTransfer.android_release_url) wildTransfer.android_release_url = WILDTRANSFER_RELEASES_URL;
                if (!wildTransfer.android_apk_url) wildTransfer.android_apk_url = '';
                if (!wildTransfer.android_apk_direct_url) wildTransfer.android_apk_direct_url = '';
                if (!wildTransfer.android_apk_proxy_url) wildTransfer.android_apk_proxy_url = '';
                if (!wildTransfer.android_sha256) wildTransfer.android_sha256 = '';
                if (!wildTransfer.windows_release_notes) wildTransfer.windows_release_notes = '';
                if (!wildTransfer.android_release_notes) wildTransfer.android_release_notes = '';
                if (!wildTransfer.windows_version) wildTransfer.windows_version = wildTransfer.version || '';
                if (!wildTransfer.android_version) wildTransfer.android_version = '';
                wildTransfer.icon_url = wildTransfer.icon_url || WILDTRANSFER_LOCAL_ICON;
                wildTransfer.installer_available = false;
                wildTransfer.android_available = false;
                wildTransfer.last_update_at = null;
                wildTransfer.windows_last_update_at = null;
                wildTransfer.android_last_update_at = null;
                wildTransfer.pending_release = false;
                wildTransfer.short = 'WTR';
                wildTransfer.installer_size = Number(wildTransfer.installer_size || 0);
                wildTransfer.android_apk_size = Number(wildTransfer.android_apk_size || 0);
                wildTransfer.android_aab_size = Number(wildTransfer.android_aab_size || 0);

                try {
                    const latest = await fetchLatestWildTransferRelease();
                    const preferredWildTransferVersion = isNativeAndroidRuntime()
                        ? (latest?.androidVersion || latest?.windowsVersion || wildTransfer.version)
                        : (latest?.windowsVersion || latest?.androidVersion || wildTransfer.version);
                    if (preferredWildTransferVersion) wildTransfer.version = preferredWildTransferVersion;
                    wildTransfer.windows_version = latest?.windowsVersion || wildTransfer.windows_version || wildTransfer.version || '';
                    wildTransfer.android_version = latest?.androidVersion || wildTransfer.android_version || '';
                    wildTransfer.android_version_code = Number(latest?.versionCode || 0);
                    if (latest?.installerUrl) wildTransfer.installer_url = latest.installerUrl;
                    if (latest?.releaseUrl) wildTransfer.android_release_url = latest.releaseUrl;
                    if (latest?.androidApkUrl) wildTransfer.android_apk_url = latest.androidApkUrl;
                    wildTransfer.android_apk_direct_url = latest?.androidApkDirectUrl || wildTransfer.android_apk_direct_url || '';
                    wildTransfer.android_apk_proxy_url = latest?.androidApkProxyUrl || wildTransfer.android_apk_proxy_url || '';
                    wildTransfer.android_sha256 = latest?.androidSha256 || wildTransfer.android_sha256 || '';
                    wildTransfer.windows_release_notes = latest?.windowsReleaseNotes || wildTransfer.windows_release_notes || '';
                    wildTransfer.android_release_notes = latest?.androidReleaseNotes || wildTransfer.android_release_notes || '';
                    wildTransfer.installer_size = Number(latest?.installerSize || 0);
                    wildTransfer.installer_available = Boolean(latest?.installerAvailable);
                    wildTransfer.android_apk_size = Number(latest?.androidApkSize || 0);
                    wildTransfer.android_aab_size = Number(latest?.androidAabSize || 0);
                    wildTransfer.android_available = Boolean(latest?.androidAvailable || wildTransfer.android_apk_url || wildTransfer.android_aab_url);
                    wildTransfer.last_update_at = latest?.publishedAt || null;
                    wildTransfer.windows_last_update_at = latest?.windowsPublishedAt || null;
                    wildTransfer.android_last_update_at = latest?.androidPublishedAt || null;
                    wildTransfer.pending_release = !wildTransfer.installer_available && !wildTransfer.android_available;
                    wildTransfer.release_warning = latest?.warning || '';
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de WildTransfer:', err?.message || err);
                    wildTransfer.pending_release = false;
                    wildTransfer.release_warning = 'No se pudo validar la release de WildTransfer (Windows/Android).';
                }
            }

            if (velocitySurge) {
                velocitySurge.platform = 'windows';
                velocitySurge.install_type = 'external';
                if (!velocitySurge.installer_url) velocitySurge.installer_url = VELOCITY_SURGE_RELEASES_URL;
                velocitySurge.icon_url = velocitySurge.icon_url || VELOCITY_SURGE_LOCAL_ICON;
                velocitySurge.installer_available = false;
                velocitySurge.last_update_at = null;
                velocitySurge.windows_last_update_at = null;
                velocitySurge.android_last_update_at = null;
                velocitySurge.pending_release = false;
                velocitySurge.short = 'VSG';
                velocitySurge.installer_size = Number(velocitySurge.installer_size || 0);

                try {
                    const latest = await fetchLatestVelocitySurgeRelease();
                    if (latest?.version) velocitySurge.version = latest.version;
                    if (latest?.installerUrl) velocitySurge.installer_url = latest.installerUrl;
                    velocitySurge.installer_size = Number(latest?.installerSize || 0);
                    velocitySurge.installer_available = Boolean(latest?.installerAvailable);
                    velocitySurge.last_update_at = latest?.publishedAt || null;
                    velocitySurge.windows_last_update_at = latest?.publishedAt || null;
                    velocitySurge.pending_release = !velocitySurge.installer_available;
                    if (latest?.warning) {
                        velocitySurge.pending_release = true;
                        velocitySurge.release_warning = latest.warning;
                    } else {
                        velocitySurge.release_warning = '';
                    }
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de Velocity Surge:', err?.message || err);
                    velocitySurge.pending_release = true;
                    velocitySurge.release_warning = 'No se pudo validar el instalador de la ultima release.';
                }
            }

        }
        function isExternalInstallerProject(project) {
            if (!project) return false;
            return supportsWindowsInstaller(project) || supportsAndroidDownloads(project);
        }

        function getInstallerUrl(project) {
            if (!project) return '';
            if (project.installer_available === false) return '';
            if (project.installer_url) return project.installer_url;
            if (project.release_url) return project.release_url;
            if (isWildWeaponProject(project)) return WILDWEAPON_RELEASES_URL;
            if (isSSAProject(project)) return SSA_RELEASES_URL;
            if (isOceanPayProject(project)) return OCEAN_PAY_RELEASES_URL;
            if (isFloretProject(project)) return FLORET_RELEASES_URL;
            if (isWildTransferProject(project)) return WILDTRANSFER_RELEASES_URL;
            if (isVelocitySurgeProject(project)) return VELOCITY_SURGE_RELEASES_URL;
            return '';
        }

        function getCapacitorPlugin(pluginName) {
            const cap = window.Capacitor;
            if (!cap || !pluginName) return null;
            if (cap.Plugins && cap.Plugins[pluginName]) return cap.Plugins[pluginName];
            if (cap[pluginName]) return cap[pluginName];
            return null;
        }

        function isNativeAndroidRuntime() {
            const cap = window.Capacitor;
            if (!cap?.isNativePlatform?.()) return false;
            return String(cap?.getPlatform?.() || '').toLowerCase() === 'android';
        }

        function getAndroidApkInstallMode() {
            try {
                const raw = String(localStorage.getItem(OWS_STORE_ANDROID_APK_MODE_KEY) || '').trim().toLowerCase();
                if (raw === 'inapp') return raw;
                if (raw === 'external') {
                    // Migrate legacy external-default behavior to in-app installs.
                    localStorage.setItem(OWS_STORE_ANDROID_APK_MODE_KEY, 'inapp');
                    return 'inapp';
                }
            } catch (_) {}
            // Default behavior must stay inside OWS Store on Android.
            return 'inapp';
        }

        function shouldUseAndroidExternalInstallCompat() {
            if (!isNativeAndroidRuntime()) return false;
            const mode = getAndroidApkInstallMode();
            return mode === 'external';
        }

        function hasRecentUnknownSourcesAck() {
            try {
                const ts = Number(localStorage.getItem(OWS_STORE_ANDROID_UNKNOWN_SOURCES_ACK_KEY) || 0);
                if (!Number.isFinite(ts) || ts <= 0) return false;
                return (Date.now() - ts) < OWS_STORE_ANDROID_UNKNOWN_SOURCES_ACK_TTL_MS;
            } catch (_) {
                return false;
            }
        }

        function persistUnknownSourcesAckNow() {
            try {
                localStorage.setItem(OWS_STORE_ANDROID_UNKNOWN_SOURCES_ACK_KEY, String(Date.now()));
            } catch (_) {}
        }

        function openAndroidUnknownSourcesSettings() {
            const attempts = [
                'intent://settings#Intent;action=android.settings.MANAGE_UNKNOWN_APP_SOURCES;end',
                'intent://settings#Intent;action=android.settings.SECURITY_SETTINGS;end',
            ];
            for (const uri of attempts) {
                try {
                    const anchor = document.createElement('a');
                    anchor.href = uri;
                    anchor.target = '_self';
                    anchor.rel = 'noopener noreferrer';
                    anchor.style.display = 'none';
                    document.body.appendChild(anchor);
                    anchor.click();
                    anchor.remove();
                    return true;
                } catch (_) {}
            }
            return false;
        }

        async function ensureAndroidUnknownSourcesReady(projectName = 'esta app', options = {}) {
            if (!isNativeAndroidRuntime()) return { ok: true };
            const forcePrompt = Boolean(options?.forcePrompt);
            if (!forcePrompt && hasRecentUnknownSourcesAck()) return { ok: true };
            const safeProject = String(projectName || 'esta app');
            const confirmText = [
                `Antes de instalar ${safeProject}, habilita "Instalar apps desconocidas" para OWS Store.`,
                '',
                'HONOR:',
                'Ajustes > Seguridad y privacidad > Mayor seguridad y privacidad > Instalar aplicaciones de fuentes externas > OWS Store.',
                '',
                'Pulsa Aceptar si YA lo habilitaste. Pulsa Cancelar para abrir Ajustes ahora.',
            ].join('\n');
            const alreadyEnabled = window.confirm(confirmText);
            if (alreadyEnabled) {
                persistUnknownSourcesAckNow();
                return { ok: true };
            }
            const opened = openAndroidUnknownSourcesSettings();
            const helpMessage = opened
                ? 'Ajustes abiertos. Habilita "Instalar apps desconocidas" para OWS Store y reintenta.'
                : 'No se pudo abrir Ajustes automaticamente. Habilita "Instalar apps desconocidas" para OWS Store y reintenta.';
            addNotification(helpMessage, 'warning');
            showActionMessage(helpMessage, { state: 'info' });
            return {
                ok: false,
                code: 'unknown_sources_not_confirmed',
                error: 'Permiso de fuentes externas no confirmado.',
            };
        }

        function confirmAndroidInstallIntent(projectName = 'este proyecto') {
            if (!isNativeAndroidRuntime()) return true;
            const safeProject = String(projectName || 'este proyecto');
            const externalMode = shouldUseAndroidExternalInstallCompat();
            const confirmText = [
                `Vas a descargar e instalar ${safeProject} desde OWS Store.`,
                '',
                externalMode
                    ? 'Se usara modo compatibilidad: descarga externa del APK para mejor compatibilidad.'
                    : 'Por seguridad, Android pedira confirmacion del instalador APK.',
                'Pulsa Aceptar para continuar o Cancelar para detener el proceso.',
            ].join('\n');
            const accepted = window.confirm(confirmText);
            if (!accepted) {
                const msg = `Instalacion de ${safeProject} cancelada por seguridad.`;
                addNotification(msg, 'warning');
                showActionMessage(msg, { state: 'info' });
            }
            return accepted;
        }

        function formatInstallErrorDetail(err, fallback = 'desconocido') {
            if (!err) return fallback;
            if (typeof err === 'string') return err;
            const chunks = [];
            if (typeof err?.error === 'string' && err.error.trim()) chunks.push(err.error.trim());
            if (typeof err?.message === 'string' && err.message.trim()) chunks.push(err.message.trim());
            if (typeof err?.hint === 'string' && err.hint.trim()) chunks.push(err.hint.trim());
            if (Array.isArray(err?.missingPlugins) && err.missingPlugins.length) {
                chunks.push(`Plugins faltantes: ${err.missingPlugins.join(', ')}`);
            }
            if (Array.isArray(err?.availablePlugins) && err.availablePlugins.length) {
                chunks.push(`Plugins disponibles: ${err.availablePlugins.join(', ')}`);
            }
            if (typeof err?.code === 'string' && err.code.trim()) chunks.push(`Codigo: ${err.code.trim()}`);
            if (chunks.length) return chunks.join(' | ');
            try {
                return JSON.stringify(err);
            } catch (_) {
                return fallback;
            }
        }

        function base64ToUint8Array(base64Value = '') {
            const clean = String(base64Value || '').replace(/\s+/g, '');
            if (!clean) return new Uint8Array(0);
            const binary = atob(clean);
            const out = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) out[i] = binary.charCodeAt(i);
            return out;
        }

        async function computeSha256HexFromBase64(base64Value = '') {
            if (!window.crypto?.subtle) return '';
            const bytes = base64ToUint8Array(base64Value);
            if (!bytes.length) return '';
            const digest = await window.crypto.subtle.digest('SHA-256', bytes);
            return Array.from(new Uint8Array(digest)).map((b) => b.toString(16).padStart(2, '0')).join('');
        }

        async function installAndroidApkInApp({
            url,
            fileName = 'ows-project.apk',
            taskId = 'install_android',
            sessionKey = '',
            slug = '',
            projectName = 'Proyecto',
            expectedSize = 0,
            expectedSha256 = '',
            sessionIsApp = false,
        } = {}) {
            if (!url) return { ok: false, error: 'URL APK vacia.' };
            if (!isNativeAndroidRuntime()) return { ok: false, error: 'No es runtime Android nativo.' };
            const unknownSourcesReady = await ensureAndroidUnknownSourcesReady(projectName);
            if (!unknownSourcesReady?.ok) return unknownSourcesReady;

            const Filesystem = getCapacitorPlugin('Filesystem');
            const FileTransfer = getCapacitorPlugin('FileTransfer');
            const FileOpener = getCapacitorPlugin('FileOpener');
            if (!Filesystem || !FileTransfer || !FileOpener) {
                const missingPlugins = [];
                if (!Filesystem) missingPlugins.push('Filesystem');
                if (!FileTransfer) missingPlugins.push('FileTransfer');
                if (!FileOpener) missingPlugins.push('FileOpener');
                const availablePlugins = Object.keys(window.Capacitor?.Plugins || {}).sort();
                console.error('[OWS Store][Android] Plugins faltantes para instalar APK', {
                    missingPlugins,
                    availablePlugins,
                });
                return {
                    ok: false,
                    error: `Plugins Android faltantes (${missingPlugins.join(', ')}).`,
                    missingPlugins,
                    availablePlugins,
                };
            }

            const safeNameBase = String(fileName || 'ows-project.apk').replace(/[^\w.\-]+/g, '-').replace(/-+/g, '-');
            const safeName = /\.apk$/i.test(safeNameBase) ? safeNameBase : `${safeNameBase}.apk`;
            const relativePath = `ows-store/apk/${safeName}`;
            const directory = 'DOCUMENTS';
            const expectedBytes = Number(expectedSize || 0);
            const expectedHash = String(expectedSha256 || '').trim().toLowerCase();

            let progressHandle = null;
            let lastBytes = 0;
            let lastTs = Date.now();

            try {
                try {
                    await Filesystem.deleteFile({ directory, path: relativePath });
                } catch (_) {}

                let targetUri = '';
                try {
                    const uriResult = await Filesystem.getUri({ directory, path: relativePath });
                    targetUri = String(uriResult?.uri || '');
                } catch (_) {}
                if (!targetUri) return { ok: false, error: 'No se pudo resolver ruta local APK.' };

                if (sessionKey) {
                    updateDownloadSession(sessionKey, {
                        name: projectName,
                        slug,
                        phase: 'downloading',
                        percent: 0,
                        status: `Descargando APK (${safeName})...`,
                        sizeBytes: expectedBytes,
                        downloadedBytes: 0,
                        speedBps: 0,
                        etaSeconds: null,
                        isApp: Boolean(sessionIsApp),
                    });
                }
                if (slug) setRuntimeState(slug, { phase: 'downloading', percent: 0, taskId });

                if (typeof FileTransfer.addListener === 'function') {
                    progressHandle = await FileTransfer.addListener('progress', (p) => {
                        if (String(p?.type || '') !== 'download') return;
                        const transferred = Math.max(0, Number(p?.bytes || 0));
                        const totalFromEvent = Math.max(0, Number(p?.contentLength || 0));
                        const total = totalFromEvent > 0 ? totalFromEvent : expectedBytes;
                        const percent = total > 0 ? Math.max(0, Math.min(100, (transferred / total) * 100)) : 0;

                        const now = Date.now();
                        const dt = Math.max(0.08, (now - lastTs) / 1000);
                        const speed = Math.max(0, (transferred - lastBytes) / dt);
                        lastBytes = transferred;
                        lastTs = now;
                        const eta = speed > 0 && total > transferred ? (total - transferred) / speed : null;

                        if (slug) setRuntimeState(slug, { phase: 'downloading', percent, taskId });
                        if (sessionKey) {
                            updateDownloadSession(sessionKey, {
                                phase: 'downloading',
                                percent,
                                status: `Descargando APK... ${Math.round(percent)}%`,
                                sizeBytes: total > 0 ? total : expectedBytes,
                                downloadedBytes: transferred,
                                speedBps: speed,
                                etaSeconds: eta,
                                isApp: Boolean(sessionIsApp),
                            });
                        }
                    });
                }

                const downloadResult = await FileTransfer.downloadFile({
                    url,
                    path: targetUri,
                    progress: true,
                    readTimeout: 180000,
                    connectTimeout: 120000,
                });
                const downloadedPath = String(downloadResult?.path || targetUri || '');
                if (!downloadedPath) return { ok: false, error: 'APK descargado sin ruta valida.' };
                const stat = await Filesystem.stat({ directory, path: relativePath }).catch(() => null);
                const downloadedBytes = Number(stat?.size || 0);
                if (expectedBytes > 0 && downloadedBytes > 0) {
                    const minAcceptedBytes = Math.floor(expectedBytes * 0.8);
                    if (downloadedBytes < minAcceptedBytes) {
                        return {
                            ok: false,
                            error: `APK incompleto (${formatByteSize(downloadedBytes)} / ${formatByteSize(expectedBytes)}).`,
                            code: 'apk_incomplete_download',
                            hint: 'La descarga no termino correctamente. Reintenta con buena red.',
                        };
                    }
                }
                if (downloadedBytes > 0 && downloadedBytes < 200000) {
                    return {
                        ok: false,
                        error: `APK demasiado pequeno (${formatByteSize(downloadedBytes)}).`,
                        code: 'apk_too_small',
                        hint: 'El enlace devolvio un archivo invalido. Reintenta en unos segundos.',
                    };
                }
                if (expectedHash && typeof Filesystem.readFile === 'function') {
                    try {
                        const fileData = await Filesystem.readFile({ directory, path: relativePath });
                        const rawPayload = typeof fileData?.data === 'string' ? fileData.data : '';
                        const rawBase64 = rawPayload.includes(',') ? rawPayload.split(',').pop() : rawPayload;
                        const actualHash = await computeSha256HexFromBase64(rawBase64 || '');
                        if (actualHash && actualHash.toLowerCase() !== expectedHash) {
                            return {
                                ok: false,
                                error: 'Integridad APK fallida (SHA-256 no coincide).',
                                code: 'apk_hash_mismatch',
                                hint: `Esperado ${expectedHash.slice(0, 12)}..., recibido ${actualHash.slice(0, 12)}...`,
                            };
                        }
                    } catch (hashErr) {
                        console.log('[OWS Store][Android] No se pudo validar hash APK:', hashErr?.message || hashErr);
                    }
                }

                if (slug) setRuntimeState(slug, { phase: 'launching', percent: 100, taskId });
                if (sessionKey) {
                    updateDownloadSession(sessionKey, {
                        phase: 'launching',
                        percent: 100,
                        status: 'Abriendo instalador Android...',
                        downloadedBytes: expectedBytes > 0 ? expectedBytes : lastBytes,
                        etaSeconds: 0,
                        isApp: Boolean(sessionIsApp),
                    });
                }

                await FileOpener.openFile({
                    path: downloadedPath,
                    mimeType: 'application/vnd.android.package-archive',
                });

                // On some Android ROMs, chooser can close without launching installer
                // when "Install unknown apps" is disabled for this app.
                setTimeout(() => {
                    if (!isNativeAndroidRuntime()) return;
                    if (document.visibilityState === 'visible') {
                        const helpMsg = 'Si no se abre el instalador, habilita "Instalar apps desconocidas" para OWS Store. Si Android dice "paquete no valido", puede ser APK incompleto o firma distinta.';
                        if (sessionKey) {
                            updateDownloadSession(sessionKey, {
                                phase: 'ready',
                                status: helpMsg,
                            });
                        }
                        addNotification(helpMsg, 'warning');
                        showActionMessage(helpMsg, { state: 'info' });
                    }
                }, 1400);

                return { ok: true, path: downloadedPath };
            } catch (err) {
                return {
                    ok: false,
                    error: err?.message || String(err || 'error desconocido'),
                    code: err?.code || '',
                    details: (() => {
                        try {
                            return JSON.stringify(err);
                        } catch (_) {
                            return '';
                        }
                    })(),
                };
            } finally {
                try {
                    await progressHandle?.remove?.();
                } catch (_) {}
            }
        }

        function openExternal(url) {
            if (!url) return;
            const isApkUrl = /\.apk(?:$|[?#])/i.test(String(url));
            const isNativeRuntime = Boolean(window.Capacitor?.isNativePlatform?.());
            if (isApkUrl && isNativeRuntime) {
                try {
                    const anchor = document.createElement('a');
                    anchor.href = url;
                    anchor.download = '';
                    anchor.rel = 'noopener noreferrer';
                    anchor.target = '_self';
                    document.body.appendChild(anchor);
                    anchor.click();
                    anchor.remove();
                    return;
                } catch (_) {
                    try {
                        window.location.assign(url);
                        return;
                    } catch (_) {}
                }
            }
            if (window.owsUpdater?.openExternalUrl) {
                window.owsUpdater.openExternalUrl(url);
                return;
            }
            window.open(url, '_blank', 'noopener,noreferrer');
        }

        function findWildWeaponProject() {
            return Array.isArray(allProjects) ? allProjects.find(p => isWildWeaponProject(p)) : null;
        }

        function getInstalledVersion(slug) {
            return localStorage.getItem(`installed_${slug}`) || '';
        }

        function getInstalledVersionCode(slug) {
            const raw = Number(localStorage.getItem(`installed_version_code_${slug}`) || 0);
            return Number.isFinite(raw) ? raw : 0;
        }

        function getInstalledPlatform(slug) {
            return localStorage.getItem(`installed_platform_${slug}`) || '';
        }

        function getInstalledReleasePublishedAt(slug, platform = 'windows') {
            return localStorage.getItem(`installed_release_published_at_${slug}_${platform}`) || '';
        }

        function setInstalledReleasePublishedAt(slug, platform = 'windows', publishedAt = '') {
            const key = `installed_release_published_at_${slug}_${platform}`;
            const value = String(publishedAt || '').trim();
            if (value) localStorage.setItem(key, value);
            else localStorage.removeItem(key);
        }

        function persistAndroidInstallMarker(project, item = {}) {
            if (!project?.slug) return;
            const slug = String(project.slug || '').trim();
            if (!slug) return;
            const versionName = String(item?.versionName || project.android_version || project.version || '').trim();
            const versionCode = Number(item?.versionCode || project.android_version_code || project.version_code || 0);
            if (versionName) localStorage.setItem(`installed_${slug}`, versionName);
            localStorage.setItem(`installed_platform_${slug}`, 'android');
            if (Number.isFinite(versionCode) && versionCode > 0) {
                localStorage.setItem(`installed_version_code_${slug}`, String(versionCode));
            } else {
                localStorage.removeItem(`installed_version_code_${slug}`);
            }
            setInstalledReleasePublishedAt(
                slug,
                'android',
                item?.releasePublishedAt || project.android_last_update_at || project.last_update_at || ''
            );
        }

        function getLegacyInstallKeyAliases(project) {
            const slug = String(project?.slug || '').toLowerCase().trim();
            if (!slug) return [];
            const aliases = new Set();
            aliases.add(slug);
            aliases.add(slug.replace(/-/g, ''));
            aliases.add(slug.replace(/-/g, '_'));
            if (isFloretProject(project)) {
                aliases.add('floret');
                aliases.add('floretshop');
                aliases.add('floret-shop');
            }
            if (isWildTransferProject(project)) {
                aliases.add('wildtransfer');
                aliases.add('wild-transfer');
            }
            if (isVelocitySurgeProject(project)) {
                aliases.add('velocitysurge');
                aliases.add('velocity-surge');
            }
            if (isWildWeaponProject(project)) {
                aliases.add('wildweapon');
                aliases.add('wildweapon-mayhem');
            }
            return [...aliases].filter(Boolean);
        }

        function migrateLegacyInstallMarkerKeys(project) {
            if (!project?.slug) return;
            const canonicalSlug = String(project.slug || '').trim();
            if (!canonicalSlug) return;
            const aliases = getLegacyInstallKeyAliases(project).filter((x) => x !== canonicalSlug);
            if (!aliases.length) return;
            const canonicalVersionKey = `installed_${canonicalSlug}`;
            const canonicalPlatformKey = `installed_platform_${canonicalSlug}`;
            const canonicalCodeKey = `installed_version_code_${canonicalSlug}`;
            if (localStorage.getItem(canonicalVersionKey)) return;

            for (const alias of aliases) {
                const v = String(localStorage.getItem(`installed_${alias}`) || '').trim();
                if (!v) continue;
                localStorage.setItem(canonicalVersionKey, v);
                const p = normalizePlatformKind(localStorage.getItem(`installed_platform_${alias}`) || '');
                if (p) localStorage.setItem(canonicalPlatformKey, p);
                const code = String(localStorage.getItem(`installed_version_code_${alias}`) || '').trim();
                if (code) localStorage.setItem(canonicalCodeKey, code);
                if (!p && isNativeAndroidRuntime() && supportsAndroidDownloads(project)) {
                    localStorage.setItem(canonicalPlatformKey, 'android');
                }
                break;
            }
        }

        function getInstallHints(project) {
            const slug = String(project?.slug || '').toLowerCase();
            const name = String(project?.name || '').trim();
            const fallbackName = name || 'App';
            if (isWildWeaponProject(project)) {
                return {
                    installDirNames: ['WildWeapon Mayhem', 'wildweapon-mayhem'],
                    executableNames: ['WildWeapon Mayhem.exe', 'wildweapon-mayhem.exe'],
                    uninstallerNames: ['Uninstall WildWeapon Mayhem.exe', 'unins000.exe']
                };
            }
            if (isSSAProject(project)) {
                return {
                    installDirNames: ['Savage Space Animals', 'savagespaceanimals', 'savage-space-animals'],
                    executableNames: ['Savage Space Animals.exe', 'savagespaceanimals.exe', 'savage-space-animals.exe'],
                    uninstallerNames: ['Uninstall Savage Space Animals.exe', 'unins000.exe']
                };
            }
            if (isFloretProject(project)) {
                return {
                    installDirNames: ['Floret Shop', 'floretshop', 'floret-shop'],
                    executableNames: ['Floret Shop.exe', 'floretshop.exe', 'floret-shop.exe'],
                    uninstallerNames: ['Uninstall Floret Shop.exe', 'unins000.exe']
                };
            }
            if (isWildTransferProject(project)) {
                return {
                    installDirNames: ['WildTransfer', 'wildtransfer', 'wild-transfer'],
                    executableNames: ['WildTransfer.exe', 'wildtransfer.exe', 'wild-transfer.exe'],
                    uninstallerNames: ['Uninstall WildTransfer.exe', 'unins000.exe']
                };
            }
            if (isWildDestinyProject(project)) {
                return {
                    installDirNames: ['Wild Destiny', 'wild-destiny', 'wilddestiny'],
                    executableNames: ['Wild Destiny.exe', 'wild-destiny.exe', 'wilddestiny.exe'],
                    uninstallerNames: ['Uninstall Wild Destiny.exe', 'unins000.exe']
                };
            }
            if (isVelocitySurgeProject(project)) {
                return {
                    installDirNames: ['Velocity Surge', 'velocity-surge', 'velocitysurge'],
                    executableNames: ['Velocity Surge.exe', 'velocity-surge.exe', 'velocitysurge.exe'],
                    uninstallerNames: ['Uninstall Velocity Surge.exe', 'unins000.exe']
                };
            }
            if (isOWSNewsProject(project)) {
                return {
                    installDirNames: ['OWS News', 'ows-news', 'owsnews', 'Ocean and Wild Studios News'],
                    executableNames: ['OWS News.exe', 'ows-news.exe', 'owsnews.exe', 'Ocean and Wild Studios News.exe'],
                    uninstallerNames: ['Uninstall OWS News.exe', 'unins000.exe']
                };
            }
            return {
                installDirNames: [fallbackName, slug, fallbackName.replace(/\s+/g, '')],
                executableNames: [`${fallbackName}.exe`, `${slug}.exe`, `${fallbackName.replace(/\s+/g, '')}.exe`],
                uninstallerNames: [`Uninstall ${fallbackName}.exe`, 'unins000.exe']
            };
        }

        async function resolveInstalledApp(project) {
            if (!window.owsUpdater?.resolveInstalledApp) return { installed: false };
            const hints = getInstallHints(project);
            const result = await window.owsUpdater.resolveInstalledApp(hints);
            return result || { installed: false };
        }

        async function refreshInstallationStates() {
            const next = {};
            for (const p of allProjects) {
                migrateLegacyInstallMarkerKeys(p);
                const marker = getInstalledVersion(p.slug);
                const markerCode = getInstalledVersionCode(p.slug);
                const markerPlatform = normalizePlatformKind(getInstalledPlatform(p.slug));
                if (marker && !markerPlatform && isNativeAndroidRuntime() && supportsAndroidDownloads(p)) {
                    localStorage.setItem(`installed_platform_${p.slug}`, 'android');
                }
                const runtime = getRuntimeState(p.slug);
                const installingRuntime = ['queued', 'waiting', 'preparing', 'downloading', 'launching'].includes(runtime.phase);
                const suppressed = uninstallSuppressedBySlug[p.slug] === true;
                if (isExternalInstallerProject(p)) {
                    try {
                        const detected = await resolveInstalledApp(p);
                        const installedBySystem = Boolean(detected?.installed || marker);
                        const installed = installingRuntime ? true : (suppressed ? false : installedBySystem);
                        if (!installed && suppressed) uninstallSuppressedBySlug[p.slug] = false;
                        if (installed || installingRuntime || isProjectQueued(p.slug)) rememberProjectInLibrary(p.slug);
                        next[p.slug] = {
                            installed,
                            version: marker || '',
                            versionCode: markerCode,
                            exePath: detected?.exePath || '',
                            uninstallPath: detected?.uninstallPath || '',
                            installDir: detected?.installDir || '',
                            runtime,
                        };
                    } catch (_) {
                        const installed = installingRuntime ? true : (suppressed ? false : Boolean(marker));
                        if (installed || installingRuntime || isProjectQueued(p.slug)) rememberProjectInLibrary(p.slug);
                        next[p.slug] = { installed, version: marker || '', versionCode: markerCode, runtime };
                    }
                } else {
                    const installed = suppressed ? false : Boolean(marker);
                    if (installed || installingRuntime || isProjectQueued(p.slug)) rememberProjectInLibrary(p.slug);
                    next[p.slug] = { installed, version: marker || '', versionCode: markerCode, runtime };
                }
            }
            installStateBySlug = next;
        }

        async function openWildWeaponAction(event) {
            if (event && typeof event.preventDefault === 'function') event.preventDefault();
            const p = findWildWeaponProject();
            if (!p) {
                addNotification('WildWeapon Mayhem no esta disponible en el listado actual.', 'warning');
                showActionMessage('WildWeapon Mayhem no esta disponible en el listado actual.');
                return;
            }
            openDetails(p.slug);
        }

        function renderProjects(projects) {
            const container = document.getElementById('projects-container');
            container.innerHTML = '';
            if (!projects.length) {
                container.innerHTML = `<p style="color:var(--text-dim)">No hay resultados para tu busqueda/filtro.</p>`;
                return;
            }
            projects.forEach(p => {
                const card = document.createElement('div');
                card.className = 'app-card ecosystem-row';
                card.onclick = () => openDetails(p.slug);
                const isComingSoon = p.status === 'coming_soon';
                const runtime = getRuntimeState(p.slug);
                const isInstalling = isInstallingPhase(runtime.phase);
                const isQueued = runtime.phase === 'queued';
                const isPreparing = runtime.phase === 'preparing';
                const availabilityLabel = getProjectPlatformLabel(p);
                const short = getProjectShort(p);
                const updateInfo = getProjectUpdateInfo(p);
                const displayVersion = getProjectDisplayVersion(p);
                const updateHint = isReleaseTrackedProject(p)
                    ? (p.last_update_at ? `Ultima actualizacion: ${formatDateTime(p.last_update_at)}` : 'Ultima actualizacion: pendiente')
                    : (p.description || 'Proyecto oficial del ecosistema Ocean and Wild Studios.');
                const updateInfoHtml = isReleaseTrackedProject(p)
                    ? `<div class="ecosystem-submeta">${updateHint}</div>`
                    : '';
                const newBadgeHtml = hasNewBadge(p) ? `<span class="new-badge">NUEVO!</span>` : '';
                const updateFlagHtml = updateInfo.needsUpdate
                    ? `<div class="ecosystem-submeta" style="color:var(--brand-2); font-weight:700;">Update ${getPrimaryUpdatePlatformLabel(updateInfo)} disponible: v${updateInfo.latestVersion}</div>`
                    : '';
                const installingHtml = `
                    <div id="installing-text-${p.slug}" class="ecosystem-submeta" style="color:var(--brand-2); display:${(isInstalling || isQueued || isPreparing) ? 'block' : 'none'};">
                        ${isQueued ? 'En cola para descarga...' : (isPreparing ? 'Preparando instalador...' : (isInstalling ? `Instalando: ${Math.round(runtime.percent || 0)}%` : ''))}
                    </div>
                `;
                const countdownHtml = (isComingSoon && p.release_date)
                    ? `<span class="countdown" data-date="${p.release_date}">Cargando...</span>`
                    : `<span>${p.pending_release ? 'Esperando release' : 'Disponible'}</span>`;
                card.innerHTML = `
                    <div class="progress-overlay" id="loader-${p.slug}">
                        <div style="font-weight: 800; font-size: 0.8rem;">INSTALANDO...</div>
                        <div class="progress-bar-container"><div class="progress-fill" id="fill-${p.slug}"></div></div>
                    </div>
                    <img src="${getProjectIcon(p, 64)}" class="app-icon" alt="Icon">
                    <div class="ecosystem-main">
                        <div class="ecosystem-topline">
                            <div class="app-name"><span class="ecosystem-title-wrap">${p.name}${short ? ` <span style="font-size:0.72rem;color:var(--brand-2);">(${short})</span>` : ''}${newBadgeHtml}</span></div>
                            <span class="ecosystem-platform">${availabilityLabel}</span>
                        </div>
                        <div class="app-meta"><span>v${displayVersion || '1.0.0'}</span>${countdownHtml}</div>
                        ${updateInfoHtml || `<div class="ecosystem-submeta">${updateHint}</div>`}
                        ${updateFlagHtml}
                        ${installingHtml}
                    </div>
                    <button class="btn-install ecosystem-open-btn" onclick="event.stopPropagation(); openDetails('${p.slug}')">
                        <i class="fas fa-circle-info"></i> Ver ficha
                    </button>
                `;
                container.appendChild(card);
            });
            startCountdowns();
        }

        function renderLibrary() {
            const container = document.getElementById('library-container');
            if (!container) return;
            container.innerHTML = '';
            const libraryProjects = allProjects.filter((p) => {
                const state = installStateBySlug[p.slug] || {};
                const runtime = getRuntimeState(p.slug);
                const inRuntime = isInstallingPhase(runtime.phase) || runtime.phase === 'queued' || runtime.phase === 'preparing';
                return Boolean(state.installed) || isProjectInLibrary(p.slug) || inRuntime;
            });
            if (!libraryProjects.length) {
                container.innerHTML = `<p style="color:var(--text-dim)">Tu biblioteca esta vacia. Instala un proyecto desde Explorar para verlo aqui.</p>`;
                return;
            }

            libraryProjects.forEach((p) => {
                const state = installStateBySlug[p.slug] || {};
                const runtime = getRuntimeState(p.slug);
                const isInstalled = Boolean(state.installed);
                const isDownloading = isInstallingPhase(runtime.phase);
                const isQueued = runtime.phase === 'queued';
                const isPreparing = runtime.phase === 'preparing';
                const updateInfo = getProjectUpdateInfo(p);
                const card = document.createElement('div');
                card.className = 'app-card';
                const metaVersion = isInstalled
                    ? (state.version || getInstalledVersion(p.slug) || p.version || '1.0.0')
                    : (getProjectDisplayVersion(p) || p.version || '1.0.0');
                const installDate = isReleaseTrackedProject(p) && p.last_update_at
                    ? formatDateTime(p.last_update_at)
                    : 'Sin datos';
                const installedPlatform = getInstalledPlatform(p.slug);
                const openLabel = installedPlatform === 'android' ? 'Abrir APK' : 'Abrir';
                const statusLabel = isQueued
                    ? 'EN COLA'
                    : (isPreparing ? 'PREPARANDO' : (isDownloading ? `DESCARGANDO ${Math.round(runtime.percent || 0)}%` : 'INSTALADO'));
                const resolvedStatusLabel = isInstalled ? statusLabel : 'NO INSTALADO';
                const progressHtml = `
                    <div id="lib-progress-${p.slug}" class="progress-bar-container" style="margin-bottom:0.8rem; display:${isDownloading ? 'block' : 'none'};">
                        <div id="lib-fill-${p.slug}" class="progress-fill" style="width:${Math.round(runtime.percent || 0)}%"></div>
                    </div>
                `;
                const blockedByStore = isStoreObsoleteGateActive();
                const reinstallLabel = blockedByStore
                    ? 'Actualizar Store'
                    : (updateInfo.needsUpdate ? 'Actualizar' : 'Reinstalar');
                const reinstallIcon = blockedByStore ? 'fa-shield-halved' : 'fa-rotate';
                const reinstallAction = blockedByStore
                    ? `triggerStoreObsoleteNotice('${p.slug}')`
                    : `reinstallFromLibrary('${p.slug}')`;
                const actionsHtml = (isDownloading || isPreparing || isQueued)
                    ? `<div class="library-actions">
                        <button class="btn-install full" style="background:#b96700;" onclick="cancelInstallFromLibrary('${p.slug}')"><i class="fas fa-ban"></i> Cancelar instalacion</button>
                    </div>`
                    : (isInstalled
                        ? `<div class="library-actions">
                            <button class="btn-install" onclick="launchFromLibrary('${p.slug}')"><i class="fas fa-play"></i> ${openLabel}</button>
                            <button class="btn-install ${blockedByStore ? 'unavailable' : ''}" style="background:linear-gradient(90deg,var(--brand-2),#2aa0a6);" onclick="${reinstallAction}"><i class="fas ${reinstallIcon}"></i> ${reinstallLabel}</button>
                            <button class="btn-install full" style="background:#2b2e37;" onclick="uninstallFromLibrary('${p.slug}')"><i class="fas fa-trash"></i> Desinstalar</button>
                        </div>`
                        : `<div class="library-actions">
                            <button class="btn-install ${blockedByStore ? 'unavailable' : ''}" onclick="${reinstallAction}"><i class="fas ${blockedByStore ? 'fa-shield-halved' : 'fa-download'}"></i> ${blockedByStore ? 'Actualizar Store' : 'Instalar'}</button>
                            <button class="btn-install full" style="background:#2b2e37;" onclick="openDetails('${p.slug}')"><i class="fas fa-circle-info"></i> Ver ficha</button>
                        </div>`);
                const updateBadgeHtml = (isInstalled && updateInfo.needsUpdate)
                    ? `<div style="font-size:0.74rem; color:var(--brand-2); margin-bottom:0.8rem; font-weight:700;">Actualizacion disponible (${getPrimaryUpdatePlatformLabel(updateInfo)}): v${updateInfo.latestVersion}</div>`
                    : (!isInstalled
                        ? `<div style="font-size:0.74rem; color:var(--ink-soft); margin-bottom:0.8rem;">Guardado en biblioteca. Instala para jugar o usar.</div>`
                        : '');
                card.innerHTML = `
                    <img src="${getProjectIcon(p, 64)}" class="app-icon" alt="Icon">
                    <div class="app-name">${p.name}</div>
                    <div class="app-meta"><span>v${metaVersion}</span><span id="lib-status-${p.slug}">${resolvedStatusLabel}</span></div>
                    <div style="font-size:0.74rem; color:var(--ink-soft); margin-bottom:0.8rem;">Ult. update: ${installDate}</div>
                    ${updateBadgeHtml}
                    ${progressHtml}
                    ${actionsHtml}
                `;
                container.appendChild(card);
            });
        }

        function openDetails(slug) {
            const p = allProjects.find(pro => pro.slug === slug);
            if (!p) return;
            const detailNewTag = hasNewBadge(p) ? ' · NUEVO!' : '';
            document.getElementById('m-title').innerText = getProjectShort(p) ? `${p.name} (${getProjectShort(p)})${detailNewTag}` : `${p.name}${detailNewTag}`;
            document.getElementById('m-desc').innerText = p.description || "Explora una nueva dimension de entretenimiento con este proyecto oficial de Ocean and Wild Studios.";
            const isComingSoon = p.status === 'coming_soon';
            if (isComingSoon && p.release_date) {
                const launchDate = formatDateTime(p.release_date);
                document.getElementById('m-desc').innerText += `\n\nLanzamiento Windows programado: ${launchDate}.`;
            }
            if (isReleaseTrackedProject(p)) {
                const statusText = p.pending_release
                    ? (p.release_warning || 'Pendiente de publicacion en Releases')
                    : `Ultima actualizacion: ${formatDateTime(p.last_update_at)}`;
                document.getElementById('m-desc').innerText += `\n\n${statusText}.`;
            }
            document.getElementById('m-status').innerText = isComingSoon
                ? 'LANZAMIENTO PROGRAMADO'
                : (isReleaseTrackedProject(p)
                ? (p.pending_release ? 'PENDING RELEASE' : 'READY TO INSTALL')
                : (p.status || 'launched').toUpperCase());
            document.getElementById('m-icon').src = getProjectIcon(p, 140);
            document.getElementById('m-banner').style.backgroundImage = `url(${p.banner_url || 'https://images.unsplash.com/photo-1614850523296-d8c1af93d400?auto=format&fit=crop&q=80&w=800'})`;

            const targets = getProjectInstallTargets(p);
            const selectedTarget = getSelectedInstallTarget(p);
            if (selectedTarget) selectedInstallTargetBySlug[p.slug] = selectedTarget.id;
            const modalVersion = selectedTarget?.version || getProjectDisplayVersion(p) || p.version || '1.0.0';
            document.getElementById('m-version').innerText = modalVersion;
            const platformsWrap = document.getElementById('m-platforms');
            const platformOptions = document.getElementById('m-platform-options');
            const platformMeta = document.getElementById('m-platform-meta');
            if (platformsWrap && platformOptions && platformMeta) {
                if (targets.length > 1) {
                    platformOptions.innerHTML = targets.map((t) => `
                        <button class="platform-pill ${selectedTarget?.id === t.id ? 'active' : ''} ${t.available ? '' : 'is-disabled'}"
                                onclick="event.stopPropagation(); selectInstallTarget('${p.slug}', '${t.id}')">
                            ${t.label}
                        </button>
                    `).join('');
                    const sizeLabel = selectedTarget?.sizeBytes > 0 ? formatByteSize(selectedTarget.sizeBytes) : '-';
                    const versionLabel = selectedTarget?.version ? `v${selectedTarget.version}` : 'sin version';
                    const stateLabel = selectedTarget?.available ? 'Disponible' : 'Pendiente';
                    platformMeta.textContent = `${selectedTarget?.label || 'Target'} | ${stateLabel} | Tamano ${sizeLabel} | ${versionLabel}`;
                    platformsWrap.style.display = 'block';
                } else if (targets.length === 1) {
                    const t = targets[0];
                    platformOptions.innerHTML = '';
                    const sizeLabel = t?.sizeBytes > 0 ? formatByteSize(t.sizeBytes) : '-';
                    const versionLabel = t?.version ? `v${t.version}` : 'sin version';
                    const stateLabel = t?.available ? 'Disponible' : 'Pendiente';
                    platformMeta.textContent = `${t.label} | ${stateLabel} | Tamano ${sizeLabel} | ${versionLabel}`;
                    platformsWrap.style.display = 'block';
                } else {
                    platformOptions.innerHTML = '';
                    platformMeta.textContent = '';
                    platformsWrap.style.display = 'none';
                }
            }

            const actions = document.getElementById('m-actions');
            actions.innerHTML = '';
            const state = installStateBySlug[p.slug] || {};
            const installedV = state.version || localStorage.getItem(`installed_${p.slug}`);
            const isExternal = isExternalInstallerProject(p);
            const busy = isBusyInstalling(p.slug);
            const phase = getRuntimeState(p.slug).phase;
            const updateInfo = getProjectUpdateInfo(p);
            const selectedIsAndroid = selectedTarget?.kind === 'android';
            const selectedIsWindows = !selectedTarget || selectedTarget.kind === 'windows';
            const storeBlocked = isStoreObsoleteGateActive();

            let btnText = '<i class="fas fa-download"></i> INSTALAR PROYECTO';
            let btnClass = 'btn-install';
            if (isComingSoon) { btnText = 'PROXIMAMENTE'; btnClass += ' coming-soon'; }
            else if (busy) {
                if (phase === 'queued' || phase === 'waiting') btnText = '<i class="fas fa-list"></i> EN COLA...';
                else if (phase === 'preparing') btnText = '<i class="fas fa-gear"></i> PREPARANDO...';
                else btnText = '<i class="fas fa-spinner"></i> INSTALANDO...';
                btnClass += ' unavailable';
            }
            else if (isExternal) {
                if (selectedIsAndroid) {
                    if (!selectedTarget?.available || !selectedTarget?.url) {
                        btnText = '<i class="fas fa-clock"></i> APK PENDIENTE';
                        btnClass += ' unavailable';
                    } else {
                        btnText = '<i class="fas fa-mobile-screen-button"></i> DESCARGAR APK';
                    }
                } else if (selectedIsWindows) {
                    if (p.pending_release || p.installer_available === false) {
                        btnText = '<i class="fas fa-clock"></i> PENDIENTE DE RELEASE';
                        btnClass += ' unavailable';
                    } else if (updateInfo.needsUpdate) btnText = '<i class="fas fa-arrow-up"></i> ACTUALIZAR A v' + (p.version || 'latest');
                    else if (state.installed || installedV) btnText = '<i class="fas fa-rotate"></i> VER ULTIMA VERSION';
                    else btnText = '<i class="fas fa-download"></i> INSTALAR PROYECTO';
                }
            } else if (installedV) {
                if (updateInfo.needsUpdate) btnText = '<i class="fas fa-arrow-up"></i> ACTUALIZAR A v' + p.version;
                else btnText = '<i class="fas fa-play"></i> JUGAR AHORA';
            }
            if (!isComingSoon && !busy && storeBlocked && (isExternal || !installedV || updateInfo.needsUpdate)) {
                btnText = '<i class="fas fa-shield-halved"></i> ACTUALIZA OWS STORE';
                btnClass += ' unavailable';
            }

            const btn = document.createElement('button');
            btn.className = btnClass;
            btn.innerHTML = btnText;
            btn.onclick = async (e) => {
                closeDetails();
                if (!isComingSoon && !busy && storeBlocked && (isExternal || !installedV || updateInfo.needsUpdate)) {
                    triggerStoreObsoleteNotice(p.slug);
                    return;
                }
                await handleProjectAction(e, p);
            };
            actions.appendChild(btn);
            if (busy) {
                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'btn-install';
                cancelBtn.style.marginTop = '0.6rem';
                cancelBtn.style.background = '#b96700';
                cancelBtn.innerHTML = '<i class="fas fa-ban"></i> CANCELAR INSTALACION';
                cancelBtn.onclick = async () => { closeDetails(); await cancelInstallFromLibrary(p.slug); };
                actions.appendChild(cancelBtn);
            }
            renderProjectNewsInModal(p);
            maybeShowRecommendBubble(p);
            document.getElementById('details-modal').classList.add('active');
        }

        function closeDetails() { document.getElementById('details-modal').classList.remove('active'); }

        async function refreshTrackedProjectRelease(project, options = {}) {
            if (!project || !isReleaseTrackedProject(project)) return null;
            const force = Boolean(options?.force);
            if (force) {
                if (isWildWeaponProject(project)) wildWeaponReleaseCache = null;
                if (isSSAProject(project)) ssaReleaseCache = null;
                if (isOceanPayProject(project)) oceanPayProjectReleaseCache = null;
                if (isWildTransferProject(project)) wildTransferReleaseCache = null;
                if (isVelocitySurgeProject(project)) velocitySurgeReleaseCache = null;
            }
            const latest = isWildWeaponProject(project)
                ? await fetchLatestWildWeaponRelease()
                : (isSSAProject(project)
                    ? await fetchLatestSSARelease()
                    : (isOceanPayProject(project)
                        ? await fetchLatestOceanPayRelease()
                        : (isFloretProject(project)
                            ? await fetchLatestFloretRelease()
                            : (isWildTransferProject(project)
                                ? await fetchLatestWildTransferRelease()
                                : (isVelocitySurgeProject(project)
                                    ? await fetchLatestVelocitySurgeRelease()
                                    : await fetchLatestOWSNewsRelease())))));

            if (isFloretProject(project) || isWildTransferProject(project)) {
                const preferred = isNativeAndroidRuntime()
                    ? (latest?.androidVersion || latest?.windowsVersion || project.version)
                    : (latest?.windowsVersion || latest?.androidVersion || project.version);
                if (preferred) project.version = preferred;
                project.windows_version = latest?.windowsVersion || project.windows_version || project.version || '';
                project.android_version = latest?.androidVersion || project.android_version || '';
                project.android_version_code = Number(latest?.versionCode || project.android_version_code || 0);
                if (latest?.releaseUrl) project.android_release_url = latest.releaseUrl;
                project.windows_last_update_at = latest?.windowsPublishedAt || project.windows_last_update_at || null;
                project.android_last_update_at = latest?.androidPublishedAt || project.android_last_update_at || null;
                project.android_apk_direct_url = latest?.androidApkDirectUrl || project.android_apk_direct_url || '';
                project.android_apk_proxy_url = latest?.androidApkProxyUrl || project.android_apk_proxy_url || '';
                project.android_sha256 = latest?.androidSha256 || project.android_sha256 || '';
                if (isWildTransferProject(project) || isFloretProject(project)) {
                    project.windows_release_notes = latest?.windowsReleaseNotes || project.windows_release_notes || '';
                    project.android_release_notes = latest?.androidReleaseNotes || project.android_release_notes || '';
                }
            } else if (latest?.version) {
                project.version = latest.version;
                project.windows_last_update_at = latest?.publishedAt || project.windows_last_update_at || null;
            }

            if (latest?.installerUrl) project.installer_url = latest.installerUrl;
            project.installer_size = Number(latest?.installerSize || 0);
            project.installer_available = Boolean(latest?.installerAvailable);
            if (latest?.androidApkUrl) project.android_apk_url = latest.androidApkUrl;
            if (latest?.androidAabUrl) project.android_aab_url = latest.androidAabUrl;
            project.android_apk_size = Number(latest?.androidApkSize || 0);
            project.android_aab_size = Number(latest?.androidAabSize || 0);
            project.android_available = Boolean(latest?.androidAvailable || project.android_apk_url || project.android_aab_url);
            project.last_update_at = latest?.publishedAt || project.last_update_at || null;
            project.pending_release = supportsAndroidDownloads(project)
                ? (!project.installer_available && !project.android_available)
                : !project.installer_available;
            project.release_warning = latest?.warning || '';
            return latest;
        }

        async function handleProjectAction(e, project) {
            e.stopPropagation();
            if (!project) return;
            const installedV = localStorage.getItem(`installed_${project.slug}`);
            const isExternalProject = isExternalInstallerProject(project);
            const isPureLaunch = !isExternalProject && installedV === project.version;
            if (!isPureLaunch) {
                const blockedByStore = await ensureStoreIsUpToDateForProjectAction(`instalar o actualizar ${project.name}`, { openUpdates: true, forceCheck: true });
                if (blockedByStore) return;
            }
            uninstallSuppressedBySlug[project.slug] = false;
            if (isExternalInstallerProject(project) && (isProjectQueued(project.slug) || activeInstallTaskKey === getDownloadKeyForProject(project))) {
                addNotification(project.name + ' ya esta en cola de descarga.', 'warning');
                showActionMessage(project.name + ' ya esta en cola de descarga.', { state: 'info' });
                return;
            }
            if (isBusyInstalling(project.slug)) {
                addNotification('Ya hay una instalacion en curso para ' + project.name + '.', 'warning');
                showActionMessage('Instalacion en curso para ' + project.name + '.');
                return;
            }
            if (project.status === 'coming_soon') {
                addNotification(project.name + ' aun no esta disponible.', 'warning');
                showActionMessage(project.name + ' aun no esta disponible.');
                return;
            }
            let selectedTarget = getSelectedInstallTarget(project);
            if (isExternalInstallerProject(project)) {
                if (selectedTarget?.kind === 'android') {
                    if (isReleaseTrackedProject(project)) {
                        showActionMessage('Validando release Android de ' + project.name + '...', { state: 'checking' });
                        try {
                            await refreshTrackedProjectRelease(project, { force: true });
                            selectedTarget = getSelectedInstallTarget(project);
                        } catch (err) {
                            console.log('No se pudo refrescar release Android:', err?.message || err);
                            addNotification(`No se pudo validar la ultima release Android de ${project.name}.`, 'warning');
                        }
                    }
                    if (!selectedTarget || selectedTarget.kind !== 'android' || !selectedTarget.url) {
                        const warningText = `No hay enlace de descarga Android para ${project.name}.`;
                        addNotification(warningText, 'warning');
                        showActionMessage(warningText);
                        return;
                    }
                    if (isNativeAndroidRuntime()) {
                        if (!confirmAndroidInstallIntent(project.name)) return;
                        const gate = await ensureAndroidUnknownSourcesReady(project.name, { forcePrompt: true });
                        if (!gate?.ok) return;
                    }
                    const updatesStatus = document.getElementById('updates-project-status');
                    if (updatesStatus) updatesStatus.textContent = 'Descargando APK de ' + project.name + '...';
                    addNotification('Iniciando instalacion Android de ' + project.name + '...', 'neutral');
                    showActionMessage('Agregando ' + project.name + ' a la cola de instalacion Android...', { state: 'info' });
                    const queueKey = getDownloadKeyForProject(project);
                    const safeBaseName = String(project.name || 'android-app').replace(/[^\w.\-]+/g, '-').replace(/-+/g, '-');
                    const safeVersion = String(selectedTarget.version || project.version || 'latest').replace(/[^\w.\-]+/g, '-').replace(/-+/g, '-');
                    const queueItem = {
                        key: queueKey,
                        slug: project.slug,
                        platform: 'android',
                        url: selectedTarget.url,
                        fileName: `${safeBaseName}-${safeVersion}.apk`,
                        targetLabel: selectedTarget.label || 'Android (APK)',
                        sizeBytes: Number(selectedTarget.sizeBytes || project.android_apk_size || 0),
                        sha256: String(selectedTarget.sha256 || project.android_sha256 || '').trim(),
                        versionName: selectedTarget.version || project.version || 'latest',
                        versionCode: Number(project.android_version_code || 0),
                        releasePublishedAt: project.android_last_update_at || project.last_update_at || null,
                    };
                    rememberProjectInLibrary(project.slug);
                    projectInstallQueue.push(queueItem);
                    setRuntimeState(project.slug, { phase: 'queued', percent: 0, taskId: `install_${project.slug}` });
                    updateDownloadSession(queueKey, {
                        name: project.name,
                        slug: project.slug,
                        icon: getProjectIcon(project, 64),
                        phase: 'queued',
                        percent: 0,
                        status: 'En cola para descargar APK...',
                        sizeBytes: Number(queueItem.sizeBytes || 0),
                        isApp: false,
                    });
                    scheduleSectionRender({ projects: true, library: true, immediate: false });
                    syncQueueMarkers();
                    processProjectInstallQueue();
                    return;
                }

                setRuntimeState(project.slug, { phase: 'queued', percent: 0, taskId: `install_${project.slug}` });
                scheduleSectionRender({ projects: true, library: true, immediate: false });
                showActionMessage('Validando release de ' + project.name + '...', { state: 'checking' });
                if (isReleaseTrackedProject(project)) {
                    const requiresBlockingRefresh = !project.installer_url || project.installer_available === false || project.pending_release;
                    if (requiresBlockingRefresh) {
                        try {
                            await refreshTrackedProjectRelease(project);
                        } catch (err) {
                            console.log('No se pudo actualizar metadata release externa:', err?.message || err);
                            addNotification(`No se pudo resolver la ultima release de ${project.name}.`, 'warning');
                            project.pending_release = true;
                            project.release_warning = 'No se pudo validar el instalador de la ultima release.';
                        }
                    } else {
                        refreshTrackedProjectRelease(project)
                            .then(() => scheduleSectionRender({ projects: true, library: true, immediate: false }))
                            .catch((err) => console.log('Refresh release en background fallo:', err?.message || err));
                    }
                }
                const installerUrl = getInstallerUrl(project);
                if (!installerUrl) {
                    const updatesStatus = document.getElementById('updates-project-status');
                    if (updatesStatus) updatesStatus.textContent = 'Pendiente: instalador no publicado';
                    const warningText = project.release_warning || `${project.name} todavia no tiene instalador publicado en Releases.`;
                    addNotification(warningText, 'warning');
                    showActionMessage(warningText);
                    return alert(warningText);
                }
                const updatesStatus = document.getElementById('updates-project-status');
                if (updatesStatus) updatesStatus.textContent = 'Descargando instalador de ' + project.name + '...';
                addNotification('Iniciando instalacion de ' + project.name + '...', 'neutral');
                showActionMessage('Agregando ' + project.name + ' a la cola de instalacion...', { state: 'info' });
                const queueKey = getDownloadKeyForProject(project);
                const queueItem = {
                    key: queueKey,
                    slug: project.slug,
                    url: installerUrl,
                    fileName: `${project.name || 'installer'}-${project.version || 'latest'}.exe`,
                    sizeBytes: Number(project.installer_size || 0),
                    releasePublishedAt: project.windows_last_update_at || project.last_update_at || null,
                };
                rememberProjectInLibrary(project.slug);
                projectInstallQueue.push(queueItem);
                setRuntimeState(project.slug, { phase: 'queued', percent: 0, taskId: `install_${project.slug}` });
                updateDownloadSession(queueKey, {
                    name: project.name,
                    slug: project.slug,
                    icon: getProjectIcon(project, 64),
                    phase: 'queued',
                    percent: 0,
                    status: 'En cola para descarga...',
                    sizeBytes: Number(project.installer_size || 0),
                    isApp: false,
                });
                scheduleSectionRender({ projects: true, library: true, immediate: false });
                syncQueueMarkers();
                processProjectInstallQueue();
                return;
            }
            if (installedV === project.version) launchGame(project.url);
            else {
                rememberProjectInLibrary(project.slug);
                simulateInstall(project.slug, project.version);
            }
        }

        async function launchFromLibrary(slug) {
            const project = allProjects.find((p) => p.slug === slug);
            if (!project) return;
            if (isExternalInstallerProject(project)) {
                const state = installStateBySlug[slug] || {};
                const installedPlatform = getInstalledPlatform(slug);
                const androidTarget = getProjectInstallTargets(project).find((t) => t.id === 'android-apk' && t.url);
                const shouldUseAndroid = installedPlatform === 'android' || (!state.exePath && Boolean(androidTarget));
                if (shouldUseAndroid) {
                    if (!androidTarget?.url) {
                        addNotification('No se encontro APK para ' + project.name + '.', 'warning');
                        showActionMessage('No se encontro APK para ' + project.name + '.');
                        return;
                    }
                    if (window.owsUpdater?.installExternalInstaller || isNativeAndroidRuntime()) {
                        await handleProjectAction({ stopPropagation: () => {} }, project);
                        return;
                    }
                    openExternal(androidTarget.url);
                    addNotification('Abriendo APK de ' + project.name + '...', 'neutral');
                    showActionMessage('Abriendo APK de ' + project.name + '...', { state: 'info' });
                    return;
                }
                if (!state.exePath) {
                    addNotification('No se encontro ejecutable instalado para ' + project.name + '.', 'warning');
                    showActionMessage('No se encontro ejecutable instalado para ' + project.name + '.');
                    return;
                }
                const result = await window.owsUpdater?.launchInstalledApp?.({ exePath: state.exePath });
                if (!result?.ok) {
                    addNotification('No se pudo abrir ' + project.name + ': ' + (result?.error || 'desconocido'), 'error');
                    return;
                }
                addNotification('Abriendo ' + project.name + '...', 'success');
                return;
            }
            launchGame(project.url);
        }

        async function reinstallFromLibrary(slug) {
            const project = allProjects.find((p) => p.slug === slug);
            if (!project) return;
            await handleProjectAction({ stopPropagation: () => {} }, project);
        }

        async function cancelInstallFromLibrary(slug) {
            const runtime = getRuntimeState(slug);
            const taskId = runtime.taskId || `install_${slug}`;
            const project = allProjects.find((p) => p.slug === slug);
            const key = `project_${slug}`;
            const queuedIdx = projectInstallQueue.findIndex((item) => item.slug === slug);
            if (queuedIdx >= 0) {
                projectInstallQueue.splice(queuedIdx, 1);
                updateDownloadSession(key, { phase: 'cancelled', status: 'Descarga retirada de la cola.' });
                setRuntimeState(slug, { phase: 'idle', percent: 0, taskId: '' });
                syncQueueMarkers();
                await refreshInstallationStates();
                scheduleSectionRender({ projects: true, library: true, immediate: true });
                if (project) {
                    addNotification('Instalacion cancelada para ' + project.name + '.', 'warning');
                    showActionMessage('Instalacion cancelada para ' + project.name + '.', { state: 'info' });
                }
                return;
            }
            if (window.owsUpdater?.cancelExternalInstaller) {
                await window.owsUpdater.cancelExternalInstaller({ taskId });
            }
            setRuntimeState(slug, { phase: 'idle', percent: 0, taskId: '' });
            updateDownloadSession(key, { phase: 'cancelled', status: 'Instalacion cancelada por el usuario.' });
            await refreshInstallationStates();
            scheduleSectionRender({ projects: true, library: true, immediate: true });
            if (project) {
                addNotification('Instalacion cancelada para ' + project.name + '.', 'warning');
                showActionMessage('Instalacion cancelada para ' + project.name + '.');
            }
        }

        async function uninstallFromLibrary(slug) {
            const project = allProjects.find((p) => p.slug === slug);
            if (!project) return;
            rememberProjectInLibrary(slug);
            uninstallSuppressedBySlug[slug] = true;
            localStorage.removeItem(`installed_${slug}`);
            localStorage.removeItem(`installed_platform_${slug}`);
            localStorage.removeItem(`installed_version_code_${slug}`);
            setInstalledReleasePublishedAt(slug, 'windows', '');
            setInstalledReleasePublishedAt(slug, 'android', '');
            installStateBySlug[slug] = { ...(installStateBySlug[slug] || {}), installed: false, version: '' };
            scheduleSectionRender({ projects: true, library: true, immediate: true });
            const state = installStateBySlug[slug] || {};
            if (isExternalInstallerProject(project) && state.uninstallPath) {
                const result = await window.owsUpdater?.uninstallInstalledApp?.({ uninstallPath: state.uninstallPath });
                if (!result?.ok) {
                    uninstallSuppressedBySlug[slug] = false;
                    addNotification('No se pudo abrir desinstalador: ' + (result?.error || 'desconocido'), 'error');
                    await refreshInstallationStates();
                    scheduleSectionRender({ projects: true, library: true, immediate: true });
                    return;
                }
                addNotification('Desinstalador iniciado para ' + project.name + '.', 'neutral');
                await refreshInstallationStates();
                scheduleSectionRender({ projects: true, library: true, immediate: true });
                return;
            }
            await refreshInstallationStates();
            scheduleSectionRender({ projects: true, library: true, immediate: true });
            addNotification(project.name + ' removido de Biblioteca.', 'neutral');
        }

        function launchGame(url) {
            document.body.classList.add('no-scroll');
            document.getElementById('game-overlay').style.display = 'flex';
            document.getElementById('game-frame').src = url || 'about:blank';
        }

        function closeGame() {
            document.getElementById('game-overlay').style.display = 'none';
            document.getElementById('game-frame').src = 'about:blank';
            document.body.classList.remove('no-scroll');
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        function simulateInstall(slug, version) {
            const overlay = document.getElementById(`loader-${slug}`);
            const fill = document.getElementById(`fill-${slug}`);
            if (!overlay) return;
            overlay.style.display = 'flex';
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        localStorage.setItem(`installed_${slug}`, version);
                        overlay.style.display = 'none';
                        loadProjects();
                    }, 500);
                }
                if (fill) fill.style.width = progress + '%';
            }, 300);
        }

        function startCountdowns() {
            setInterval(() => {
                document.querySelectorAll('.countdown').forEach(el => {
                    const target = new Date(el.dataset.date).getTime();
                    const diff = target - Date.now();
                    if (diff <= 0) { el.innerText = "DISPONIBLE!"; el.style.color = "var(--success)"; return; }
                    const d = Math.floor(diff / 86400000), h = Math.floor((diff % 86400000) / 3600000), m = Math.floor((diff % 3600000) / 60000), s = Math.floor((diff % 60000) / 1000);
                    el.innerText = `${d}d ${h}h ${m}m ${s}s`;
                });
            }, 1000);
        }

        function showSection(id, triggerEl = null) {
            activeSection = id;
            document.querySelectorAll('main section').forEach(s => s.style.display = 'none');
            const target = document.getElementById(`${id}-view`);
            if (!target) return;
            target.style.display = 'block';
            document.querySelectorAll('.nav-menu .nav-item').forEach(i => i.classList.remove('active'));
            if (triggerEl) triggerEl.classList.add('active');
            if (id === 'library') {
                refreshInstallationStates().then(() => scheduleSectionRender({ projects: true, library: true, immediate: true }));
            }
            if (id === 'updates') {
                renderDownloadSurfaces();
                renderStoreNewsTimeline();
                if (isNativeAndroidRuntime() && typeof window.owsUpdater === 'undefined') {
                    checkOWSStoreAndroidUpdate({ silent: true, origin: 'auto' }).catch(() => {});
                } else if (window.owsUpdater?.checkForUpdates) {
                    requestWindowsUpdaterCheck({ silent: true, origin: 'auto' }).catch(() => {});
                }
            } else if (id === 'home') {
                renderNewsHub();
            }
        }

        function initUpdater() {
            if (typeof window.owsUpdater === 'undefined') {
                if (!isNativeAndroidRuntime()) return;
                const banner = document.getElementById('update-banner');
                const btn = document.getElementById('btn-install-update');
                const closeBtn = document.getElementById('btn-close-update-banner');
                const status = document.getElementById('updates-status');
                if (btn) {
                    btn.style.display = 'none';
                    btn.innerHTML = '<i class="fas fa-mobile-screen-button"></i> Descargar update Android';
                }
                if (closeBtn) {
                    closeBtn.disabled = true;
                    closeBtn.style.opacity = '0.45';
                    closeBtn.style.cursor = 'not-allowed';
                }
                setUpdateBannerVisual({
                    state: 'checking',
                    title: 'Buscando updates Android',
                    message: 'Comprobando nuevas versiones de OWS Store para Android...',
                    iconClass: 'fa-mobile-screen-button',
                    iconSpin: true,
                    meta: 'Tamano: - | ETA: -'
                });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    name: 'OWS Store Android',
                    icon: STORE_LOCAL_ICON,
                    isApp: true,
                    phase: 'checking',
                    percent: 0,
                    status: 'Verificando update Android...',
                    sizeBytes: 0,
                    downloadedBytes: 0,
                    speedBps: 0,
                    etaSeconds: null,
                });
                if (banner) banner.classList.add('visible');
                if (status) status.textContent = 'Buscando actualizaciones Android...';
                setUpdateMetaUI({ sizeBytes: 0, etaSeconds: null, transferredBytes: null, speedBps: 0 });
                checkOWSStoreAndroidUpdate({ silent: true, origin: 'auto' })
                    .catch((err) => {
                        const msg = err?.message || 'desconocido';
                        appUpdateAvailable = false;
                        syncUpdatesBadge();
                        if (status) status.textContent = 'Error de verificacion Android';
                        setUpdateBannerVisual({
                            state: 'error',
                            title: 'Error de actualizacion Android',
                            message: 'No se pudo verificar updates Android: ' + msg,
                            iconClass: 'fa-triangle-exclamation',
                            iconSpin: false,
                        });
                        updateDownloadSession(STORE_DOWNLOAD_KEY, {
                            name: 'OWS Store Android',
                            icon: STORE_LOCAL_ICON,
                            isApp: true,
                            phase: 'error',
                            percent: 0,
                            status: 'Error verificando update Android: ' + msg,
                        });
                        addNotification('Error verificando updates Android: ' + msg, 'error');
                        if (closeBtn) {
                            closeBtn.disabled = false;
                            closeBtn.style.opacity = '1';
                            closeBtn.style.cursor = 'pointer';
                        }
                    });
                return;
            }
            const isExternalInstallActive = () => Boolean(activeInstallTaskKey && activeInstallTaskKey !== STORE_DOWNLOAD_KEY);
            window.owsUpdater.getAppVersion?.().then(v => {
                currentStoreWindowsVersion = String(v || '').trim();
                const el = document.getElementById('app-version');
                if (el) el.textContent = 'v' + v;
                const updatesVersion = document.getElementById('updates-app-version');
                if (updatesVersion) updatesVersion.textContent = 'v' + v;
            }).catch(() => {});
            const banner = document.getElementById('update-banner');
            const btn = document.getElementById('btn-install-update');
            const wrap = document.getElementById('update-progress-wrap');
            const fill = document.getElementById('update-progress-fill');
            const closeBtn = document.getElementById('btn-close-update-banner');
            const status = document.getElementById('updates-status');
            if (fill) fill.style.width = '0%';
            if (wrap) wrap.style.display = 'none';
            if (btn) btn.style.display = 'none';
            if (closeBtn) {
                closeBtn.disabled = true;
                closeBtn.style.opacity = '0.45';
                closeBtn.style.cursor = 'not-allowed';
            }
            setUpdateBannerVisual({
                state: 'checking',
                title: 'Buscando updates',
                message: 'Comprobando nuevas versiones de OWS Store...',
                iconClass: 'fa-magnifying-glass',
                iconSpin: true,
                meta: 'Tamano: - | ETA: -'
            });
            updateDownloadSession(STORE_DOWNLOAD_KEY, {
                name: 'OWS Store',
                icon: STORE_LOCAL_ICON,
                isApp: true,
                phase: 'checking',
                percent: 0,
                status: 'Verificando disponibilidad de update...',
                sizeBytes: 0,
                downloadedBytes: 0,
                speedBps: 0,
                etaSeconds: null,
            });
            if (banner) banner.classList.add('visible');
            if (status) status.textContent = 'Buscando actualizaciones...';
            setUpdateMetaUI({ sizeBytes: 0, etaSeconds: null, transferredBytes: null, speedBps: 0 });
            if (!lastStoreUpdaterCheckSilent) addNotification('Buscando actualizaciones de OWS Store...', 'neutral');
            window.owsUpdater.onUpdateAvailable?.((info) => {
                const banner = document.getElementById('update-banner');
                const msg = document.getElementById('update-msg');
                const btn = document.getElementById('btn-install-update');
                const dot = document.getElementById('update-indicator-dot');
                const closeBtn = document.getElementById('btn-close-update-banner');
                setStoreObsoleteGateBlocked({
                    platform: 'windows',
                    currentVersion: currentStoreWindowsVersion,
                    requiredVersion: String(info?.version || '').trim(),
                    reason: 'store-outdated',
                    source: 'windows-updater-event',
                });
                owsStoreWindowsManualUpdateUrl = '';
                owsStoreWindowsManualVersion = '';
                appUpdateSizeBytes = extractUpdateSizeBytes(info);
                appUpdateEtaSeconds = null;
                if (!isExternalInstallActive()) {
                    if (msg) msg.textContent = 'Version ' + (info?.version || 'nueva') + ' disponible. Descargando...';
                    if (banner) banner.classList.add('visible');
                    if (btn) btn.style.display = 'none';
                    if (closeBtn) {
                        closeBtn.disabled = true;
                        closeBtn.style.opacity = '0.45';
                        closeBtn.style.cursor = 'not-allowed';
                    }
                }
                if (dot) dot.style.display = 'block';
                appUpdateAvailable = true;
                syncUpdatesBadge();
                if (status) status.textContent = 'Descargando update v' + (info?.version || 'nueva');
                if (!isExternalInstallActive()) {
                    setUpdateBannerVisual({
                        state: 'available',
                        title: 'Actualizacion disponible',
                        message: 'Version ' + (info?.version || 'nueva') + ' detectada. Iniciando descarga...',
                        iconClass: 'fa-arrow-up',
                        iconSpin: false,
                    });
                }
                setUpdateMetaUI({ sizeBytes: appUpdateSizeBytes, etaSeconds: null, transferredBytes: 0, speedBps: 0 });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    phase: 'available',
                    percent: 0,
                    sizeBytes: appUpdateSizeBytes,
                    downloadedBytes: 0,
                    speedBps: 0,
                    etaSeconds: null,
                    status: 'Update detectada: v' + (info?.version || 'nueva'),
                });
                const sizeLabel = formatByteSize(appUpdateSizeBytes);
                addNotification('Actualizacion encontrada: v' + (info?.version || 'nueva') + (sizeLabel !== '-' ? ` (${sizeLabel})` : '') + '.', 'success');
            });
            window.owsUpdater.onDownloadProgress?.((p) => {
                const wrap = document.getElementById('update-progress-wrap');
                const fill = document.getElementById('update-progress-fill');
                const totalBytes = Number(p?.total || 0);
                const transferredBytes = Number(p?.transferred || 0);
                const speedBps = Number(p?.bytesPerSecond || 0);
                if (totalBytes > 0) appUpdateSizeBytes = totalBytes;
                const remainingBytes = appUpdateSizeBytes > 0 ? Math.max(appUpdateSizeBytes - transferredBytes, 0) : 0;
                appUpdateEtaSeconds = speedBps > 0 && remainingBytes > 0 ? (remainingBytes / speedBps) : null;
                if (!isExternalInstallActive()) {
                    if (wrap) wrap.style.display = 'block';
                    if (fill) fill.style.width = (p?.percent || 0) + '%';
                    setUpdateBannerVisual({
                        state: 'downloading',
                        title: 'Descargando update',
                        message: 'Progreso: ' + Math.round(p?.percent || 0) + '%',
                        iconClass: 'fa-download',
                        iconSpin: true,
                    });
                }
                if (status) status.textContent = 'Descargando update: '
                    + Math.round(p?.percent || 0) + '%'
                    + (appUpdateSizeBytes > 0 ? ` (${formatByteSize(transferredBytes)} / ${formatByteSize(appUpdateSizeBytes)})` : '')
                    + (appUpdateEtaSeconds !== null ? ` - ETA ${formatEta(appUpdateEtaSeconds)}` : '');
                setUpdateMetaUI({
                    sizeBytes: appUpdateSizeBytes,
                    etaSeconds: appUpdateEtaSeconds,
                    transferredBytes,
                    speedBps
                });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    phase: 'downloading',
                    percent: Number(p?.percent || 0),
                    sizeBytes: appUpdateSizeBytes,
                    downloadedBytes: transferredBytes,
                    speedBps,
                    etaSeconds: appUpdateEtaSeconds,
                    status: 'Descargando update de OWS Store...',
                });
            });
            window.owsUpdater.onUpdateDownloaded?.(() => {
                const msg = document.getElementById('update-msg');
                const btn = document.getElementById('btn-install-update');
                const wrap = document.getElementById('update-progress-wrap');
                const closeBtn = document.getElementById('btn-close-update-banner');
                owsStoreWindowsManualUpdateUrl = '';
                owsStoreWindowsManualVersion = '';
                if (!isExternalInstallActive()) {
                    if (msg) msg.textContent = 'Descarga completa. Reinicia para instalar.';
                    if (wrap) wrap.style.display = 'none';
                    if (btn) btn.style.display = 'flex';
                    if (closeBtn) {
                        closeBtn.disabled = false;
                        closeBtn.style.opacity = '1';
                        closeBtn.style.cursor = 'pointer';
                    }
                    setUpdateBannerVisual({
                        state: 'ready',
                        title: 'Update lista para instalar',
                        message: 'Descarga completa. Reinicia para aplicar la nueva version.',
                        iconClass: 'fa-circle-check',
                        iconSpin: false,
                    });
                }
                if (status) status.textContent = 'Lista para instalar';
                setUpdateMetaUI({
                    sizeBytes: appUpdateSizeBytes,
                    etaSeconds: 0,
                    transferredBytes: appUpdateSizeBytes > 0 ? appUpdateSizeBytes : null,
                    speedBps: 0
                });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    phase: 'ready',
                    percent: 100,
                    sizeBytes: appUpdateSizeBytes,
                    downloadedBytes: appUpdateSizeBytes,
                    speedBps: 0,
                    etaSeconds: 0,
                    status: 'Descarga completa. Reinicia para instalar.',
                });
                addNotification('Actualizacion descargada, lista para instalar.', 'success');
            });
            window.owsUpdater.onUpdateNotAvailable?.(async () => {
                const autoCheck = lastStoreUpdaterCheckSilent || lastStoreUpdaterCheckOrigin === 'auto';
                const currentVersion = String(await window.owsUpdater.getAppVersion?.().catch(() => '') || '').trim();
                if (currentVersion) currentStoreWindowsVersion = currentVersion;
                const manual = await applyWindowsManualUpdateSignal(currentStoreWindowsVersion, { silent: true }).catch(() => ({ needsUpdate: false }));
                if (manual?.needsUpdate) return;
                clearStoreObsoleteGate({ platform: 'windows', source: 'windows-updater-event', reason: 'up-to-date' });
                const banner = document.getElementById('update-banner');
                const msg = document.getElementById('update-msg');
                const dot = document.getElementById('update-indicator-dot');
                const closeBtn = document.getElementById('btn-close-update-banner');
                appUpdateSizeBytes = 0;
                appUpdateEtaSeconds = null;
                if (!isExternalInstallActive() && msg) msg.textContent = 'No hay actualizaciones disponibles.';
                if (dot) dot.style.display = 'none';
                appUpdateAvailable = false;
                syncUpdatesBadge();
                if (status) status.textContent = 'Sin actualizaciones pendientes';
                if (!isExternalInstallActive()) {
                    setUpdateBannerVisual({
                        state: 'success',
                        title: autoCheck ? 'Verificacion automatica completada' : 'OWS Store actualizada',
                        message: autoCheck
                            ? 'Sin novedades de update en esta verificacion.'
                            : 'No hay actualizaciones pendientes en este momento.',
                        iconClass: 'fa-circle-check',
                        iconSpin: false,
                    });
                    if (closeBtn) {
                        closeBtn.disabled = false;
                        closeBtn.style.opacity = '1';
                        closeBtn.style.cursor = 'pointer';
                    }
                }
                setUpdateMetaUI({ sizeBytes: 0, etaSeconds: null, transferredBytes: null, speedBps: 0 });
                removeDownloadSession(STORE_DOWNLOAD_KEY);
                if (!lastStoreUpdaterCheckSilent) addNotification('No hay actualizaciones pendientes.', 'neutral');
                if (!isExternalInstallActive()) {
                    setTimeout(() => {
                        if (banner && !actionBannerSticky) dismissUpdateBanner(true);
                    }, 5000);
                }
            });
            window.owsUpdater.onUpdateError?.(async (err) => {
                const banner = document.getElementById('update-banner');
                const msg = document.getElementById('update-msg');
                const closeBtn = document.getElementById('btn-close-update-banner');
                appUpdateEtaSeconds = null;
                if (!isExternalInstallActive()) {
                    if (msg) msg.textContent = 'Error buscando actualizaciones: ' + (err || 'desconocido');
                    if (banner) banner.classList.add('visible');
                }
                appUpdateAvailable = false;
                syncUpdatesBadge();
                if (status) status.textContent = 'Error de verificacion';
                if (!isExternalInstallActive()) {
                    setUpdateBannerVisual({
                        state: 'error',
                        title: 'Error de actualizacion',
                        message: 'No se pudo completar la verificacion de updates: ' + (err || 'desconocido'),
                        iconClass: 'fa-triangle-exclamation',
                        iconSpin: false,
                    });
                    if (closeBtn) {
                        closeBtn.disabled = false;
                        closeBtn.style.opacity = '1';
                        closeBtn.style.cursor = 'pointer';
                    }
                }
                setUpdateMetaUI({ sizeBytes: appUpdateSizeBytes, etaSeconds: null, transferredBytes: null, speedBps: 0 });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    phase: 'error',
                    percent: 0,
                    status: 'Error en update de OWS Store: ' + (err || 'desconocido'),
                });
                addNotification('Error de actualizacion: ' + (err || 'desconocido'), 'error');
                const currentVersion = String(await window.owsUpdater.getAppVersion?.().catch(() => '') || '').trim();
                if (currentVersion) currentStoreWindowsVersion = currentVersion;
                await applyWindowsManualUpdateSignal(currentStoreWindowsVersion, { silent: true }).catch(() => {});
            });
            window.owsUpdater.onExternalInstallStatus?.((payload) => {
                const projectStatus = document.getElementById('updates-project-status');
                if (!payload?.message) return;
                const payloadTaskId = String(payload?.taskId || '');
                const slug = payloadTaskId.startsWith('install_') ? payloadTaskId.replace(/^install_/, '') : '';
                const uiKey = slug ? `project_${slug}` : '';
                const shouldPaintProgress = shouldRefreshExternalProgressUi(uiKey, payload);
                if (projectStatus && payload?.message && (payload.phase !== 'downloading' || shouldPaintProgress)) {
                    projectStatus.textContent = payload.message;
                }
                if (slug) {
                    const project = getProjectBySlug(slug);
                    const key = `project_${slug}`;
                    const downloadedBytes = Number(payload?.downloadedBytes || 0);
                    const totalBytes = Number(payload?.totalBytes || 0);
                    const speedBps = Number(payload?.bytesPerSecond || 0);
                    const etaSeconds = speedBps > 0 && totalBytes > downloadedBytes
                        ? (totalBytes - downloadedBytes) / speedBps
                        : null;
                    if (payload.phase === 'downloading') {
                        if (!shouldPaintProgress) return;
                        setRuntimeState(slug, { phase: 'downloading', percent: Number(payload.percent || 0), taskId: payloadTaskId });
                        const wrap = document.getElementById('update-progress-wrap');
                        const fill = document.getElementById('update-progress-fill');
                        if (wrap) wrap.style.display = 'block';
                        if (fill) fill.style.width = `${Math.round(Number(payload.percent || 0))}%`;
                        setUpdateMetaUI({
                            sizeBytes: totalBytes,
                            etaSeconds,
                            transferredBytes: downloadedBytes,
                            speedBps
                        });
                        setUpdateBannerVisual({
                            state: 'downloading',
                            title: project ? project.name : 'Descargando proyecto',
                            message: payload.message,
                            iconClass: 'fa-download',
                            iconSpin: true,
                        });
                        updateDownloadSession(key, {
                            name: project?.name || slug,
                            slug,
                            icon: project ? getProjectIcon(project, 64) : STORE_LOCAL_ICON,
                            phase: 'downloading',
                            percent: Number(payload.percent || 0),
                            sizeBytes: totalBytes,
                            downloadedBytes,
                            speedBps,
                            etaSeconds,
                            status: payload.message,
                        });
                    } else if (payload.phase === 'launching') {
                        setRuntimeState(slug, { phase: 'launching', percent: 100, taskId: payloadTaskId });
                        const fill = document.getElementById('update-progress-fill');
                        if (fill) fill.style.width = '100%';
                        updateDownloadSession(key, {
                            name: project?.name || slug,
                            slug,
                            icon: project ? getProjectIcon(project, 64) : STORE_LOCAL_ICON,
                            phase: 'launching',
                            percent: 100,
                            status: payload.message || 'Abriendo instalador...',
                        });
                    } else if (payload.phase === 'done') {
                        setRuntimeState(slug, { phase: 'installed', percent: 100, taskId: '' });
                        const wrap = document.getElementById('update-progress-wrap');
                        if (wrap) wrap.style.display = 'none';
                        updateDownloadSession(key, {
                            name: project?.name || slug,
                            slug,
                            icon: project ? getProjectIcon(project, 64) : STORE_LOCAL_ICON,
                            phase: 'done',
                            percent: 100,
                            status: payload.message || 'Instalador abierto.',
                            etaSeconds: 0,
                        });
                    } else if (payload.phase === 'cancelled' || payload.phase === 'error') {
                        setRuntimeState(slug, { phase: 'idle', percent: 0, taskId: '' });
                        const wrap = document.getElementById('update-progress-wrap');
                        if (wrap) wrap.style.display = 'none';
                        updateDownloadSession(key, {
                            name: project?.name || slug,
                            slug,
                            icon: project ? getProjectIcon(project, 64) : STORE_LOCAL_ICON,
                            phase: payload.phase,
                            percent: 0,
                            status: payload.message || (payload.phase === 'error' ? 'Error de instalacion.' : 'Instalacion cancelada.'),
                        });
                        activeInstallTaskKey = '';
                        processProjectInstallQueue();
                    }
                    // Avoid full card re-render while progress is streaming; patch UI in place instead.
                    if (payload.phase === 'downloading') {
                        patchInstallProgressUI(slug);
                    } else {
                        scheduleSectionRender({
                            projects: true,
                            library: true,
                            immediate: true
                        });
                    }
                }
                if (payload.phase === 'downloading') {
                    if (!shouldPaintProgress) return;
                    showActionMessage(payload.message, { sticky: true, state: 'downloading', showProgress: true });
                    return;
                }
                const key = `${payload.phase}:${payload.message}`;
                if (key !== lastExternalStatusNotification) {
                    addNotification(payload.message, payload?.phase === 'error' ? 'error' : 'neutral');
                    lastExternalStatusNotification = key;
                }
                showActionMessage(payload.message);
            });
            requestWindowsUpdaterCheck({ silent: true, origin: 'auto' }).catch(() => {});
        }
        function installUpdate() {
            if (isNativeAndroidRuntime()) {
                openStoreAndroidDownload();
                return;
            }
            if (owsStoreWindowsManualUpdateUrl) {
                openExternal(owsStoreWindowsManualUpdateUrl);
                showActionMessage('Abriendo descarga manual de update para OWS Store...', { state: 'ready' });
                addNotification('Descargando update manual de OWS Store...', 'neutral');
                return;
            }
            if (window.owsUpdater?.installUpdate) window.owsUpdater.installUpdate();
        }

        async function openStoreAndroidDownload() {
            const url = selectAndroidDownloadUrl(
                owsStoreAndroidState.downloadUrl || OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL,
                owsStoreAndroidState.directDownloadUrl || ''
            ) || OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL;
            if (isNativeAndroidRuntime()) {
                if (!confirmAndroidInstallIntent('OWS Store Android')) return;
                if (shouldUseAndroidExternalInstallCompat()) {
                    const sessionKey = 'app_ows_store_android_manual';
                    updateDownloadSession(sessionKey, {
                        name: 'OWS Store Android',
                        slug: 'ows-store-android',
                        icon: STORE_LOCAL_ICON,
                        phase: 'launching',
                        percent: 100,
                        status: 'Abriendo descarga externa del APK (modo compatibilidad)...',
                        sizeBytes: Number(owsStoreAndroidState.sizeBytes || 0),
                        isApp: true,
                    });
                    openExternal(url);
                    updateDownloadSession(sessionKey, {
                        phase: 'ready',
                        percent: 100,
                        status: 'APK enviado a descarga externa. Instala y vuelve a abrir OWS Store.',
                        sizeBytes: Number(owsStoreAndroidState.sizeBytes || 0),
                        isApp: true,
                    });
                    addNotification('OWS Store Android: modo compatibilidad activo (descarga externa).', 'success');
                    showActionMessage('APK enviado a descarga externa. Instala y vuelve a abrir OWS Store.', { state: 'ready' });
                    return;
                }
                const gate = await ensureAndroidUnknownSourcesReady('OWS Store Android', { forcePrompt: true });
                if (!gate?.ok) return;
                const sessionKey = 'app_ows_store_android_manual';
                updateDownloadSession(sessionKey, {
                    name: 'OWS Store Android',
                    slug: 'ows-store-android',
                    icon: STORE_LOCAL_ICON,
                    phase: 'preparing',
                    percent: 0,
                    status: 'Preparando instalador Android...',
                    sizeBytes: Number(owsStoreAndroidState.sizeBytes || 0),
                    isApp: true,
                });
                showActionMessage('Preparando instalador Android de OWS Store...', {
                    sticky: true,
                    state: 'checking',
                    title: 'OWS Store Android',
                    showProgress: true,
                });
                const result = await installAndroidApkInApp({
                    url,
                    fileName: `OWS-Store-Android-${owsStoreAndroidState.version || 'latest'}.apk`,
                    taskId: 'install_ows_store_android',
                    sessionKey,
                    slug: '',
                    projectName: 'OWS Store Android',
                    expectedSize: Number(owsStoreAndroidState.sizeBytes || 0),
                    expectedSha256: String(owsStoreAndroidState.sha256 || ''),
                    sessionIsApp: true,
                });
                if (!result?.ok) {
                    if (result?.code === 'unknown_sources_not_confirmed') {
                        const waitMsg = 'Instalacion pausada. Habilita "Instalar apps desconocidas" para OWS Store y reintenta.';
                        updateDownloadSession(sessionKey, {
                            phase: 'ready',
                            status: waitMsg,
                        });
                        addNotification(waitMsg, 'warning');
                        showActionMessage(waitMsg, { state: 'info' });
                        return;
                    }
                    const errorDetail = formatInstallErrorDetail(result, 'desconocido');
                    updateDownloadSession(sessionKey, {
                        phase: 'error',
                        status: 'Error instalando APK Android: ' + errorDetail,
                    });
                    addNotification('Error instalando APK de OWS Store Android: ' + errorDetail, 'error');
                    showActionMessage('Error instalando APK de OWS Store Android: ' + errorDetail, { state: 'error' });
                    return;
                }
                updateDownloadSession(sessionKey, {
                    phase: 'ready',
                    percent: 100,
                    status: 'Instalador Android abierto. Instala la update y vuelve a abrir OWS Store para confirmar version.',
                    etaSeconds: 0,
                });
                addNotification('Instalador Android abierto. La update se confirma al reabrir OWS Store.', 'success');
                showActionMessage('Instalador Android abierto. Instala y reabre OWS Store.', { state: 'ready' });
                return;
            }
            openExternal(url);
        }

        function initSearch() {
            const input = document.getElementById('search-input');
            if (!input) return;
            input.addEventListener('input', () => {
                currentSearchTerm = input.value || '';
                renderVisibleProjects();
            });
        }

        window.onload = () => {
            libraryOwnedSlugs = loadLibraryOwnedSlugs();
            initTheme();
            renderOWSStoreAndroidMeta();
            initOceanPayStore();
            renderDownloadSurfaces();
            loadProjects();
            initBrandCycle();
            initSpotlightSlider();
            initUpdater();
            refreshStoreAndroidReleaseLink().catch(() => {
                renderOWSStoreAndroidMeta();
            });
            initSearch();
            setInterval(() => {
                if (document.hidden) return;
                checkProjectUpdatesAndNotify().then(() => {
                    scheduleSectionRender({ projects: true, library: true, immediate: false });
                }).catch(() => {});
                fetchOWSNewsUpdates(false).then(() => {
                    if (activeSection === 'home') renderNewsHub();
                }).catch(() => {});
                refreshStoreAndroidReleaseLink().catch(() => {});
                if (isNativeAndroidRuntime() && typeof window.owsUpdater === 'undefined') {
                    checkOWSStoreAndroidUpdate({ silent: true, origin: 'auto' }).catch(() => {});
                } else if (window.owsUpdater?.checkForUpdates) {
                    requestWindowsUpdaterCheck({ silent: true, origin: 'auto' }).catch(() => {});
                }
            }, 120000);
        };

        window.onbeforeunload = () => {
            if (brandCycleTimer) clearInterval(brandCycleTimer);
            if (spotlightSlideTimer) clearInterval(spotlightSlideTimer);
            if (spotlightSlideCleanupTimer) clearTimeout(spotlightSlideCleanupTimer);
        };
    </script>
</body>

</html>





