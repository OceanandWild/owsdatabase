<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdnjs.cloudflare.com; font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com; img-src 'self' data: https: blob:; connect-src 'self' https://owsdatabase.onrender.com https://images.unsplash.com https://ui-avatars.com https://placehold.co https://api.github.com; frame-src https:;">
    <title>OWS Store - Central Studio Hub</title>
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;600;700;800&family=Space+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg: #f4efe6;
            --paper: #fffaf2;
            --surface: #ffffff;
            --ink: #1f1f24;
            --ink-soft: #595a66;
            --line: #d8ccbc;
            --brand: #d14f2a;
            --brand-2: #007f84;
            --text-dim: #595a66;
            --glass: rgba(255, 255, 255, 0.66);
            --glass-border: #d8ccbc;
            --accent-primary: #007f84;
            --accent-secondary: #d14f2a;
            --ok: #1f9d63;
            --warn: #b96700;
            --shadow: 0 16px 38px rgba(35, 27, 21, 0.12);
        }

        body[data-theme="dark"] {
            --bg: #0d1117;
            --paper: #0f1723;
            --surface: #121b2a;
            --ink: #ecf3ff;
            --ink-soft: #97a8c2;
            --line: #233347;
            --brand: #f26e3f;
            --brand-2: #11b6bd;
            --text-dim: #8fa4bf;
            --glass: rgba(20, 30, 45, 0.72);
            --glass-border: #2d4057;
            --accent-primary: #11b6bd;
            --accent-secondary: #f26e3f;
            --ok: #34d399;
            --warn: #f59e0b;
            --shadow: 0 18px 38px rgba(0, 0, 0, 0.34);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Sora', sans-serif;
        }

        body {
            background: radial-gradient(1300px 600px at -10% -20%, #f9d9b1 0%, transparent 45%),
                        radial-gradient(900px 500px at 110% 10%, #bfe8e8 0%, transparent 45%),
                        var(--bg);
            color: var(--ink);
            overflow-x: hidden;
            min-height: 100vh;
        }

        body[data-theme="dark"] {
            background: radial-gradient(1300px 700px at -15% -25%, rgba(39, 93, 130, 0.35) 0%, transparent 50%),
                        radial-gradient(1000px 600px at 120% 8%, rgba(72, 39, 104, 0.35) 0%, transparent 55%),
                        var(--bg);
        }

        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: 100vh;
            gap: 0;
        }

        .sidebar {
            background: linear-gradient(180deg, #fffaf2 0%, #f7eee0 100%);
            border-right: 1px solid var(--line);
            padding: 2rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
        }

        body[data-theme="dark"] .sidebar {
            background: linear-gradient(180deg, #0f1723 0%, #0d1522 100%);
        }

        body[data-theme="dark"] .search-bar,
        body[data-theme="dark"] .app-card,
        body[data-theme="dark"] .stat-box,
        body[data-theme="dark"] .download-item,
        body[data-theme="dark"] .explore-controls,
        body[data-theme="dark"] .download-dock,
        body[data-theme="dark"] .modal-actions {
            background: linear-gradient(180deg, #121b2a 0%, #101827 100%);
            border-color: var(--line);
        }

        body[data-theme="dark"] .update-banner {
            background: rgba(13, 20, 32, 0.95);
            border-color: #2e4360;
            box-shadow: 0 14px 35px rgba(0, 0, 0, 0.45);
        }

        body[data-theme="dark"] .download-item-phase {
            background: rgba(17, 182, 189, 0.15);
            color: #8de8ee;
        }

        .sidebar::after {
            content: '';
            position: absolute;
            inset: auto 14px 14px 14px;
            height: 120px;
            border-radius: 18px;
            background: linear-gradient(135deg, rgba(0, 127, 132, 0.08), rgba(209, 79, 42, 0.12));
            pointer-events: none;
        }

        body[data-theme="dark"] .sidebar::after {
            background: linear-gradient(135deg, rgba(17, 182, 189, 0.12), rgba(242, 110, 63, 0.12));
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--ink);
            letter-spacing: -1px;
            display: flex;
            align-items: center;
            gap: 0.7rem;
            min-height: 40px;
        }

        .logo i {
            color: var(--brand);
            min-width: 22px;
            text-align: center;
            transition: color 0.22s ease, transform 0.22s ease;
        }

        .brand-copy {
            display: inline-flex;
            align-items: baseline;
            gap: 0.35rem;
            line-height: 1;
        }

        .brand-prefix {
            color: var(--ink);
            opacity: 0.92;
        }

        .brand-word {
            color: var(--brand);
            letter-spacing: 0.35px;
            min-width: 92px;
            display: inline-block;
            transition: color 0.22s ease, transform 0.22s ease, opacity 0.22s ease;
        }

        .logo.swap i,
        .logo.swap .brand-word {
            transform: translateY(-2px) scale(1.03);
            opacity: 0.88;
        }

        .logo-caption {
            margin-top: -0.6rem;
            margin-bottom: 0.1rem;
            font-size: 0.72rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
            letter-spacing: 0.2px;
            min-height: 16px;
        }

        .nav-menu {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 2;
        }

        .theme-toggle-row {
            margin-top: 0.2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.8rem;
            padding: 0.6rem 0.2rem;
            z-index: 2;
        }

        .theme-toggle-label {
            font-size: 0.72rem;
            font-weight: 800;
            color: var(--ink-soft);
            letter-spacing: 0.4px;
            text-transform: uppercase;
        }

        .theme-switch {
            width: 54px;
            height: 30px;
            border-radius: 999px;
            border: 1px solid var(--line);
            background: #fff;
            position: relative;
            cursor: pointer;
            transition: all 0.22s ease;
        }

        .theme-switch::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffb35c, #f26e3f);
            transition: transform 0.22s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.16);
        }

        .theme-switch.dark {
            background: linear-gradient(90deg, #15263d, #1d334f);
            border-color: #2d4767;
        }

        .theme-switch.dark::before {
            transform: translateX(24px);
            background: linear-gradient(135deg, #11b6bd, #4f46e5);
        }

        .connection-card {
            margin-top: auto;
            padding: 1rem;
            background: var(--glass);
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            gap: 0.42rem;
        }

        .connection-caption {
            font-size: 0.7rem;
            color: var(--text-dim);
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-weight: 700;
        }

        .connection-title {
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 0.45rem;
        }

        .connection-title i {
            color: var(--accent-primary);
        }

        .connection-placeholder-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.32rem;
            width: fit-content;
            border-radius: 999px;
            border: 1px dashed rgba(17, 182, 189, 0.55);
            color: var(--accent-primary);
            background: rgba(17, 182, 189, 0.08);
            padding: 0.22rem 0.56rem;
            font-size: 0.65rem;
            font-weight: 800;
            letter-spacing: 0.35px;
            text-transform: uppercase;
        }

        .connection-placeholder-note {
            font-size: 0.74rem;
            color: var(--ink-soft);
            line-height: 1.45;
        }

        .op-mini-form {
            display: flex;
            flex-direction: column;
            gap: 0.42rem;
            margin-top: 0.25rem;
        }

        .op-mini-input {
            width: 100%;
            border: 1px solid var(--line);
            border-radius: 10px;
            background: var(--surface);
            color: var(--ink);
            padding: 0.42rem 0.55rem;
            font-size: 0.76rem;
            outline: none;
        }

        .op-mini-input:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(17, 182, 189, 0.15);
        }

        .op-mini-actions {
            display: flex;
            gap: 0.35rem;
            flex-wrap: wrap;
            margin-top: 0.12rem;
        }

        .op-mini-btn {
            border: 1px solid var(--line);
            border-radius: 9px;
            background: var(--surface);
            color: var(--ink);
            padding: 0.34rem 0.55rem;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
        }

        .op-mini-btn.primary {
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            border-color: transparent;
            color: #fff;
        }

        .op-mini-btn.warn {
            border-color: rgba(210, 80, 60, 0.45);
            color: #cf5a43;
        }

        .op-mini-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .op-mini-status {
            font-size: 0.69rem;
            color: var(--ink-soft);
            line-height: 1.38;
        }

        .op-mini-user {
            font-size: 0.74rem;
            font-weight: 800;
            color: var(--ink);
            display: none;
        }

        .op-mini-balance {
            font-size: 0.72rem;
            color: var(--ink-soft);
            display: none;
        }

        .op-mini-currencies {
            display: none;
            margin-top: 0.28rem;
            grid-template-columns: 1fr 1fr;
            gap: 0.3rem;
            max-height: 148px;
            overflow-y: auto;
            padding-right: 0.1rem;
        }

        .op-mini-currency-chip {
            border: 1px solid var(--line);
            border-radius: 8px;
            background: var(--surface);
            padding: 0.28rem 0.38rem;
            min-width: 0;
        }

        .op-mini-currency-chip .label {
            display: block;
            font-size: 0.62rem;
            color: var(--ink-soft);
            line-height: 1.15;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .op-mini-currency-chip .value {
            display: block;
            margin-top: 0.08rem;
            font-size: 0.69rem;
            color: var(--ink);
            font-weight: 800;
            font-family: 'Space Mono', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .op-mini-currencies-more {
            grid-column: 1 / -1;
            font-size: 0.62rem;
            color: var(--ink-soft);
            text-align: right;
            padding-right: 0.05rem;
        }

        .download-dock {
            margin-top: 0.5rem;
            border: 1px solid var(--line);
            border-radius: 14px;
            background: linear-gradient(180deg, #fff 0%, #f7efe3 100%);
            padding: 0.65rem;
            display: none;
            flex-direction: column;
            gap: 0.55rem;
            position: relative;
            z-index: 2;
        }

        .download-dock.visible {
            display: flex;
            animation: dockSlideIn 0.22s ease;
        }

        .download-dock-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.68rem;
            color: var(--ink-soft);
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-weight: 800;
        }

        .download-dock-count {
            background: var(--brand-2);
            color: #fff;
            border-radius: 999px;
            padding: 0.08rem 0.44rem;
            font-size: 0.65rem;
            font-family: 'Space Mono', monospace;
        }

        .download-dock-body {
            display: flex;
            gap: 0.55rem;
            align-items: center;
        }

        .download-dock-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            object-fit: cover;
            border: 1px solid #dfd2c2;
            background: #fff;
            flex-shrink: 0;
        }

        .download-dock-info {
            min-width: 0;
            flex: 1;
        }

        .download-dock-title {
            font-size: 0.77rem;
            font-weight: 800;
            color: var(--ink);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-dock-status {
            margin-top: 0.08rem;
            font-size: 0.67rem;
            color: var(--ink-soft);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-dock-progress {
            margin-top: 0.3rem;
            height: 5px;
            background: #e9ddcf;
            border-radius: 99px;
            overflow: hidden;
        }

        .download-dock-progress-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            border-radius: 99px;
            transition: width 0.2s ease;
        }

        .download-dock-loader {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(0, 127, 132, 0.2);
            border-top-color: var(--brand-2);
            border-radius: 50%;
            animation: spinLoop 1s linear infinite;
            margin-left: auto;
            flex-shrink: 0;
            display: none;
        }

        .download-dock-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.3rem;
        }

        .download-dock-btn {
            width: 24px;
            height: 24px;
            border-radius: 8px;
            border: 1px solid #dccfbf;
            background: #fff;
            color: var(--ink-soft);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.68rem;
        }

        .download-dock-btn:hover {
            color: var(--ink);
            background: #f6efe3;
        }

        .download-dock-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .download-dock-index {
            font-size: 0.64rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
        }

        @keyframes dockSlideIn {
            from { opacity: 0; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .nav-item {
            padding: 0.9rem 1rem;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            color: var(--ink-soft);
            font-weight: 700;
            border: 1px solid transparent;
            background: transparent;
        }

        .nav-item i {
            font-size: 1.1rem;
        }

        .nav-item:hover,
        .nav-item.active {
            background: #fff;
            color: var(--ink);
            border-color: var(--line);
            transform: translateX(4px);
            box-shadow: 0 6px 18px rgba(25, 20, 15, 0.08);
        }

        .main-content {
            padding: 2rem 2.2rem 3rem;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            gap: 1rem;
        }

        .search-bar {
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: 16px;
            padding: 0.9rem 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            width: min(100%, 480px);
            box-shadow: var(--shadow);
        }

        .search-bar i {
            color: var(--brand-2);
        }

        .search-bar input {
            background: transparent;
            border: none;
            color: var(--ink);
            outline: none;
            width: 100%;
            font-weight: 600;
        }

        .featured-hero {
            width: 100%;
            height: 420px;
            border-radius: 28px;
            overflow: hidden;
            position: relative;
            margin-bottom: 2.3rem;
            background: #000;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.35);
        }

        .hero-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.85;
            transform: scale(1.03);
        }

        .hero-content {
            position: absolute;
            inset: auto 0 0 0;
            padding: 2.5rem;
            background: linear-gradient(180deg, transparent 0%, rgba(25, 20, 16, 0.82) 45%, rgba(25, 20, 16, 0.95) 100%);
            color: #f7f0e7;
        }

        .hero-tag {
            background: #ffd9c7;
            color: #7a2b10;
            padding: 0.35rem 0.7rem;
            border-radius: 999px;
            font-size: 0.72rem;
            font-weight: 800;
            text-transform: uppercase;
            margin-bottom: 0.9rem;
            display: inline-block;
            letter-spacing: 0.5px;
        }

        .hero-title {
            font-size: clamp(2rem, 5vw, 3.3rem);
            font-weight: 800;
            margin-bottom: 0.5rem;
            letter-spacing: -1.5px;
            line-height: 1.02;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 800;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            letter-spacing: -0.3px;
        }

        .explore-shell {
            display: flex;
            flex-direction: column;
            gap: 1.15rem;
            margin-bottom: 0.8rem;
        }

        .explore-spotlight {
            background:
                radial-gradient(600px 200px at 0% 0%, rgba(0, 127, 132, 0.2), transparent 55%),
                radial-gradient(600px 200px at 100% 100%, rgba(209, 79, 42, 0.22), transparent 55%),
                linear-gradient(145deg, #1f2026 0%, #2a2d39 50%, #18242b 100%);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #f2f5fa;
            padding: 1.3rem;
            display: grid;
            grid-template-columns: 1.4fr 1fr;
            gap: 1rem;
            box-shadow: 0 20px 42px rgba(18, 18, 24, 0.35);
        }

        .spotlight-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            background: rgba(255, 255, 255, 0.14);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 999px;
            padding: 0.25rem 0.65rem;
            font-size: 0.66rem;
            font-weight: 700;
            margin-bottom: 0.7rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .spotlight-title {
            font-size: clamp(1.7rem, 3.3vw, 2.5rem);
            font-weight: 800;
            line-height: 1.05;
            margin-bottom: 0.6rem;
            letter-spacing: -1px;
        }

        .spotlight-subtitle {
            color: rgba(242, 245, 250, 0.82);
            font-size: 0.94rem;
            line-height: 1.55;
            max-width: 620px;
            margin-bottom: 0.9rem;
        }

        .spotlight-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.55rem;
            margin-bottom: 0.95rem;
        }

        .btn-hero-secondary {
            border: 1px solid rgba(255, 255, 255, 0.28);
            background: rgba(255, 255, 255, 0.06);
            color: #f2f5fa;
        }

        .btn-hero-secondary:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .spotlight-metrics {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 0.55rem;
        }

        .spotlight-metric {
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.58rem 0.62rem;
        }

        .spotlight-metric-value {
            font-size: 1rem;
            font-weight: 800;
            color: #f9fbff;
            line-height: 1;
        }

        .spotlight-metric-label {
            margin-top: 0.25rem;
            font-size: 0.65rem;
            color: rgba(242, 245, 250, 0.72);
            text-transform: uppercase;
            letter-spacing: 0.45px;
        }

        .spotlight-side {
            display: flex;
            flex-direction: column;
            gap: 0.65rem;
        }

        .spotlight-panel {
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 14px;
            background: rgba(0, 0, 0, 0.24);
            padding: 0.72rem 0.75rem;
        }

        .spotlight-panel-title {
            font-size: 0.72rem;
            color: rgba(242, 245, 250, 0.72);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.45rem;
        }

        .spotlight-list {
            display: flex;
            flex-direction: column;
            gap: 0.42rem;
        }

        .spotlight-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.77rem;
            color: #eff2f8;
        }

        .spotlight-list-item span:last-child {
            color: rgba(242, 245, 250, 0.72);
            font-family: 'Space Mono', monospace;
            font-size: 0.66rem;
        }

        .explore-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 0.65rem;
            background: #fff8ee;
            border: 1px solid var(--line);
            border-radius: 16px;
            padding: 0.7rem 0.8rem;
        }

        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .filter-chip {
            border: 1px solid #d9ccbd;
            border-radius: 999px;
            padding: 0.32rem 0.72rem;
            background: #fff;
            color: var(--ink-soft);
            font-size: 0.72rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.18s ease;
        }

        .filter-chip:hover,
        .filter-chip.active {
            color: #fff;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            border-color: transparent;
        }

        .explore-note {
            font-size: 0.72rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
        }

        .project-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 3rem;
        }

        .ecosystem-list {
            display: flex;
            flex-direction: column;
            gap: 0.78rem;
            margin-bottom: 2.2rem;
        }

        .ecosystem-row {
            display: grid;
            grid-template-columns: 86px minmax(0, 1fr) auto;
            align-items: center;
            gap: 0.9rem;
            padding: 0.85rem 0.95rem;
            border-radius: 16px;
        }

        .ecosystem-row .app-icon {
            width: 74px;
            height: 74px;
            border-radius: 16px;
            margin-bottom: 0;
        }

        .ecosystem-main {
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .ecosystem-topline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.6rem;
        }

        .ecosystem-topline .app-name {
            margin-bottom: 0;
        }

        .ecosystem-platform {
            font-size: 0.65rem;
            border-radius: 999px;
            padding: 0.2rem 0.5rem;
            text-transform: uppercase;
            font-weight: 800;
            letter-spacing: 0.45px;
            background: rgba(0, 127, 132, 0.11);
            color: var(--accent-primary);
            border: 1px solid rgba(0, 127, 132, 0.26);
            white-space: nowrap;
        }

        .ecosystem-submeta {
            font-size: 0.72rem;
            color: var(--ink-soft);
            line-height: 1.35;
        }

        .ecosystem-open-btn {
            width: auto;
            min-width: 130px;
            padding: 0.66rem 0.95rem;
            border-radius: 11px;
            font-size: 0.82rem;
            white-space: nowrap;
        }

        .app-card {
            background: linear-gradient(180deg, #fff 0%, #fffaf5 100%);
            border: 1px solid var(--line);
            border-radius: 18px;
            padding: 1.1rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(35, 27, 21, 0.08);
            animation: cardIn 0.45s ease both;
        }

        .app-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .app-card:hover {
            transform: translateY(-6px);
            border-color: #c6b29b;
            box-shadow: 0 16px 34px rgba(35, 27, 21, 0.16);
        }

        .app-card:hover::before {
            opacity: 1;
        }

        .app-icon {
            width: 62px;
            height: 62px;
            border-radius: 14px;
            background: #f6efe7;
            margin-bottom: 0.9rem;
            object-fit: cover;
            border: 1px solid #e6d9ca;
        }

        .app-name {
            font-size: 1.14rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
            color: var(--ink);
        }

        .app-meta {
            color: var(--ink-soft);
            font-size: 0.82rem;
            margin-bottom: 0.4rem;
            display: flex;
            justify-content: space-between;
            font-family: 'Space Mono', monospace;
        }

        .btn-install {
            width: 100%;
            padding: 0.78rem;
            border-radius: 12px;
            border: 0;
            background: linear-gradient(90deg, var(--brand), #e57b22);
            color: #fff;
            font-weight: 800;
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.45rem;
        }

        .btn-install:hover {
            filter: brightness(1.04);
            transform: translateY(-1px);
        }

        .btn-install.unavailable {
            background: #ece3d7;
            color: #888;
            cursor: not-allowed;
        }

        body[data-theme="dark"] .btn-install.unavailable {
            background: #263243;
            color: #8ca0bc;
        }

        .btn-install.coming-soon {
            background: transparent;
            border: 1px solid var(--warn);
            color: var(--warn);
        }

        .library-actions {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.45rem;
        }

        .library-actions .full {
            grid-column: 1 / -1;
        }

        .library-actions .btn-install {
            min-width: 0;
            font-size: 0.93rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0.7rem 0.6rem;
        }

        .progress-overlay {
            position: absolute;
            inset: 0;
            background: rgba(247, 238, 228, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            z-index: 10;
            color: #473326;
            backdrop-filter: blur(2px);
        }

        body[data-theme="dark"] .progress-overlay {
            background: rgba(14, 23, 36, 0.92);
            color: #d9e6fb;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: #e9ddcf;
            border-radius: 4px;
            margin-top: 0.7rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            width: 0%;
            transition: width 0.25s;
        }

        #game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
            display: none;
            flex-direction: column;
            animation: appScaleIn 0.25s ease;
        }

        #game-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: #000;
        }

        .game-controls {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 10000;
            display: flex;
            gap: 8px;
            opacity: 0.9;
            transition: opacity 0.2s;
        }

        .game-controls:hover {
            opacity: 1;
        }

        .btn-close-game {
            background: rgba(33, 35, 42, 0.86);
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: #fff;
            padding: 0.6rem 0.9rem;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-close-game:hover {
            background: #c63f24;
        }

        @keyframes appScaleIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes cardIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .no-scroll {
            overflow: hidden !important;
        }

        #details-modal {
            position: fixed;
            top: 0;
            right: -100%;
            width: 470px;
            height: 100vh;
            background: linear-gradient(180deg, #fffaf2 0%, #f7eee0 100%);
            border-left: 1px solid var(--line);
            z-index: 5000;
            transition: right 0.35s ease;
            display: flex;
            flex-direction: column;
            box-shadow: -18px 0 40px rgba(30, 23, 18, 0.15);
        }

        #details-modal.active {
            right: 0;
        }

        .modal-banner {
            width: 100%;
            height: 210px;
            background-size: cover;
            background-position: center;
            position: relative;
        }

        .modal-banner::after {
            content: '';
            position: absolute;
            inset: auto 0 0;
            height: 72px;
            background: linear-gradient(180deg, transparent, #f7eee0);
        }

        .modal-header {
            padding: 0 1.6rem;
            margin-top: -44px;
            position: relative;
            z-index: 1;
            display: flex;
            align-items: flex-end;
            gap: 1rem;
            margin-bottom: 1.4rem;
        }

        .modal-icon-large {
            width: 118px;
            height: 118px;
            border-radius: 24px;
            background: #fff;
            border: 3px solid #f7eee0;
            box-shadow: 0 10px 25px rgba(30, 24, 18, 0.18);
            object-fit: cover;
        }

        .modal-title-area { padding-bottom: 16px; }
        .modal-title { font-size: 1.8rem; font-weight: 800; line-height: 1.02; }
        .modal-dev {
            color: var(--brand-2);
            font-size: 0.78rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 4px;
        }

        .modal-body {
            padding: 1.6rem;
            flex: 1;
            overflow-y: auto;
        }

        .modal-description {
            color: var(--ink-soft);
            line-height: 1.58;
            margin-bottom: 1.4rem;
            font-size: 0.93rem;
        }

        .modal-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }

        .modal-platforms {
            margin-bottom: 1.1rem;
        }

        .modal-platform-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.55rem;
            margin-top: 0.55rem;
        }

        .platform-pill {
            border: 1px solid var(--line);
            background: #fff;
            color: var(--ink);
            border-radius: 999px;
            padding: 0.42rem 0.78rem;
            font-size: 0.72rem;
            font-weight: 700;
            letter-spacing: 0.2px;
            cursor: pointer;
            transition: all 0.18s ease;
        }

        .platform-pill.active {
            background: linear-gradient(90deg, var(--brand-2), #2aa0a6);
            border-color: transparent;
            color: #fff;
            box-shadow: 0 6px 16px rgba(0, 127, 132, 0.26);
        }

        .platform-pill.is-disabled {
            opacity: 0.58;
        }

        .platform-pill:hover {
            transform: translateY(-1px);
        }

        .modal-platform-meta {
            margin-top: 0.55rem;
            color: var(--ink-soft);
            font-size: 0.8rem;
        }

        .stat-box {
            background: #fff;
            padding: 0.9rem;
            border-radius: 12px;
            border: 1px solid var(--line);
        }

        .stat-label {
            font-size: 0.68rem;
            color: var(--ink-soft);
            text-transform: uppercase;
            margin-bottom: 4px;
            letter-spacing: 0.6px;
        }

        .stat-value { font-weight: 700; font-size: 0.88rem; }

        .modal-actions {
            padding: 1.2rem 1.6rem 1.6rem;
            background: rgba(255, 250, 242, 0.92);
            border-top: 1px solid var(--line);
        }

        .btn-close-modal {
            position: absolute;
            top: 14px;
            right: 14px;
            background: rgba(0, 0, 0, 0.38);
            border: none;
            color: white;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
        }

        .update-banner {
            display: none;
            position: fixed;
            bottom: 18px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 4000;
            background: linear-gradient(180deg, #fffdf8 0%, #fff6eb 100%);
            border: 1px solid #d8ccbc;
            border-radius: 18px;
            padding: 0.85rem 0.95rem;
            box-shadow: 0 18px 36px rgba(35, 27, 21, 0.24);
            align-items: center;
            gap: 0.75rem;
            min-width: 360px;
            max-width: min(92vw, 820px);
        }

        .update-banner::before {
            content: '';
            position: absolute;
            inset: 0 auto 0 0;
            width: 5px;
            border-radius: 18px 0 0 18px;
            background: linear-gradient(180deg, #007f84, #d14f2a);
        }

        .update-banner.visible {
            display: flex;
            animation: bannerPop 0.24s ease;
        }

        .update-banner.state-checking::before { background: linear-gradient(180deg, #007f84, #4baeb2); }
        .update-banner.state-available::before { background: linear-gradient(180deg, #d14f2a, #f08b33); }
        .update-banner.state-downloading::before { background: linear-gradient(180deg, #007f84, #d14f2a); }
        .update-banner.state-ready::before { background: linear-gradient(180deg, #1f9d63, #53c18b); }
        .update-banner.state-success::before { background: linear-gradient(180deg, #1f9d63, #53c18b); }
        .update-banner.state-error::before { background: linear-gradient(180deg, #c0392b, #ea6b5d); }
        .update-banner.state-info::before { background: linear-gradient(180deg, #6f7280, #979aa8); }

        .update-banner .update-icon {
            width: 42px;
            height: 42px;
            background: linear-gradient(140deg, rgba(0, 127, 132, 0.15), rgba(209, 79, 42, 0.18));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            color: #2c3d43;
            border: 1px solid rgba(0, 0, 0, 0.06);
            flex-shrink: 0;
        }

        .update-banner .update-icon i.spin {
            animation: spinLoop 1s linear infinite;
        }

        .update-banner .update-text {
            flex: 1;
            min-width: 0;
        }

        .update-banner .update-text strong {
            display: block;
            margin-bottom: 0.12rem;
            font-size: 0.9rem;
            color: #1f1f24;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .update-banner .update-text span {
            color: #5f6270;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
        }

        .update-banner .update-meta {
            color: #666978;
            font-size: 0.7rem;
            margin-top: 0.2rem;
            font-family: 'Space Mono', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .update-banner .update-progress {
            width: 132px;
            height: 7px;
            background: #eadfce;
            border-radius: 99px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .update-banner .update-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            width: 0%;
            transition: width 0.2s;
            border-radius: 99px;
        }

        .update-banner .btn-update {
            padding: 0.55rem 0.95rem;
            border-radius: 10px;
            border: none;
            background: #23242a;
            color: #fff;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.35rem;
            transition: opacity 0.2s;
            white-space: nowrap;
        }

        .update-banner .btn-close-update {
            width: 32px;
            height: 32px;
            border-radius: 10px;
            border: 1px solid #d8ccbc;
            background: #fff;
            color: #5f6270;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.18s ease;
            flex-shrink: 0;
        }

        .update-banner .btn-close-update:hover {
            background: #f4ede3;
            color: #2a2b31;
        }

        .update-banner .btn-update:hover { opacity: 0.92; }
        .update-banner .btn-update:disabled { opacity: 0.6; cursor: not-allowed; }

        @keyframes bannerPop {
            from { opacity: 0; transform: translateX(-50%) translateY(8px) scale(0.985); }
            to { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
        }

        @keyframes spinLoop {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .update-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 9px;
            height: 9px;
            background: var(--brand);
            border-radius: 50%;
            box-shadow: 0 0 0 6px rgba(209, 79, 42, 0.12);
            animation: pulse-dot 1.8s infinite;
        }

        .downloads-activity {
            display: flex;
            flex-direction: column;
            gap: 0.72rem;
            margin-bottom: 1rem;
        }

        .info-note-card {
            background: #fff;
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 0.7rem 0.85rem;
            color: var(--ink-soft);
        }

        .project-update-card {
            background: #fff;
            border: 1px solid var(--line);
            border-left: 4px solid var(--brand-2);
            border-radius: 10px;
            padding: 0.7rem 0.85rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.6rem;
        }

        .project-update-title {
            font-weight: 800;
            color: var(--ink);
        }

        .project-update-meta {
            font-size: 0.8rem;
            color: var(--ink-soft);
        }

        .notification-card {
            --tone-color: var(--brand-2);
            background: #fff;
            border: 1px solid var(--line);
            border-left: 4px solid var(--tone-color);
            border-radius: 10px;
            padding: 0.7rem 0.85rem;
        }

        .notification-time {
            font-size: 0.82rem;
            color: var(--ink-soft);
        }

        .notification-text {
            font-weight: 700;
            margin-top: 0.15rem;
            color: var(--ink);
        }

        .android-release-meta {
            font-size: 0.75rem;
            color: var(--ink-soft);
            line-height: 1.35;
        }

        body[data-theme="dark"] .info-note-card,
        body[data-theme="dark"] .project-update-card,
        body[data-theme="dark"] .notification-card {
            background: linear-gradient(180deg, #121b2a 0%, #101827 100%);
            border-color: var(--line);
        }

        .download-item {
            border: 1px solid var(--line);
            border-radius: 14px;
            background: #fff;
            padding: 0.72rem;
            display: flex;
            align-items: center;
            gap: 0.72rem;
            box-shadow: 0 8px 20px rgba(35, 27, 21, 0.08);
            transition: transform 0.16s ease, border-color 0.16s ease;
        }

        .download-item:hover {
            transform: translateY(-2px);
            border-color: #c9b9a5;
        }

        .download-item .avatar {
            width: 42px;
            height: 42px;
            border-radius: 11px;
            object-fit: cover;
            border: 1px solid #dfd2c2;
            background: #fff;
            flex-shrink: 0;
        }

        .download-item-main {
            flex: 1;
            min-width: 0;
        }

        .download-item-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .download-item-title {
            font-size: 0.9rem;
            font-weight: 800;
            color: var(--ink);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-item-phase {
            font-size: 0.67rem;
            border-radius: 999px;
            padding: 0.18rem 0.52rem;
            background: #f2e5d7;
            color: #7f4c1f;
            text-transform: uppercase;
            font-weight: 800;
            letter-spacing: 0.4px;
            flex-shrink: 0;
        }

        .download-item-meta {
            font-size: 0.7rem;
            color: var(--ink-soft);
            font-family: 'Space Mono', monospace;
            margin-bottom: 0.34rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-item-progress-wrap {
            height: 6px;
            background: #eadfce;
            border-radius: 999px;
            overflow: hidden;
            opacity: 0;
            max-height: 0;
            transition: opacity 0.18s ease, max-height 0.22s ease;
        }

        .download-item-progress-wrap.show {
            opacity: 1;
            max-height: 8px;
        }

        .download-item-progress {
            width: 0%;
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--brand), var(--brand-2));
            transition: width 0.2s ease;
        }

        .download-item-loader {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(0, 127, 132, 0.22);
            border-top-color: var(--brand-2);
            animation: spinLoop 1s linear infinite;
            display: none;
            flex-shrink: 0;
        }

        .download-item.preparing .download-item-loader,
        .download-item.queued .download-item-loader,
        .download-item.waiting .download-item-loader {
            display: block;
        }

        .download-item.downloading .download-item-progress-wrap {
            opacity: 1;
            max-height: 8px;
        }

        .download-item.ready .download-item-phase,
        .download-item.done .download-item-phase {
            background: #d9f3e7;
            color: #1f7b52;
        }

        .download-item.error .download-item-phase {
            background: #f8ddd9;
            color: #a63a2e;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.45; transform: scale(1.2); }
        }

        @media (max-width: 1120px) {
            .app-container { grid-template-columns: 1fr; }
            .sidebar {
                border-right: none;
                border-bottom: 1px solid var(--line);
                padding: 1rem;
                gap: 0.8rem;
            }
            .sidebar::after { display: none; }
            .nav-menu { flex-direction: row; flex-wrap: wrap; }
            .nav-item { flex: 1 1 calc(33% - 0.5rem); justify-content: center; }
            .main-content { padding: 1.2rem; }
            .header { flex-direction: column; align-items: stretch; }
            .search-bar { width: 100%; }
            .featured-hero { height: 350px; }
            #details-modal { width: 100%; }
            .explore-spotlight { grid-template-columns: 1fr; }
        }

        @media (max-width: 720px) {
            .sidebar {
                padding: 0.75rem;
                gap: 0.6rem;
            }
            .logo {
                font-size: 1.25rem;
            }
            .brand-word {
                min-width: 72px;
            }
            .logo-caption {
                display: none;
            }
            .nav-menu {
                flex-wrap: nowrap;
                overflow-x: auto;
                padding-bottom: 0.2rem;
                gap: 0.45rem;
                scrollbar-width: thin;
            }
            .nav-item {
                flex: 0 0 auto;
                min-width: max-content;
                padding: 0.72rem 0.82rem;
                justify-content: center;
            }
            .theme-toggle-row {
                padding: 0.32rem 0.15rem;
            }
            .connection-card {
                padding: 0.75rem;
            }
            .op-mini-currencies {
                grid-template-columns: 1fr;
                max-height: 170px;
            }
            .main-content {
                padding: 0.95rem 0.85rem 5rem;
            }
            .header {
                gap: 0.72rem;
                margin-bottom: 1.15rem;
            }
            .search-bar {
                padding: 0.78rem 0.85rem;
                border-radius: 14px;
            }
            .user-actions {
                width: 100%;
                display: grid !important;
                grid-template-columns: 1fr 1fr;
                gap: 0.55rem !important;
            }
            .user-actions .btn-close-game {
                width: 100%;
                justify-content: center;
                padding: 0.64rem 0.55rem !important;
            }
            .hero-content { padding: 1.4rem; }
            .hero-title { font-size: 1.9rem; }
            .project-grid { grid-template-columns: 1fr; }
            .spotlight-title {
                font-size: 1.7rem;
                line-height: 1.1;
            }
            .spotlight-subtitle {
                font-size: 0.88rem;
            }
            .spotlight-actions {
                flex-direction: column;
                align-items: stretch;
            }
            .spotlight-actions .btn-install {
                width: 100% !important;
            }
            .spotlight-metrics {
                grid-template-columns: 1fr 1fr;
            }
            .spotlight-panel {
                padding: 0.82rem;
            }
            .filter-chips {
                overflow-x: auto;
                flex-wrap: nowrap;
                padding-bottom: 0.22rem;
            }
            .filter-chip {
                flex: 0 0 auto;
            }
            .section-title {
                font-size: 1.1rem;
            }
            .ecosystem-row {
                grid-template-columns: 1fr;
                justify-items: start;
                gap: 0.65rem;
            }
            .ecosystem-row .app-icon {
                width: 62px;
                height: 62px;
            }
            .ecosystem-open-btn {
                width: 100%;
            }
            .update-banner {
                left: 10px;
                right: 10px;
                bottom: max(10px, env(safe-area-inset-bottom));
                min-width: 0;
                transform: none;
                padding: 0.78rem 0.78rem 0.78rem 0.95rem;
                gap: 0.62rem;
                border-radius: 14px;
            }
            .update-banner.visible {
                animation: bannerPopMobile 0.24s ease;
            }
            .update-banner .update-text strong { font-size: 0.85rem; }
            .update-banner .update-text span { font-size: 0.72rem; }
            .update-banner .update-meta { font-size: 0.67rem; }
            .update-banner .update-progress { width: 88px; }
            .update-banner .btn-update { padding: 0.48rem 0.66rem; font-size: 0.7rem; }
            .update-banner .btn-close-update { width: 28px; height: 28px; }
        }

        @keyframes bannerPopMobile {
            from { opacity: 0; transform: translateY(8px) scale(0.985); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
    </style>
</head>

<body>
    <div id="game-overlay">
        <div class="game-controls">
            <button class="btn-close-game" onclick="closeGame()"><i class="fas fa-house"></i> CARGAR STORE</button>
            <button class="btn-close-game" onclick="toggleFullscreen()"><i class="fas fa-expand"></i></button>
        </div>
        <iframe id="game-frame" src="about:blank"></iframe>
    </div>

    <div id="details-modal">
        <button class="btn-close-modal" onclick="closeDetails()"><i class="fas fa-times"></i></button>
        <div class="modal-banner" id="m-banner"></div>
        <div class="modal-header">
            <img src="" class="modal-icon-large" id="m-icon" alt="">
            <div class="modal-title-area">
                <div class="modal-dev">Ocean and Wild Studios</div>
                <div class="modal-title" id="m-title">Project Name</div>
            </div>
        </div>
        <div class="modal-body">
            <p class="modal-description" id="m-desc">Cargando informacion...</p>
            <div class="modal-stats">
                <div class="stat-box">
                    <div class="stat-label">Version</div>
                    <div class="stat-value" id="m-version">1.0.0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Estado</div>
                    <div class="stat-value" id="m-status">Lanzado</div>
                </div>
            </div>
            <div id="m-platforms" class="modal-platforms" style="display:none;">
                <div class="stat-label">Plataforma de descarga</div>
                <div id="m-platform-options" class="modal-platform-options"></div>
                <div id="m-platform-meta" class="modal-platform-meta"></div>
            </div>
        </div>
        <div class="modal-actions" id="m-actions"></div>
    </div>

    <div class="app-container">
        <aside class="sidebar">
            <div class="logo" id="brand-logo" aria-live="polite">
                <i id="brand-logo-icon" class="fas fa-cube"></i>
                <div class="brand-copy">
                    <span class="brand-prefix">OWS</span>
                    <span id="brand-logo-word" class="brand-word">ATLAS</span>
                </div>
            </div>
            <div id="brand-logo-caption" class="logo-caption">Mapa vivo de proyectos y ideas.</div>
            <nav class="nav-menu">
                <li class="nav-item active" onclick="showSection('home', this)"><i class="fas fa-house"></i> Explorar</li>
                <li class="nav-item" onclick="showSection('library', this)"><i class="fas fa-folder-open"></i> Biblioteca</li>
                <li class="nav-item" onclick="showSection('updates', this)"><i class="fas fa-arrow-up-from-bracket"></i> Actualizaciones <span id="update-badge" style="display:none; background:var(--accent-primary); color:var(--bg); border-radius:50%; padding:2px 6px; font-size:10px; margin-left:auto; font-weight:800;">!</span></li>
            </nav>
            <div class="theme-toggle-row">
                <span class="theme-toggle-label">Dark Mode</span>
                <button id="theme-switch" class="theme-switch" onclick="toggleTheme()" aria-label="Cambiar tema"></button>
            </div>
            <div id="sidebar-download-dock" class="download-dock">
                <div class="download-dock-head">
                    <span>Descargas Activas</span>
                    <span id="dock-count-badge" class="download-dock-count">0</span>
                </div>
                <div class="download-dock-body">
                    <img id="dock-item-icon" class="download-dock-icon" src="./build/icon.ico" alt="download icon">
                    <div class="download-dock-info">
                        <div id="dock-item-title" class="download-dock-title">Sin descargas</div>
                        <div id="dock-item-status" class="download-dock-status">En espera</div>
                        <div class="download-dock-progress">
                            <div id="dock-item-progress" class="download-dock-progress-fill"></div>
                        </div>
                    </div>
                    <div id="dock-item-loader" class="download-dock-loader"></div>
                </div>
                <div class="download-dock-controls">
                    <div>
                        <button id="dock-prev-btn" class="download-dock-btn" onclick="cycleSidebarDownload(-1)"><i class="fas fa-chevron-left"></i></button>
                        <button id="dock-next-btn" class="download-dock-btn" onclick="cycleSidebarDownload(1)"><i class="fas fa-chevron-right"></i></button>
                    </div>
                    <span id="dock-item-index" class="download-dock-index">0/0</span>
                </div>
            </div>
            <div class="connection-card" id="oceanpay-placeholder-card">
                <div id="update-indicator-dot" class="update-indicator" style="display:none;"></div>
                <div class="connection-caption">CONECTADO A</div>
                <div class="connection-title"><i class="fas fa-shield-halved"></i> Ocean Pay ID</div>
                <div id="op-placeholder-chip" class="connection-placeholder-badge"><i class="fas fa-hourglass-half"></i> Placeholder</div>
                <div id="op-connection-status" class="op-mini-status">Sin conexion. Inicia sesion para sincronizar Ocean Pay en OWS Store.</div>
                <div id="op-connection-user" class="op-mini-user"></div>
                <div id="op-connection-balance" class="op-mini-balance"></div>
                <div id="op-connection-currencies" class="op-mini-currencies"></div>
                <div id="op-mini-form" class="op-mini-form">
                    <input id="op-mini-username" class="op-mini-input" type="text" autocomplete="username" placeholder="Usuario Ocean Pay">
                    <input id="op-mini-password" class="op-mini-input" type="password" autocomplete="current-password" placeholder="Contrasena">
                </div>
                <div class="op-mini-actions">
                    <button id="op-mini-connect" class="op-mini-btn primary" onclick="connectOceanPayStore()">Conectar</button>
                    <button id="op-mini-refresh" class="op-mini-btn" onclick="refreshOceanPayStore()" disabled>Sincronizar</button>
                    <button id="op-mini-disconnect" class="op-mini-btn warn" onclick="disconnectOceanPayStore()" disabled>Salir</button>
                </div>
                <div id="app-version" style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.25rem;">v23.2.26-1015</div>
            </div>
        </aside>

        <!-- Banner de actualizacion (Electron) -->
        <div id="update-banner" class="update-banner state-info">
            <div class="update-icon"><i id="update-icon-glyph" class="fas fa-circle-info"></i></div>
            <div class="update-text">
                <strong id="update-title">Centro de actualizaciones</strong>
                <span id="update-msg">Una nueva version esta lista.</span>
                <div id="update-meta" class="update-meta">Tamano: - | ETA: -</div>
            </div>
            <div id="update-progress-wrap" class="update-progress" style="display:none;">
                <div id="update-progress-fill" class="update-progress-fill"></div>
            </div>
            <button id="btn-close-update-banner" class="btn-close-update" title="Cerrar" onclick="dismissUpdateBanner()">
                <i class="fas fa-times"></i>
            </button>
            <button id="btn-install-update" class="btn-update" style="display:none;" onclick="installUpdate()">
                <i class="fas fa-sync-alt"></i> Reiniciar e instalar
            </button>
        </div>

        <main class="main-content" id="main-view">
            <header class="header">
                <div class="search-bar">
                    <i class="fas fa-search"></i>
                    <input id="search-input" type="text" placeholder="Buscar juegos, herramientas o experiencias...">
                </div>
                <div class="user-actions" style="display: flex; gap: 1rem;">
                    <button class="btn-close-game" style="padding: 0.75rem 1rem;" onclick="syncLibraryNow()"><i class="fas fa-rotate"></i> Sincronizar</button>
                    <button class="btn-close-game" style="padding: 0.75rem 1rem;" onclick="showSection('updates', document.querySelector('.nav-menu .nav-item:nth-child(3)'))"><i class="fas fa-bell"></i> Notificaciones</button>
                </div>
            </header>

            <section id="home-view">
                <div class="explore-shell">
                    <div class="explore-spotlight">
                        <div>
                            <div class="spotlight-chip"><i class="fas fa-sparkles"></i> Ecosistema Multiproyecto</div>
                            <h1 class="spotlight-title">Descubre juegos, herramientas y experimentos inesperados.</h1>
                            <p class="spotlight-subtitle">
                                OWS Store combina lanzamientos estables, builds para Windows y conceptos en evolucion. Instala en cola, sigue el progreso en tiempo real y administra todo desde un solo hub.
                            </p>
                            <div class="spotlight-actions">
                                <button class="btn-install" style="width:auto; padding:0.85rem 1.15rem;" onclick="openWildWeaponAction(event)">
                                    <i class="fas fa-download"></i> Instalar destacado
                                </button>
                                <button class="btn-install btn-hero-secondary" style="width:auto; padding:0.85rem 1.15rem;" onclick="showSection('updates', document.querySelector('.nav-menu .nav-item:nth-child(3)'))">
                                    <i class="fas fa-arrow-down-up-across-line"></i> Ver descargas
                                </button>
                            </div>
                            <div class="spotlight-metrics">
                                <div class="spotlight-metric">
                                    <div id="explore-metric-total" class="spotlight-metric-value">0</div>
                                    <div class="spotlight-metric-label">Proyectos</div>
                                </div>
                                <div class="spotlight-metric">
                                    <div id="explore-metric-installed" class="spotlight-metric-value">0</div>
                                    <div class="spotlight-metric-label">Instalados</div>
                                </div>
                                <div class="spotlight-metric">
                                    <div id="explore-metric-updates" class="spotlight-metric-value">0</div>
                                    <div class="spotlight-metric-label">Con Update</div>
                                </div>
                            </div>
                        </div>
                        <div class="spotlight-side">
                            <div class="spotlight-panel">
                                <div class="spotlight-panel-title">Lanzamientos recientes</div>
                                <div id="explore-release-feed" class="spotlight-list">
                                    <div class="spotlight-list-item"><span>WildWeapon Mayhem</span><span>Windows</span></div>
                                    <div class="spotlight-list-item"><span>Savage Space Animals</span><span>Windows</span></div>
                                    <div class="spotlight-list-item"><span>OWS Store</span><span>Core Hub</span></div>
                                </div>
                            </div>
                            <div class="spotlight-panel">
                                <div class="spotlight-panel-title">Estado de descargas</div>
                                <div id="explore-download-preview" class="spotlight-list">
                                    <div class="spotlight-list-item"><span>Sin descargas activas</span><span>Idle</span></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="explore-controls">
                        <div class="filter-chips">
                            <button id="filter-chip-all" class="filter-chip active" onclick="setProjectFilter('all')">Todo</button>
                            <button id="filter-chip-installed" class="filter-chip" onclick="setProjectFilter('installed')">Instalados</button>
                            <button id="filter-chip-external" class="filter-chip" onclick="setProjectFilter('external')">Windows EXE</button>
                            <button id="filter-chip-updates" class="filter-chip" onclick="setProjectFilter('updates')">Con update</button>
                        </div>
                        <div class="explore-note">Tip: selecciona varios proyectos para encadenar descargas en cola.</div>
                    </div>

                    <div class="section-title">Ecosistema de Estudio <span style="font-size: 0.8rem; color: var(--accent-primary); cursor:pointer;">Ver todos</span></div>
                    <div class="project-grid ecosystem-list" id="projects-container">
                        <div class="app-card" style="opacity: 0.5;">
                            <div style="height: 64px; width: 64px; background: var(--glass); border-radius: 16px; margin-bottom: 1rem;"></div>
                            <div style="height: 20px; width: 60%; background: var(--glass); margin-bottom: 0.5rem;"></div>
                            <div style="height: 12px; width: 40%; background: var(--glass);"></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="library-view" style="display:none;">
                <div class="section-title">Mi Biblioteca Virtual</div>
                <div class="project-grid" id="library-container">
                    <p style="color:var(--text-dim)">No tienes proyectos instalados aun.</p>
                </div>
            </section>
            <section id="updates-view" style="display:none;">
                <div class="section-title">Centro de Actualizaciones</div>
                <div id="downloads-activity-list" class="downloads-activity">
                    <div class="download-item waiting">
                        <img class="avatar" src="./build/icon.ico" alt="OWS">
                        <div class="download-item-main">
                            <div class="download-item-head">
                                <div class="download-item-title">Sin descargas activas</div>
                                <div class="download-item-phase">Idle</div>
                            </div>
                            <div class="download-item-meta">Cuando inicies una descarga o update, aparecera aqui.</div>
                            <div class="download-item-progress-wrap">
                                <div class="download-item-progress"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="display:grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap:1rem; margin-bottom:1rem;">
                    <div class="stat-box">
                        <div class="stat-label">Estado Updater</div>
                        <div class="stat-value" id="updates-status">Esperando verificacion</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Version App</div>
                        <div class="stat-value" id="updates-app-version">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Instalador Externo</div>
                        <div class="stat-value" id="updates-project-status">Sin acciones recientes</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Tamano Update</div>
                        <div class="stat-value" id="updates-size">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Tiempo Estimado</div>
                        <div class="stat-value" id="updates-eta">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">OWS Store Android</div>
                        <div class="stat-value" style="display:flex; flex-direction:column; gap:0.55rem;">
                            <span id="ows-android-release-meta" class="android-release-meta">Buscando release Android...</span>
                            <button class="btn-install" style="width:auto; padding:0.55rem 0.8rem;" onclick="openStoreAndroidDownload()">
                                <i class="fas fa-mobile-screen-button"></i> Descargar Android
                            </button>
                        </div>
                    </div>
                </div>
                <div class="section-title">Actualizaciones de Proyectos</div>
                <div id="project-updates-list" style="display:flex; flex-direction:column; gap:0.6rem; margin-bottom:1rem;">
                    <div class="info-note-card">No hay actualizaciones pendientes.</div>
                </div>
                <div class="section-title">Notificaciones</div>
                <div id="notifications-list" style="display:flex; flex-direction:column; gap:0.6rem;"></div>
            </section>
        </main>
    </div>

    <script>
        const API_URL = 'https://owsdatabase.onrender.com';
        const OWS_STORE_ANDROID_API_BASE = `${API_URL}/ows-store/android`;
        const OWS_STORE_ANDROID_SLUG = 'ows-store';
        const FLORET_ANDROID_SLUG = 'floret-shop';
        const WILDWEAPON_RELEASES_URL = 'https://github.com/OceanandWild/wildweapon-mayhem/releases/latest';
        const WILDWEAPON_RELEASES_API_URL = 'https://api.github.com/repos/OceanandWild/wildweapon-mayhem/releases/latest';
        const WILDWEAPON_LOCAL_ICON = './build/wildweaponmayhem.ico';
        const SSA_RELEASES_URL = 'https://github.com/OceanandWild/savagespaceanimals/releases/latest';
        const SSA_RELEASES_API_URL = 'https://api.github.com/repos/OceanandWild/savagespaceanimals/releases/latest';
        const OCEAN_PAY_RELEASES_URL = 'https://github.com/OceanandWild/oceanpay/releases/';
        const OCEAN_PAY_RELEASES_API_URL = 'https://api.github.com/repos/OceanandWild/oceanpay/releases/latest';
        const OWS_STORE_RELEASES_URL = 'https://github.com/OceanandWild/owsdatabase/releases';
        const OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL = OWS_STORE_RELEASES_URL;
        const FLORET_RELEASES_URL = 'https://github.com/OceanandWild/floretshop/releases';
        const SSA_LOCAL_ICON = './build/ssa.ico?v=20260223-0443';
        const OCEAN_PAY_LOCAL_ICON = './build/oceanpay.ico?v=20260223-1825';
        const FLORET_LOCAL_ICON = 'https://raw.githubusercontent.com/OceanandWild/owsdatabase/main/Floret%20Shop/assets/floretshopicon.png?v=20260224-1938';
        const STORE_LOCAL_ICON = './build/icon.ico?v=20260223-0452';
        const STORE_DOWNLOAD_KEY = '__ows_store_update__';
        const STORE_THEME_KEY = 'ows_store_theme';
        const OCEAN_PAY_STORAGE_USER = 'opUser';
        const OCEAN_PAY_STORAGE_TOKEN = 'opToken';
        const SSA_PROJECT = {
            slug: 'savagespaceanimals',
            name: 'Savage Space Animals',
            short: 'SSA',
            status: 'launched',
            version: '1.0.0',
            description: 'Combate espacial con fauna extrema y progresion arcade.',
            url: '../Savage Space Animals/index.html',
            icon_url: SSA_LOCAL_ICON
        };
        const FLORET_PROJECT = {
            slug: 'floret-shop',
            name: 'Floret Shop',
            short: 'FLR',
            status: 'launched',
            version: '1.0.0',
            platform: 'android,windows',
            install_type: 'external',
            installer_url: '',
            android_release_url: FLORET_RELEASES_URL,
            android_apk_url: '',
            description: 'Marketplace de Floret. Descarga Android disponible; Windows en progreso.',
            icon_url: FLORET_LOCAL_ICON
        };
        const BRAND_STATES = [
            { word: 'ATLAS', iconClass: 'fa-cube', color: '#d14f2a', caption: 'Mapa vivo de proyectos y ideas.' },
            { word: 'STORE', iconClass: 'fa-store', color: '#007f84', caption: 'Instala juegos, herramientas y experiencias.' },
            { word: 'LABS', iconClass: 'fa-flask', color: '#1f9d63', caption: 'Prototipos inesperados en evolucion constante.' },
            { word: 'ARCADE', iconClass: 'fa-gamepad', color: '#b96700', caption: 'Diversidad de estilos para cada jugador.' },
        ];
        let wildWeaponReleaseCache = null;
        let ssaReleaseCache = null;
        let oceanPayProjectReleaseCache = null;
        let floretProjectReleaseCache = null;
        let owsStoreAndroidReleaseCache = null;
        let allProjects = [];
        const notificationLog = [];
        let lastExternalStatusNotification = '';
        let installStateBySlug = {};
        let installRuntimeBySlug = {};
        let uninstallSuppressedBySlug = {};
        let currentSearchTerm = '';
        let currentProjectFilter = 'all';
        let activeSection = 'home';
        let scheduledRenderTimer = null;
        let actionBannerTimer = null;
        let actionBannerSticky = false;
        let appUpdateAvailable = false;
        let appUpdateSizeBytes = 0;
        let appUpdateEtaSeconds = null;
        let projectUpdatesCount = 0;
        let brandStateIndex = 0;
        let brandCycleTimer = null;
        let brandSwapCleanupTimer = null;
        let sidebarDownloadCursor = 0;
        let sidebarSelectedDownloadKey = '';
        let sidebarSelectionPinnedByUser = false;
        let downloadSurfacesRenderQueued = false;
        let downloadSurfacesLastRenderedAt = 0;
        let installQueueProcessing = false;
        let activeInstallTaskKey = '';
        let oceanPayState = {
            user: null,
            token: '',
            balance: 0,
            balances: {},
            loading: false,
            connected: false
        };
        const projectInstallQueue = [];
        const downloadSessions = {};
        const UPDATE_BANNER_STATES = ['checking', 'available', 'downloading', 'ready', 'success', 'error', 'info'];
        const projectUpdateNotified = new Set();
        const externalProgressUiState = {};
        const selectedInstallTargetBySlug = {};
        const owsStoreAndroidState = {
            downloadUrl: OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL,
            version: '',
            sizeBytes: 0,
            publishedAt: null,
            source: 'release-page',
            warning: ''
        };

        function applyTheme(theme) {
            const mode = theme === 'dark' ? 'dark' : 'light';
            document.body.setAttribute('data-theme', mode);
            localStorage.setItem(STORE_THEME_KEY, mode);
            const toggle = document.getElementById('theme-switch');
            if (toggle) toggle.classList.toggle('dark', mode === 'dark');
        }

        function initTheme() {
            const saved = localStorage.getItem(STORE_THEME_KEY);
            if (saved === 'light' || saved === 'dark') {
                applyTheme(saved);
                return;
            }
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            applyTheme(prefersDark ? 'dark' : 'light');
        }

        function toggleTheme() {
            const current = document.body.getAttribute('data-theme') || 'light';
            applyTheme(current === 'dark' ? 'light' : 'dark');
        }

        function getOceanPayToken() {
            if (oceanPayState.token) return oceanPayState.token;
            const fromStorage = localStorage.getItem(OCEAN_PAY_STORAGE_TOKEN) || '';
            if (fromStorage) return fromStorage;
            try {
                const parsed = JSON.parse(localStorage.getItem(OCEAN_PAY_STORAGE_USER) || 'null');
                return parsed?.token || '';
            } catch (_) {
                return '';
            }
        }

        const OCEAN_PAY_CURRENCY_LABELS = {
            aquabux: 'AquaBux',
            ecoxionums: 'Ecoxionums',
            wildcredits: 'WildCredits',
            wildgems: 'WildGems',
            appbux: 'AppBux',
            ecobooks: 'EcoBooks',
            ecotokens: 'EcoTokens',
            ecobits: 'EcoCoreBits',
            ecorebits: 'EcoCoreBits',
            nxb: 'Nexus Bits',
            amber: 'Amber',
            voltbit: 'VoltBits',
            mayhemcoins: 'MayhemCoins',
            cosmicdust: 'Polvora Cosmica'
        };

        const OCEAN_PAY_CURRENCY_ORDER = [
            'aquabux',
            'ecoxionums',
            'wildcredits',
            'wildgems',
            'cosmicdust',
            'appbux',
            'ecobooks',
            'ecotokens',
            'ecorebits',
            'nxb',
            'amber',
            'voltbit',
            'mayhemcoins'
        ];

        function toOceanPayNumber(value) {
            const n = Number(value);
            return Number.isFinite(n) ? n : 0;
        }

        function oceanPaySortRank(code) {
            const idx = OCEAN_PAY_CURRENCY_ORDER.indexOf(code);
            return idx === -1 ? 999 : idx;
        }

        function extractOceanPayBalances(payload = {}) {
            const totals = {};
            const absorb = (source) => {
                if (!source || typeof source !== 'object') return;
                Object.entries(source).forEach(([code, value]) => {
                    const amount = toOceanPayNumber(value);
                    if (!Number.isFinite(amount)) return;
                    totals[code] = toOceanPayNumber(totals[code]) + amount;
                });
            };

            const cards = Array.isArray(payload.cards)
                ? payload.cards
                : (Array.isArray(payload?.user?.cards) ? payload.user.cards : []);

            if (cards.length) cards.forEach((card) => absorb(card?.balances));
            if (!cards.length && payload.balances && typeof payload.balances === 'object') absorb(payload.balances);

            [
                'aquabux', 'ecoxionums', 'wildcredits', 'wildgems', 'appbux',
                'ecobooks', 'ecotokens', 'ecorebits', 'ecobits', 'nxb',
                'amber', 'voltbit', 'mayhemcoins', 'cosmicdust'
            ].forEach((code) => {
                if (totals[code] !== undefined) return;
                const rootValue = payload?.[code];
                const userValue = payload?.user?.[code];
                if (rootValue !== undefined) totals[code] = toOceanPayNumber(rootValue);
                else if (userValue !== undefined) totals[code] = toOceanPayNumber(userValue);
            });

            if (totals.ecorebits === undefined && totals.ecobits !== undefined) totals.ecorebits = totals.ecobits;

            return totals;
        }

        function renderOceanPayCurrencyChips() {
            const container = document.getElementById('op-connection-currencies');
            if (!container) return;
            const connected = Boolean(oceanPayState.connected);
            if (!connected) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            const entries = Object.entries(oceanPayState.balances || {})
                .map(([code, value]) => [code, toOceanPayNumber(value)]);
            const known = OCEAN_PAY_CURRENCY_ORDER.map((code) => [code, toOceanPayNumber(oceanPayState?.balances?.[code])]);
            const knownSet = new Set(OCEAN_PAY_CURRENCY_ORDER);
            const extra = entries
                .filter(([code]) => !knownSet.has(code))
                .sort((a, b) => b[1] - a[1]);
            const renderedEntries = [...known, ...extra];

            const visible = renderedEntries;
            if (!visible.length) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            const chipsHtml = visible.map(([code, value]) => {
                const label = OCEAN_PAY_CURRENCY_LABELS[code] || code.toUpperCase();
                return `
                    <div class="op-mini-currency-chip">
                        <span class="label">${label}</span>
                        <span class="value">${Math.floor(value).toLocaleString()}</span>
                    </div>
                `;
            }).join('');

            container.innerHTML = chipsHtml;
            container.style.display = 'grid';
        }

        function setOceanPaySession({ user = null, token = '', balance = 0, balances = null }) {
            const normalizedBalances = balances && typeof balances === 'object'
                ? { ...balances }
                : (token ? { ...(oceanPayState.balances || {}) } : {});
            const aquabuxFromBalances = toOceanPayNumber(normalizedBalances.aquabux);
            const explicitBalance = toOceanPayNumber(balance);
            oceanPayState = {
                ...oceanPayState,
                user: user || null,
                token: token || '',
                balance: aquabuxFromBalances > 0 ? aquabuxFromBalances : explicitBalance,
                balances: normalizedBalances,
                connected: Boolean(token)
            };
            if (token && user) {
                localStorage.setItem(OCEAN_PAY_STORAGE_TOKEN, token);
                localStorage.setItem(OCEAN_PAY_STORAGE_USER, JSON.stringify({ ...user, token }));
            } else if (!token) {
                localStorage.removeItem(OCEAN_PAY_STORAGE_TOKEN);
                localStorage.removeItem(OCEAN_PAY_STORAGE_USER);
            }
            renderOceanPayCard();
        }

        function renderOceanPayCard() {
            const status = document.getElementById('op-connection-status');
            const userEl = document.getElementById('op-connection-user');
            const balanceEl = document.getElementById('op-connection-balance');
            const form = document.getElementById('op-mini-form');
            const chip = document.getElementById('op-placeholder-chip');
            const btnConnect = document.getElementById('op-mini-connect');
            const btnRefresh = document.getElementById('op-mini-refresh');
            const btnDisconnect = document.getElementById('op-mini-disconnect');
            const connected = Boolean(oceanPayState.connected);
            if (status) {
                if (oceanPayState.loading) status.textContent = 'Sincronizando Ocean Pay...';
                else if (connected) status.textContent = 'Ocean Pay conectado correctamente.';
                else status.textContent = 'Sin conexion. Inicia sesion para sincronizar Ocean Pay en OWS Store.';
            }
            if (userEl) {
                userEl.style.display = connected ? 'block' : 'none';
                userEl.textContent = connected ? `Usuario: ${oceanPayState.user?.username || 'desconocido'}` : '';
            }
            if (balanceEl) {
                balanceEl.style.display = connected ? 'block' : 'none';
                const aquabux = toOceanPayNumber(oceanPayState?.balances?.aquabux ?? oceanPayState.balance);
                balanceEl.textContent = connected ? `AquaBux: ${Math.floor(aquabux).toLocaleString()}` : '';
            }
            renderOceanPayCurrencyChips();
            if (form) form.style.display = connected ? 'none' : 'flex';
            if (chip) chip.style.display = connected ? 'none' : 'inline-flex';
            if (btnConnect) btnConnect.disabled = oceanPayState.loading || connected;
            if (btnRefresh) btnRefresh.disabled = oceanPayState.loading || !connected;
            if (btnDisconnect) btnDisconnect.disabled = oceanPayState.loading || !connected;
        }

        async function oceanPayApi(path, options = {}, retry = true) {
            const token = getOceanPayToken();
            const cfg = { ...options, headers: { ...(options.headers || {}) } };
            if (token) cfg.headers.Authorization = `Bearer ${token}`;
            let res = await fetch(`${API_URL}${path}`, cfg);
            if (res.status === 401 && token && retry) {
                const refreshed = await refreshOceanPayToken();
                if (refreshed) return oceanPayApi(path, options, false);
            }
            return res;
        }

        async function refreshOceanPayToken() {
            const token = getOceanPayToken();
            if (!token) return false;
            try {
                const res = await fetch(`${API_URL}/ocean-pay/refresh-token`, {
                    method: 'POST',
                    headers: { Authorization: `Bearer ${token}` }
                });
                if (!res.ok) return false;
                const data = await res.json();
                if (!data?.token) return false;
                const oldUser = JSON.parse(localStorage.getItem(OCEAN_PAY_STORAGE_USER) || '{}');
                setOceanPaySession({
                    user: { ...oldUser, ...(data.user || {}) },
                    token: data.token,
                    balance: oceanPayState.balance
                });
                return true;
            } catch (_) {
                return false;
            }
        }

        async function refreshOceanPayStore() {
            const token = getOceanPayToken();
            if (!token) {
                setOceanPaySession({ user: null, token: '', balance: 0, balances: {} });
                return false;
            }
            oceanPayState.loading = true;
            renderOceanPayCard();
            try {
                const res = await oceanPayApi('/ocean-pay/me');
                if (!res.ok) throw new Error('Sesion no valida');
                const data = await res.json();
                const currentUser = JSON.parse(localStorage.getItem(OCEAN_PAY_STORAGE_USER) || '{}');
                const balances = extractOceanPayBalances(data);
                setOceanPaySession({
                    user: {
                        ...currentUser,
                        id: data.id || currentUser.id,
                        uid: data.id || currentUser.uid,
                        username: data.username || currentUser.username
                    },
                    token: getOceanPayToken(),
                    balance: toOceanPayNumber(balances.aquabux),
                    balances
                });
                addNotification('Ocean Pay sincronizado.', 'success');
                return true;
            } catch (err) {
                setOceanPaySession({ user: null, token: '', balance: 0, balances: {} });
                addNotification('Sesion de Ocean Pay expirada. Vuelve a iniciar sesion.', 'warning');
                return false;
            } finally {
                oceanPayState.loading = false;
                renderOceanPayCard();
            }
        }

        async function connectOceanPayStore() {
            const userInput = document.getElementById('op-mini-username');
            const passInput = document.getElementById('op-mini-password');
            const username = String(userInput?.value || '').trim();
            const password = String(passInput?.value || '').trim();
            if (!username || !password) {
                addNotification('Completa usuario y contrasena de Ocean Pay.', 'warning');
                return;
            }
            oceanPayState.loading = true;
            renderOceanPayCard();
            try {
                const res = await fetch(`${API_URL}/ocean-pay/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok || !data?.token) throw new Error(data?.error || 'No se pudo iniciar sesion');
                const loginPayload = {
                    ...data,
                    ...(data?.user || {}),
                    cards: data?.cards || data?.user?.cards || []
                };
                const balances = extractOceanPayBalances(loginPayload);
                setOceanPaySession({
                    user: { ...(data.user || {}), username },
                    token: data.token,
                    balance: toOceanPayNumber(balances.aquabux || data?.user?.aquabux || data?.aquabux || 0),
                    balances
                });
                if (userInput) userInput.value = '';
                if (passInput) passInput.value = '';
                await refreshOceanPayStore();
            } catch (err) {
                addNotification(`Ocean Pay: ${err?.message || 'error de conexion'}`, 'error');
            } finally {
                oceanPayState.loading = false;
                renderOceanPayCard();
            }
        }

        function disconnectOceanPayStore() {
            setOceanPaySession({ user: null, token: '', balance: 0, balances: {} });
            addNotification('Sesion de Ocean Pay cerrada en OWS Store.', 'neutral');
        }

        function initOceanPayStore() {
            const token = getOceanPayToken();
            if (token) {
                let user = null;
                try { user = JSON.parse(localStorage.getItem(OCEAN_PAY_STORAGE_USER) || 'null'); } catch (_) {}
                setOceanPaySession({ user, token, balance: 0, balances: {} });
                refreshOceanPayStore();
            } else {
                renderOceanPayCard();
            }
        }

        function formatByteSize(bytes) {
            const n = Number(bytes);
            if (!Number.isFinite(n) || n <= 0) return '-';
            const units = ['B', 'KB', 'MB', 'GB'];
            let value = n;
            let idx = 0;
            while (value >= 1024 && idx < units.length - 1) {
                value /= 1024;
                idx += 1;
            }
            const precision = idx === 0 ? 0 : (value < 10 ? 2 : 1);
            return `${value.toFixed(precision)} ${units[idx]}`;
        }

        function formatEta(seconds) {
            const s = Number(seconds);
            if (!Number.isFinite(s) || s < 0) return '-';
            if (s < 5) return 'menos de 5s';
            if (s < 60) return `${Math.ceil(s)}s`;
            const mins = Math.floor(s / 60);
            const secs = Math.ceil(s % 60);
            if (mins < 60) return `${mins}m ${secs}s`;
            const hours = Math.floor(mins / 60);
            const remMins = mins % 60;
            return `${hours}h ${remMins}m`;
        }

        function extractUpdateSizeBytes(info) {
            const files = Array.isArray(info?.files) ? info.files : [];
            const withSize = files.find((f) => Number.isFinite(Number(f?.size)) && Number(f.size) > 0);
            return withSize ? Number(withSize.size) : 0;
        }

        function setUpdateMetaUI(payload = {}) {
            const sizeEl = document.getElementById('updates-size');
            const etaEl = document.getElementById('updates-eta');
            const metaEl = document.getElementById('update-meta');
            const sizeBytes = Number.isFinite(Number(payload.sizeBytes)) ? Number(payload.sizeBytes) : appUpdateSizeBytes;
            const etaSeconds = Number.isFinite(Number(payload.etaSeconds)) ? Number(payload.etaSeconds) : appUpdateEtaSeconds;
            const transferredBytes = Number.isFinite(Number(payload.transferredBytes)) ? Number(payload.transferredBytes) : null;
            const speedBps = Number(payload.speedBps || 0);

            const sizeText = formatByteSize(sizeBytes);
            const etaText = formatEta(etaSeconds);
            const transferredText = (transferredBytes !== null && sizeBytes > 0)
                ? `${formatByteSize(transferredBytes)} / ${formatByteSize(sizeBytes)}`
                : '';
            const speedText = speedBps > 0 ? `${formatByteSize(speedBps)}/s` : '';

            if (sizeEl) sizeEl.textContent = sizeText;
            if (etaEl) etaEl.textContent = etaText;
            if (metaEl) {
                const parts = [`Tamano: ${sizeText}`, `ETA: ${etaText}`];
                if (transferredText) parts.push(transferredText);
                if (speedText) parts.push(speedText);
                metaEl.textContent = parts.join(' | ');
            }
        }

        function applyBrandState(state, animate = true) {
            const logo = document.getElementById('brand-logo');
            const icon = document.getElementById('brand-logo-icon');
            const word = document.getElementById('brand-logo-word');
            const caption = document.getElementById('brand-logo-caption');
            if (!logo || !icon || !word || !caption || !state) return;

            if (animate) {
                logo.classList.remove('swap');
                void logo.offsetWidth;
                logo.classList.add('swap');
                if (brandSwapCleanupTimer) clearTimeout(brandSwapCleanupTimer);
                brandSwapCleanupTimer = setTimeout(() => logo.classList.remove('swap'), 260);
            }
            icon.className = `fas ${state.iconClass}`;
            icon.style.color = state.color;
            word.textContent = state.word;
            word.style.color = state.color;
            caption.textContent = state.caption;
        }

        function initBrandCycle() {
            if (brandCycleTimer) clearInterval(brandCycleTimer);
            brandStateIndex = 0;
            applyBrandState(BRAND_STATES[brandStateIndex], false);
            brandCycleTimer = setInterval(() => {
                brandStateIndex = (brandStateIndex + 1) % BRAND_STATES.length;
                applyBrandState(BRAND_STATES[brandStateIndex], true);
            }, 3200);
        }

        function getProjectBySlug(slug) {
            return Array.isArray(allProjects) ? allProjects.find((p) => p.slug === slug) : null;
        }

        function getDownloadKeyForProject(project) {
            return `project_${project.slug}`;
        }

        function isActiveDownloadPhase(phase) {
            return ['checking', 'available', 'queued', 'waiting', 'preparing', 'downloading', 'launching'].includes(String(phase || ''));
        }

        function getDownloadPhaseLabel(phase) {
            const p = String(phase || '');
            if (p === 'checking') return 'VERIFICANDO';
            if (p === 'available') return 'DISPONIBLE';
            if (p === 'queued') return 'EN COLA';
            if (p === 'waiting') return 'EN ESPERA';
            if (p === 'preparing') return 'PREPARANDO';
            if (p === 'downloading') return 'DESCARGANDO';
            if (p === 'launching') return 'ABRIENDO';
            if (p === 'ready') return 'LISTO';
            if (p === 'done') return 'FINALIZADO';
            if (p === 'cancelled') return 'CANCELADO';
            if (p === 'error') return 'ERROR';
            return 'IDLE';
        }

        function shouldRefreshExternalProgressUi(key, payload) {
            if (!key) return true;
            if (payload?.phase !== 'downloading') return true;
            const now = Date.now();
            const pct = Math.round(Number(payload?.percent || 0));
            const msg = String(payload?.message || '');
            const prev = externalProgressUiState[key] || { at: 0, pct: -1, msg: '' };
            const byPct = Math.abs(pct - prev.pct) >= 2;
            const byTime = (now - prev.at) >= 900;
            const byMsg = msg && msg !== prev.msg && (now - prev.at) >= 650;
            const isEdge = pct <= 1 || pct >= 99;
            const should = byPct || byTime || byMsg || isEdge;
            if (should) externalProgressUiState[key] = { at: now, pct, msg };
            return should;
        }

        function createDefaultDownloadSession(key) {
            return {
                key,
                name: 'Descarga',
                slug: '',
                icon: STORE_LOCAL_ICON,
                phase: 'idle',
                percent: 0,
                sizeBytes: 0,
                downloadedBytes: 0,
                speedBps: 0,
                etaSeconds: null,
                status: '',
                isApp: false,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                autoRemoveAt: 0,
            };
        }

        function updateDownloadSession(key, patch = {}) {
            if (!key) return;
            const prev = downloadSessions[key] || createDefaultDownloadSession(key);
            const next = {
                ...prev,
                ...patch,
                key,
                updatedAt: Date.now(),
            };
            next.percent = Math.max(0, Math.min(100, Number(next.percent || 0)));
            if (next.phase === 'ready' || next.phase === 'done' || next.phase === 'cancelled') {
                next.autoRemoveAt = Date.now() + 25000;
            } else if (next.phase === 'error') {
                next.autoRemoveAt = Date.now() + 45000;
            } else {
                next.autoRemoveAt = 0;
            }
            downloadSessions[key] = next;
            if (!sidebarSelectedDownloadKey) {
                sidebarSelectedDownloadKey = key;
            }
            requestRenderDownloadSurfaces();
        }

        function removeDownloadSession(key) {
            if (!key || !downloadSessions[key]) return;
            delete downloadSessions[key];
            if (sidebarSelectedDownloadKey === key) {
                sidebarSelectedDownloadKey = '';
                sidebarSelectionPinnedByUser = false;
            }
            requestRenderDownloadSurfaces({ immediate: true });
        }

        function purgeStaleDownloadSessions() {
            const now = Date.now();
            Object.keys(downloadSessions).forEach((key) => {
                const item = downloadSessions[key];
                if (!item) return;
                if (item.autoRemoveAt > 0 && now >= item.autoRemoveAt) {
                    delete downloadSessions[key];
                }
            });
        }

        function getDownloadSessionsList() {
            purgeStaleDownloadSessions();
            return Object.values(downloadSessions).sort((a, b) => {
                const aa = isActiveDownloadPhase(a.phase) ? 1 : 0;
                const bb = isActiveDownloadPhase(b.phase) ? 1 : 0;
                if (aa !== bb) return bb - aa;
                return (a.createdAt || 0) - (b.createdAt || 0);
            });
        }

        function getActiveDownloadSessions() {
            return getDownloadSessionsList().filter((d) => isActiveDownloadPhase(d.phase));
        }

        function cycleSidebarDownload(direction = 1) {
            const list = getActiveDownloadSessions();
            if (!list.length) return;
            const step = Number(direction) >= 0 ? 1 : -1;
            const len = list.length;
            const currentIdx = list.findIndex((item) => item.key === sidebarSelectedDownloadKey);
            const baseIdx = currentIdx >= 0 ? currentIdx : Math.min(Math.max(sidebarDownloadCursor, 0), len - 1);
            const nextIdx = (baseIdx + step + len) % len;
            sidebarDownloadCursor = nextIdx;
            sidebarSelectedDownloadKey = list[nextIdx]?.key || '';
            sidebarSelectionPinnedByUser = true;
            renderSidebarDownloadDock();
        }

        function renderSidebarDownloadDock() {
            const dock = document.getElementById('sidebar-download-dock');
            const countBadge = document.getElementById('dock-count-badge');
            const icon = document.getElementById('dock-item-icon');
            const title = document.getElementById('dock-item-title');
            const status = document.getElementById('dock-item-status');
            const progress = document.getElementById('dock-item-progress');
            const loader = document.getElementById('dock-item-loader');
            const prevBtn = document.getElementById('dock-prev-btn');
            const nextBtn = document.getElementById('dock-next-btn');
            const index = document.getElementById('dock-item-index');
            if (!dock) return;

            const items = getActiveDownloadSessions();
            if (!items.length) {
                dock.classList.remove('visible');
                sidebarDownloadCursor = 0;
                sidebarSelectedDownloadKey = '';
                sidebarSelectionPinnedByUser = false;
                return;
            }

            let selectedIdx = items.findIndex((item) => item.key === sidebarSelectedDownloadKey);
            if (selectedIdx === -1 && !sidebarSelectionPinnedByUser && activeInstallTaskKey) {
                selectedIdx = items.findIndex((item) => item.key === activeInstallTaskKey);
            }
            if (selectedIdx === -1) {
                selectedIdx = Math.min(Math.max(sidebarDownloadCursor, 0), items.length - 1);
            }
            const current = items[selectedIdx];
            sidebarDownloadCursor = selectedIdx;
            sidebarSelectedDownloadKey = current?.key || '';
            dock.classList.add('visible');
            if (countBadge) countBadge.textContent = String(items.length);
            if (icon) icon.src = current.icon || STORE_LOCAL_ICON;
            if (title) title.textContent = current.name || 'Descarga';
            if (status) {
                status.textContent = current.status
                    || `${getDownloadPhaseLabel(current.phase)} ${current.percent > 0 ? `${Math.round(current.percent)}%` : ''}`.trim();
            }
            if (progress) progress.style.width = `${Math.round(current.percent || 0)}%`;
            if (loader) {
                loader.style.display = (current.phase === 'preparing' || current.phase === 'queued' || current.phase === 'waiting') ? 'block' : 'none';
            }
            if (prevBtn) prevBtn.disabled = items.length < 2;
            if (nextBtn) nextBtn.disabled = items.length < 2;
            if (index) index.textContent = `${selectedIdx + 1}/${items.length}`;
        }

        function renderDownloadsActivityList() {
            const container = document.getElementById('downloads-activity-list');
            if (!container) return;
            const entries = getDownloadSessionsList();
            if (!entries.length) {
                container.innerHTML = `
                    <div class="download-item waiting">
                        <img class="avatar" src="${STORE_LOCAL_ICON}" alt="OWS">
                        <div class="download-item-main">
                            <div class="download-item-head">
                                <div class="download-item-title">Sin descargas activas</div>
                                <div class="download-item-phase">IDLE</div>
                            </div>
                            <div class="download-item-meta">Cuando inicies una descarga o update, aparecera aqui.</div>
                            <div class="download-item-progress-wrap">
                                <div class="download-item-progress"></div>
                            </div>
                        </div>
                    </div>`;
                return;
            }

            container.innerHTML = entries.map((item) => {
                const sizeText = formatByteSize(item.sizeBytes || 0);
                const downloadedText = item.downloadedBytes > 0 ? formatByteSize(item.downloadedBytes) : '-';
                const speedText = item.speedBps > 0 ? `${formatByteSize(item.speedBps)}/s` : '-';
                const etaText = formatEta(item.etaSeconds);
                const phaseLabel = getDownloadPhaseLabel(item.phase);
                const showProgress = item.phase === 'downloading' || item.phase === 'launching' || item.phase === 'ready' || item.phase === 'done';
                const metaText = item.status
                    || `Tamano ${sizeText} | Recibido ${downloadedText} | Velocidad ${speedText} | ETA ${etaText}`;
                return `
                    <div class="download-item ${item.phase}">
                        <img class="avatar" src="${item.icon || STORE_LOCAL_ICON}" alt="${item.name}">
                        <div class="download-item-main">
                            <div class="download-item-head">
                                <div class="download-item-title">${item.name}</div>
                                <div class="download-item-phase">${phaseLabel}</div>
                            </div>
                            <div class="download-item-meta">${metaText}</div>
                            <div class="download-item-progress-wrap ${showProgress ? 'show' : ''}">
                                <div class="download-item-progress" style="width:${Math.round(item.percent || 0)}%"></div>
                            </div>
                        </div>
                        <div class="download-item-loader"></div>
                    </div>`;
            }).join('');
        }

        function renderExploreInsights() {
            const totalEl = document.getElementById('explore-metric-total');
            const installedEl = document.getElementById('explore-metric-installed');
            const updatesEl = document.getElementById('explore-metric-updates');
            const releaseFeed = document.getElementById('explore-release-feed');
            const downloadPreview = document.getElementById('explore-download-preview');

            if (totalEl) totalEl.textContent = String(allProjects.length || 0);
            if (installedEl) {
                const installedCount = allProjects.filter((p) => Boolean(installStateBySlug[p.slug]?.installed)).length;
                installedEl.textContent = String(installedCount);
            }
            if (updatesEl) updatesEl.textContent = String(getPendingProjectUpdates().length);

            if (releaseFeed) {
                const top = [...allProjects]
                    .sort((a, b) => {
                        const ad = Date.parse(a?.last_update_at || '') || 0;
                        const bd = Date.parse(b?.last_update_at || '') || 0;
                        return bd - ad;
                    })
                    .slice(0, 4);
                if (!top.length) {
                    releaseFeed.innerHTML = `<div class="spotlight-list-item"><span>Sin datos de releases</span><span>--</span></div>`;
                } else {
                    releaseFeed.innerHTML = top.map((p) => `
                        <div class="spotlight-list-item">
                            <span>${p.name}</span>
                            <span>v${p.version || '1.0.0'}</span>
                        </div>`).join('');
                }
            }

            if (downloadPreview) {
                const active = getActiveDownloadSessions().slice(0, 3);
                if (!active.length) {
                    downloadPreview.innerHTML = `<div class="spotlight-list-item"><span>Sin descargas activas</span><span>Idle</span></div>`;
                } else {
                    downloadPreview.innerHTML = active.map((d) => `
                        <div class="spotlight-list-item">
                            <span>${d.name}</span>
                            <span>${Math.round(d.percent || 0)}%</span>
                        </div>`).join('');
                }
            }
        }

        function renderDownloadSurfaces() {
            renderDownloadsActivityList();
            renderSidebarDownloadDock();
            renderExploreInsights();
        }

        function requestRenderDownloadSurfaces(options = {}) {
            const immediate = Boolean(options.immediate);
            if (immediate) {
                downloadSurfacesRenderQueued = false;
                downloadSurfacesLastRenderedAt = Date.now();
                renderDownloadSurfaces();
                return;
            }
            if (downloadSurfacesRenderQueued) return;
            const elapsed = Date.now() - downloadSurfacesLastRenderedAt;
            const waitMs = elapsed >= 280 ? 0 : (280 - elapsed);
            downloadSurfacesRenderQueued = true;
            setTimeout(() => {
                downloadSurfacesRenderQueued = false;
                downloadSurfacesLastRenderedAt = Date.now();
                renderDownloadSurfaces();
            }, waitMs);
        }

        function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function isProjectQueued(slug) {
            return projectInstallQueue.some((item) => item.slug === slug);
        }

        function syncQueueMarkers() {
            const pending = [...projectInstallQueue];
            pending.forEach((item, idx) => {
                updateDownloadSession(item.key, {
                    phase: idx === 0 && !activeInstallTaskKey ? 'waiting' : 'queued',
                    status: idx === 0 && !activeInstallTaskKey
                        ? 'En espera para iniciar descarga...'
                        : `En cola (#${idx + 1})`,
                    percent: 0,
                });
                setRuntimeState(item.slug, { phase: idx === 0 && !activeInstallTaskKey ? 'preparing' : 'queued', percent: 0, taskId: `install_${item.slug}` });
            });
            requestRenderDownloadSurfaces({ immediate: true });
        }

        async function processProjectInstallQueue() {
            if (installQueueProcessing) return;
            if (!projectInstallQueue.length) {
                syncQueueMarkers();
                return;
            }
            installQueueProcessing = true;
            while (projectInstallQueue.length) {
                const item = projectInstallQueue.shift();
                if (!item) break;
                const project = getProjectBySlug(item.slug);
                if (!project) continue;
                activeInstallTaskKey = item.key;
                const updatesStatus = document.getElementById('updates-project-status');
                if (updatesStatus) updatesStatus.textContent = 'Preparando instalador de ' + project.name + '...';
                setRuntimeState(project.slug, { phase: 'preparing', percent: 0, taskId: `install_${project.slug}` });
                updateDownloadSession(item.key, {
                    name: project.name,
                    slug: project.slug,
                    icon: getProjectIcon(project, 64),
                    phase: 'preparing',
                    percent: 0,
                    status: 'Preparando instalador...',
                    sizeBytes: 0,
                    downloadedBytes: 0,
                    speedBps: 0,
                    etaSeconds: null,
                });
                showActionMessage('Preparando instalador de ' + project.name + '...', { sticky: true, state: 'checking', title: project.name });
                requestRenderDownloadSurfaces({ immediate: true });
                await sleep(120);

                if (item.platform === 'android') {
                    if (window.owsUpdater?.installExternalInstaller) {
                        if (updatesStatus) updatesStatus.textContent = 'Descargando APK de ' + project.name + '...';
                        showActionMessage('Descargando APK de ' + project.name + '...', {
                            sticky: true,
                            state: 'downloading',
                            title: project.name,
                            showProgress: true,
                        });
                        const result = await window.owsUpdater.installExternalInstaller({
                            url: item.url,
                            name: item.fileName || `${project.name || 'android-app'}.apk`,
                            taskId: `install_${project.slug}`,
                            expectedSize: Number(item.sizeBytes || 0),
                        });
                        if (!result?.ok) {
                            setRuntimeState(project.slug, { phase: 'idle', percent: 0, taskId: '' });
                            updateDownloadSession(item.key, {
                                phase: 'error',
                                status: 'Error al descargar APK: ' + (result?.error || 'desconocido'),
                            });
                            if (updatesStatus) updatesStatus.textContent = 'Error descargando APK de ' + project.name;
                            addNotification('Error al descargar APK de ' + project.name + ': ' + (result?.error || 'desconocido'), 'error');
                            showActionMessage('Error al descargar APK de ' + project.name + '.', { state: 'error' });
                            await refreshInstallationStates();
                            scheduleSectionRender({ projects: true, library: true, immediate: true });
                            activeInstallTaskKey = '';
                            syncQueueMarkers();
                            continue;
                        }
                    } else {
                        if (updatesStatus) updatesStatus.textContent = 'Iniciando descarga APK de ' + project.name + '...';
                        setRuntimeState(project.slug, { phase: 'launching', percent: 100, taskId: `install_${project.slug}` });
                        updateDownloadSession(item.key, {
                            phase: 'launching',
                            percent: 100,
                            status: 'Abriendo instalador Android...',
                            downloadedBytes: Number(item.sizeBytes || 0),
                            etaSeconds: 0,
                        });
                        showActionMessage('Abriendo instalador Android de ' + project.name + '...', {
                            sticky: true,
                            state: 'downloading',
                            title: project.name,
                            showProgress: true,
                        });
                        openExternal(item.url);
                    }

                    localStorage.setItem(`installed_${project.slug}`, item.versionName || project.version || 'latest');
                    localStorage.setItem(`installed_platform_${project.slug}`, 'android');
                    if (Number.isFinite(Number(item.versionCode)) && Number(item.versionCode) > 0) {
                        localStorage.setItem(`installed_version_code_${project.slug}`, String(item.versionCode));
                    }
                    setRuntimeState(project.slug, { phase: 'installed', percent: 100, taskId: '' });
                    updateDownloadSession(item.key, {
                        phase: 'done',
                        percent: 100,
                        status: 'APK abierto. Completa la instalacion en Android.',
                        etaSeconds: 0,
                        downloadedBytes: Number(item.sizeBytes || 0),
                    });
                    if (updatesStatus) updatesStatus.textContent = 'APK abierto para ' + project.name;
                    addNotification('APK abierto para ' + project.name + '. Completa la instalacion en Android.', 'success');
                    showActionMessage('APK abierto para ' + project.name + '.', { state: 'ready' });
                    await refreshInstallationStates();
                    scheduleSectionRender({ projects: true, library: true, immediate: true });
                    activeInstallTaskKey = '';
                    syncQueueMarkers();
                    continue;
                }

                if (!window.owsUpdater?.installExternalInstaller) {
                    updateDownloadSession(item.key, { phase: 'error', status: 'Updater no disponible para instalar externo.' });
                    setRuntimeState(project.slug, { phase: 'idle', percent: 0, taskId: '' });
                    addNotification('Updater no disponible para instalar ' + project.name + '.', 'error');
                    continue;
                }

                if (updatesStatus) updatesStatus.textContent = 'Descargando instalador de ' + project.name + '...';
                showActionMessage('Descargando instalador de ' + project.name + '...', { sticky: true, state: 'downloading', title: project.name, showProgress: true });
                const result = await window.owsUpdater.installExternalInstaller({
                    url: item.url,
                    name: item.fileName,
                    taskId: `install_${project.slug}`,
                    expectedSize: Number(item.sizeBytes || 0),
                });
                if (!result?.ok) {
                    setRuntimeState(project.slug, { phase: 'idle', percent: 0, taskId: '' });
                    updateDownloadSession(item.key, {
                        phase: 'error',
                        status: 'Error al instalar: ' + (result?.error || 'desconocido'),
                    });
                    if (updatesStatus) updatesStatus.textContent = 'Error instalando ' + project.name;
                    addNotification('Error al instalar ' + project.name + ': ' + (result?.error || 'desconocido'), 'error');
                    showActionMessage('Error al instalar ' + project.name + '.', { state: 'error' });
                    await refreshInstallationStates();
                    scheduleSectionRender({ projects: true, library: true, immediate: true });
                    activeInstallTaskKey = '';
                    syncQueueMarkers();
                    continue;
                }
                localStorage.setItem(`installed_${project.slug}`, project.version || 'latest');
                localStorage.setItem(`installed_platform_${project.slug}`, 'windows');
                localStorage.removeItem(`installed_version_code_${project.slug}`);
                setRuntimeState(project.slug, { phase: 'installed', percent: 100, taskId: '' });
                updateDownloadSession(item.key, {
                    phase: 'done',
                    percent: 100,
                    status: 'Instalador abierto para continuar.',
                    etaSeconds: 0,
                    downloadedBytes: item.sizeBytes || 0,
                });
                if (updatesStatus) updatesStatus.textContent = 'Instalador abierto para ' + project.name;
                addNotification('Instalador abierto para ' + project.name + '.', 'success');
                showActionMessage('Instalador abierto para ' + project.name + '.', { state: 'ready' });
                await refreshInstallationStates();
                scheduleSectionRender({ projects: true, library: true, immediate: true });
                activeInstallTaskKey = '';
                syncQueueMarkers();
            }
            installQueueProcessing = false;
            activeInstallTaskKey = '';
            requestRenderDownloadSurfaces({ immediate: true });
        }

        function addNotification(text, tone = 'neutral') {
            const colorMap = {
                neutral: '#595a66',
                success: '#1f9d63',
                warning: '#b96700',
                error: '#c0392b',
            };
            notificationLog.unshift({
                text,
                tone,
                at: new Date(),
            });
            if (notificationLog.length > 20) notificationLog.length = 20;

            const list = document.getElementById('notifications-list');
            if (!list) return;
            list.innerHTML = notificationLog.map((item) => {
                const stamp = item.at.toLocaleTimeString();
                const color = colorMap[item.tone] || colorMap.neutral;
                return `<div class="notification-card" style="--tone-color:${color};">
                    <div class="notification-time">${stamp}</div>
                    <div class="notification-text">${item.text}</div>
                </div>`;
            }).join('');
        }

        function setUpdateBannerVisual(options = {}) {
            const banner = document.getElementById('update-banner');
            const titleEl = document.getElementById('update-title');
            const msgEl = document.getElementById('update-msg');
            const metaEl = document.getElementById('update-meta');
            const iconEl = document.getElementById('update-icon-glyph');
            const normalizedState = UPDATE_BANNER_STATES.includes(options.state) ? options.state : 'info';
            if (!banner) return;

            UPDATE_BANNER_STATES.forEach((s) => banner.classList.remove(`state-${s}`));
            banner.classList.add(`state-${normalizedState}`);

            if (titleEl && typeof options.title === 'string') titleEl.textContent = options.title;
            if (msgEl && typeof options.message === 'string') msgEl.textContent = options.message;
            if (metaEl && typeof options.meta === 'string') metaEl.textContent = options.meta;

            if (iconEl) {
                iconEl.className = `fas ${options.iconClass || 'fa-circle-info'}`;
                iconEl.classList.toggle('spin', Boolean(options.iconSpin));
            }
        }

        function dismissUpdateBanner(force = false) {
            const banner = document.getElementById('update-banner');
            if (!banner) return;
            if (actionBannerSticky && !force) return;
            banner.classList.remove('visible');
            if (actionBannerTimer) {
                clearTimeout(actionBannerTimer);
                actionBannerTimer = null;
            }
            actionBannerSticky = false;
        }

        function inferActionBannerState(text = '', options = {}) {
            if (options.state && UPDATE_BANNER_STATES.includes(options.state)) return options.state;
            const sample = String(text || '').toLowerCase();
            if (sample.includes('error') || sample.includes('fall')) return 'error';
            if (sample.includes('cancelad')) return 'info';
            if (sample.includes('descargando') || sample.includes('instalando')) return 'downloading';
            if (sample.includes('abriendo') || sample.includes('completa') || sample.includes('lista')) return 'ready';
            return options.sticky ? 'downloading' : 'info';
        }

        function showActionMessage(text, options = {}) {
            const banner = document.getElementById('update-banner');
            const closeBtn = document.getElementById('btn-close-update-banner');
            const installBtn = document.getElementById('btn-install-update');
            const progressWrap = document.getElementById('update-progress-wrap');
            if (!banner) return;
            const sticky = Boolean(options?.sticky);
            const state = inferActionBannerState(text, options);
            const stateMap = {
                checking: { title: 'Verificando', icon: 'fa-magnifying-glass', spin: true },
                available: { title: 'Update disponible', icon: 'fa-arrow-up', spin: false },
                downloading: { title: 'Descargando', icon: 'fa-download', spin: true },
                ready: { title: 'Accion requerida', icon: 'fa-circle-check', spin: false },
                success: { title: 'Completado', icon: 'fa-circle-check', spin: false },
                error: { title: 'Error', icon: 'fa-triangle-exclamation', spin: false },
                info: { title: 'Estado', icon: 'fa-circle-info', spin: false },
            };
            const cfg = stateMap[state] || stateMap.info;

            actionBannerSticky = sticky;
            if (installBtn && !options.keepInstallButton) installBtn.style.display = 'none';
            if (progressWrap && !options.showProgress) progressWrap.style.display = 'none';
            if (closeBtn) {
                closeBtn.disabled = sticky;
                closeBtn.style.opacity = sticky ? '0.45' : '1';
                closeBtn.style.cursor = sticky ? 'not-allowed' : 'pointer';
            }
            setUpdateBannerVisual({
                state,
                title: options.title || cfg.title,
                message: text,
                iconClass: options.iconClass || cfg.icon,
                iconSpin: options.iconSpin ?? cfg.spin,
                meta: typeof options.meta === 'string' ? options.meta : document.getElementById('update-meta')?.textContent || '',
            });
            banner.classList.add('visible');

            if (actionBannerTimer) {
                clearTimeout(actionBannerTimer);
                actionBannerTimer = null;
            }
            if (!sticky) {
                actionBannerTimer = setTimeout(() => dismissUpdateBanner(true), options.durationMs || 4800);
            }
        }

        function getRuntimeState(slug) {
            return installRuntimeBySlug[slug] || { phase: 'idle', percent: 0, taskId: '' };
        }

        function isInstallingPhase(phase) {
            return phase === 'preparing' || phase === 'downloading' || phase === 'launching';
        }

        function patchInstallProgressUI(slug) {
            if (!slug) return;
            const runtime = getRuntimeState(slug);
            const installing = isInstallingPhase(runtime.phase);
            const pct = Math.max(0, Math.min(100, Math.round(Number(runtime.percent || 0))));
            const queued = runtime.phase === 'queued';
            const preparing = runtime.phase === 'preparing';

            const ecoText = document.getElementById(`installing-text-${slug}`);
            if (ecoText) {
                ecoText.style.display = (installing || queued || preparing) ? 'block' : 'none';
                if (queued) ecoText.textContent = 'En cola para descarga...';
                else if (preparing) ecoText.textContent = 'Preparando instalador...';
                else ecoText.textContent = `Instalando: ${pct}%`;
            }

            const libStatus = document.getElementById(`lib-status-${slug}`);
            if (libStatus) {
                if (queued) libStatus.textContent = 'EN COLA';
                else if (preparing) libStatus.textContent = 'PREPARANDO';
                else libStatus.textContent = installing ? `DESCARGANDO ${pct}%` : 'INSTALADO';
            }

            const libProgress = document.getElementById(`lib-progress-${slug}`);
            const libFill = document.getElementById(`lib-fill-${slug}`);
            if (libProgress && libFill) {
                libProgress.style.display = installing ? 'block' : 'none';
                libFill.style.width = `${pct}%`;
            }
        }

        function setRuntimeState(slug, next) {
            installRuntimeBySlug[slug] = { ...getRuntimeState(slug), ...next };
            patchInstallProgressUI(slug);
        }

        function isBusyInstalling(slug) {
            const phase = getRuntimeState(slug).phase;
            return isInstallingPhase(phase) || phase === 'queued' || phase === 'waiting';
        }

        function normalizeVersionParts(v) {
            const parts = String(v || '').match(/\d+/g);
            return Array.isArray(parts) ? parts.map(n => Number(n)) : [];
        }

        function compareVersionLike(a, b) {
            const pa = normalizeVersionParts(a);
            const pb = normalizeVersionParts(b);
            const len = Math.max(pa.length, pb.length);
            for (let i = 0; i < len; i++) {
                const av = pa[i] || 0;
                const bv = pb[i] || 0;
                if (av > bv) return 1;
                if (av < bv) return -1;
            }
            return 0;
        }

        function extractVersionFromText(value) {
            const text = String(value || '');
            const match = text.match(/(\d+(?:[.-]\d+){2,}(?:-[A-Za-z]*\d{3,8})?)/);
            return match ? match[1] : '';
        }

        function isInstallableAndroidApkAsset(assetName) {
            const n = String(assetName || '').toLowerCase();
            if (!n.endsWith('.apk')) return false;
            if (n.includes('unsigned')) return false;
            if (n.includes('debug')) return false;
            return true;
        }

        function scoreAndroidAssetName(name, type = 'apk') {
            const n = String(name || '').toLowerCase();
            let score = 0;
            if (type === 'apk' && n.endsWith('.apk')) score += 12;
            if (type === 'aab' && n.endsWith('.aab')) score += 12;
            if (n.includes('signed')) score += 10;
            if (n.includes('release') && !n.includes('unsigned')) score += 6;
            if (n.includes('universal')) score += 2;
            if (n.includes('debug')) score -= 18;
            if (n.includes('unsigned')) score -= 30;
            return score;
        }

        function getPendingProjectUpdates() {
            return allProjects
                .map((p) => ({ project: p, info: getProjectUpdateInfo(p) }))
                .filter((x) => x.info.needsUpdate);
        }

        function isSSAProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('savagespaceanimals') || slug.includes('savage-space-animals') || name.includes('savage space animals');
        }

        function isOceanPayProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('ocean-pay') || slug.includes('oceanpay') || name.includes('ocean pay');
        }

        function isFloretProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('floret') || name.includes('floret shop');
        }

        function getProjectShort(project) {
            if (isSSAProject(project)) return 'SSA';
            if (isFloretProject(project)) return 'FLR';
            return '';
        }

        function ensureSSAProject(projects) {
            if (!Array.isArray(projects)) return [];
            const list = [...projects];
            const idx = list.findIndex(isSSAProject);
            if (idx === -1) {
                list.unshift({ ...SSA_PROJECT });
            } else {
                list[idx] = { ...SSA_PROJECT, ...list[idx], short: 'SSA', status: 'launched' };
            }
            return list;
        }

        function ensureFloretProject(projects) {
            if (!Array.isArray(projects)) return [];
            const list = [...projects];
            const idx = list.findIndex(isFloretProject);
            if (idx === -1) {
                list.unshift({ ...FLORET_PROJECT });
            } else {
                list[idx] = { ...FLORET_PROJECT, ...list[idx], short: 'FLR', status: 'launched' };
            }
            return list;
        }

        function syncUpdatesBadge() {
            const badge = document.getElementById('update-badge');
            if (!badge) return;
            const hasAny = appUpdateAvailable || projectUpdatesCount > 0;
            badge.style.display = hasAny ? 'inline-flex' : 'none';
            if (projectUpdatesCount > 0 && appUpdateAvailable) {
                badge.textContent = `${projectUpdatesCount}+`;
            } else if (projectUpdatesCount > 0) {
                badge.textContent = String(projectUpdatesCount);
            } else {
                badge.textContent = '!';
            }
        }

        function getProjectUpdateInfo(project) {
            const state = installStateBySlug[project.slug] || {};
            const installedVersion = state.version || getInstalledVersion(project.slug);
            const latestVersion = project.version || '';
            const installed = Boolean(state.installed || installedVersion);
            if (!installed || !installedVersion || !latestVersion) {
                return { installed, needsUpdate: false, installedVersion, latestVersion };
            }
            return {
                installed,
                installedVersion,
                latestVersion,
                needsUpdate: compareVersionLike(installedVersion, latestVersion) < 0,
            };
        }

        function getVisibleProjects() {
            const q = currentSearchTerm.trim().toLowerCase();
            return allProjects.filter((p) => {
                const searchOk = !q || String(p.name || '').toLowerCase().includes(q) || String(p.description || '').toLowerCase().includes(q);
                if (!searchOk) return false;
                if (currentProjectFilter === 'installed') return Boolean(installStateBySlug[p.slug]?.installed);
                if (currentProjectFilter === 'external') return isExternalInstallerProject(p);
                if (currentProjectFilter === 'updates') return getProjectUpdateInfo(p).needsUpdate;
                return true;
            });
        }

        function renderVisibleProjects() {
            renderProjects(getVisibleProjects());
            renderExploreInsights();
        }

        function renderProjectUpdatesList() {
            const list = document.getElementById('project-updates-list');
            if (!list) return;
            const updates = getPendingProjectUpdates();
            projectUpdatesCount = updates.length;
            syncUpdatesBadge();

            if (!updates.length) {
                const appHint = appUpdateAvailable
                    ? `<div style="margin-top:0.5rem; color:var(--brand-2);">Hay una actualizacion de OWS Store disponible en el banner superior.</div>`
                    : '';
                list.innerHTML = `<div class="info-note-card">No hay actualizaciones pendientes de proyectos.${appHint}</div>`;
                return;
            }

            list.innerHTML = updates.map(({ project, info }) => `
                <div class="project-update-card">
                    <div>
                        <div class="project-update-title">${project.name}</div>
                        <div class="project-update-meta">v${info.installedVersion} -> v${info.latestVersion}</div>
                    </div>
                    <button class="btn-install" style="width:auto; padding:0.55rem 0.8rem;" onclick="reinstallFromLibrary('${project.slug}')"><i class="fas fa-arrow-up"></i> Actualizar</button>
                </div>
            `).join('');
        }

        async function checkProjectUpdatesAndNotify() {
            await applyLatestInstallerData(allProjects);
            await refreshInstallationStates();
            renderProjectUpdatesList();
            const updates = getPendingProjectUpdates();

            updates.forEach(({ project, info }) => {
                const key = `${project.slug}:${info.installedVersion}->${info.latestVersion}`;
                if (projectUpdateNotified.has(key)) return;
                projectUpdateNotified.add(key);
                addNotification(`Actualizacion disponible para ${project.name}: v${info.latestVersion}.`, 'warning');
            });
        }

        function renderIfVisible(target) {
            if (target === 'projects' && activeSection === 'home') renderVisibleProjects();
            if (target === 'library' && activeSection === 'library') renderLibrary();
            if (target === 'updates' && activeSection === 'updates') renderProjectUpdatesList();
        }

        function scheduleSectionRender({ projects = false, library = false, immediate = false } = {}) {
            const run = () => {
                if (projects) renderIfVisible('projects');
                if (library) renderIfVisible('library');
                renderProjectUpdatesList();
                renderDownloadSurfaces();
            };
            if (immediate) {
                if (scheduledRenderTimer) {
                    clearTimeout(scheduledRenderTimer);
                    scheduledRenderTimer = null;
                }
                run();
                return;
            }
            if (scheduledRenderTimer) return;
            scheduledRenderTimer = setTimeout(() => {
                scheduledRenderTimer = null;
                run();
            }, 220);
        }

        function setProjectFilter(filter) {
            currentProjectFilter = filter || 'all';
            const ids = ['all', 'installed', 'external', 'updates'];
            ids.forEach((id) => {
                const el = document.getElementById(`filter-chip-${id}`);
                if (el) el.classList.toggle('active', currentProjectFilter === id);
            });
            renderVisibleProjects();
            renderExploreInsights();
        }

        async function syncLibraryNow() {
            addNotification('Sincronizando biblioteca...', 'neutral');
            await refreshInstallationStates();
            scheduleSectionRender({ projects: true, library: true, immediate: true });
            addNotification('Biblioteca sincronizada.', 'success');
            renderExploreInsights();
        }

        async function loadProjects() {
            try {
                const res = await fetch(`${API_URL}/ows-store/projects`);
                allProjects = await res.json();
            } catch (err) {
                console.error("Error cargando proyectos:", err);
                allProjects = [
                    { ...SSA_PROJECT },
                    { ...FLORET_PROJECT },
                    { slug: 'wildweapon', name: 'WildWeapon Mayhem', status: 'launched', version: '22.2.26-1900', platform: 'windows', install_type: 'external', installer_url: WILDWEAPON_RELEASES_URL, description: 'Combate tactico definitivo, ahora disponible en ejecutable para Windows.' },
                    { slug: 'ocean-pay', name: 'Ocean Pay', status: 'launched', version: '3.1.0', platform: 'windows', install_type: 'external', installer_url: OCEAN_PAY_RELEASES_URL, icon_url: OCEAN_PAY_LOCAL_ICON, description: 'Pasarela universal.' }
                ];
            }
            allProjects = ensureFloretProject(ensureSSAProject(allProjects));
            await applyLatestInstallerData(allProjects);
            await refreshInstallationStates();
            renderVisibleProjects();
            renderLibrary();
            renderProjectUpdatesList();
            requestRenderDownloadSurfaces({ immediate: true });
            await checkProjectUpdatesAndNotify();
        }

        async function fetchLatestWildWeaponRelease() {
            const now = Date.now();
            if (wildWeaponReleaseCache && (now - wildWeaponReleaseCache.checkedAt) < 120000) {
                return wildWeaponReleaseCache;
            }

            const res = await fetch(WILDWEAPON_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
            const scoredCandidates = exeCandidates.map((a) => ({
                asset: a,
                version: extractVersionFromText(a.name),
                updatedAtMs: Date.parse(a.updated_at || '') || 0,
                hasWildWeaponName: /wildweapon/i.test(String(a.name || '')),
            }));

            // Prefer explicit wildweapon installers, then matching-tag version, then highest parsed version.
            scoredCandidates.sort((x, y) => {
                if (x.hasWildWeaponName !== y.hasWildWeaponName) return x.hasWildWeaponName ? -1 : 1;
                const cmp = compareVersionLike(y.version, x.version);
                if (cmp !== 0) return cmp;
                return y.updatedAtMs - x.updatedAtMs;
            });
            let selected = scoredCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = scoredCandidates.find(c => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const exeAsset = selected?.asset || null;
            const versionFromAsset = selected?.version || '';
            const staleInstaller = Boolean(versionFromTag && versionFromAsset && compareVersionLike(versionFromAsset, versionFromTag) < 0);
            const warning = staleInstaller
                ? `Release latest apunta a tag ${versionFromTag}, pero el instalador publicado es ${versionFromAsset}.`
                : '';
            const payload = {
                version: versionFromTag || versionFromAsset || null,
                tagVersion: versionFromTag || null,
                assetVersion: versionFromAsset || null,
                installerUrl: exeAsset?.browser_download_url || '',
                installerSize: Number(exeAsset?.size || 0),
                installerAvailable: Boolean(exeAsset?.browser_download_url) && !staleInstaller,
                publishedAt: data.published_at || data.created_at || null,
                warning,
                checkedAt: now,
            };
            wildWeaponReleaseCache = payload;
            return payload;
        }

        async function fetchLatestSSARelease() {
            const now = Date.now();
            if (ssaReleaseCache && (now - ssaReleaseCache.checkedAt) < 120000) {
                return ssaReleaseCache;
            }

            const res = await fetch(SSA_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
            const scoredCandidates = exeCandidates.map((a) => ({
                asset: a,
                version: extractVersionFromText(a.name),
                updatedAtMs: Date.parse(a.updated_at || '') || 0,
                hasSSAName: /savage|space|animals|ssa/i.test(String(a.name || '')),
            }));

            scoredCandidates.sort((x, y) => {
                if (x.hasSSAName !== y.hasSSAName) return x.hasSSAName ? -1 : 1;
                const cmp = compareVersionLike(y.version, x.version);
                if (cmp !== 0) return cmp;
                return y.updatedAtMs - x.updatedAtMs;
            });
            let selected = scoredCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = scoredCandidates.find(c => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const exeAsset = selected?.asset || null;
            const versionFromAsset = selected?.version || '';
            const staleInstaller = Boolean(versionFromTag && versionFromAsset && compareVersionLike(versionFromAsset, versionFromTag) < 0);
            const warning = staleInstaller
                ? `Release latest apunta a tag ${versionFromTag}, pero el instalador publicado es ${versionFromAsset}.`
                : '';

            const payload = {
                version: versionFromTag || versionFromAsset || null,
                tagVersion: versionFromTag || null,
                assetVersion: versionFromAsset || null,
                installerUrl: exeAsset?.browser_download_url || '',
                installerSize: Number(exeAsset?.size || 0),
                installerAvailable: Boolean(exeAsset?.browser_download_url) && !staleInstaller,
                publishedAt: data.published_at || data.created_at || null,
                warning,
                checkedAt: now,
            };
            ssaReleaseCache = payload;
            return payload;
        }

        async function fetchLatestOceanPayRelease() {
            const now = Date.now();
            if (oceanPayProjectReleaseCache && (now - oceanPayProjectReleaseCache.checkedAt) < 120000) {
                return oceanPayProjectReleaseCache;
            }

            const res = await fetch(OCEAN_PAY_RELEASES_API_URL, {
                headers: { 'Accept': 'application/vnd.github+json' }
            });
            if (!res.ok) throw new Error(`GitHub API ${res.status}`);
            const data = await res.json();
            const assets = Array.isArray(data.assets) ? data.assets : [];
            const versionFromTag = String(data.tag_name || '').replace(/^v/i, '');
            const exeCandidates = assets.filter(a => typeof a?.name === 'string' && /\.exe$/i.test(a.name));
            const scoredCandidates = exeCandidates.map((a) => ({
                asset: a,
                version: extractVersionFromText(a.name),
                updatedAtMs: Date.parse(a.updated_at || '') || 0,
                hasOceanPayName: /ocean\s*pay|oceanpay/i.test(String(a.name || '')),
            }));

            scoredCandidates.sort((x, y) => {
                if (x.hasOceanPayName !== y.hasOceanPayName) return x.hasOceanPayName ? -1 : 1;
                const cmp = compareVersionLike(y.version, x.version);
                if (cmp !== 0) return cmp;
                return y.updatedAtMs - x.updatedAtMs;
            });
            let selected = scoredCandidates[0] || null;
            if (versionFromTag) {
                const tagMatch = scoredCandidates.find(c => c.version && compareVersionLike(c.version, versionFromTag) === 0);
                if (tagMatch) selected = tagMatch;
            }

            const exeAsset = selected?.asset || null;
            const versionFromAsset = selected?.version || '';
            const staleInstaller = Boolean(versionFromTag && versionFromAsset && compareVersionLike(versionFromAsset, versionFromTag) < 0);
            const warning = staleInstaller
                ? `Release latest apunta a tag ${versionFromTag}, pero el instalador publicado es ${versionFromAsset}.`
                : '';

            const payload = {
                version: versionFromTag || versionFromAsset || null,
                tagVersion: versionFromTag || null,
                assetVersion: versionFromAsset || null,
                installerUrl: exeAsset?.browser_download_url || '',
                installerSize: Number(exeAsset?.size || 0),
                installerAvailable: Boolean(exeAsset?.browser_download_url) && !staleInstaller,
                publishedAt: data.published_at || data.created_at || null,
                warning,
                checkedAt: now,
            };
            oceanPayProjectReleaseCache = payload;
            return payload;
        }

        async function fetchLatestAndroidReleaseFromStoreApi(slug, fallbackReleaseUrl = '') {
            const cacheBust = Date.now();
            const res = await fetch(`${OWS_STORE_ANDROID_API_BASE}/releases/${encodeURIComponent(slug)}/latest?nocache=${cacheBust}`);
            if (!res.ok) throw new Error(`OWS Android API ${res.status}`);
            const data = await res.json();
            const release = data?.release || null;
            if (!release) throw new Error('Release Android sin payload.');
            const proxyDownloadUrl = `${OWS_STORE_ANDROID_API_BASE}/releases/${encodeURIComponent(slug)}/latest/download?versionCode=${encodeURIComponent(release.version_code || 'latest')}&nocache=${cacheBust}`;
            return {
                version: release.version_name || '',
                versionCode: Number(release.version_code || 0),
                packageId: release.package_id || '',
                downloadUrl: release.apk_url ? proxyDownloadUrl : (fallbackReleaseUrl || ''),
                directDownloadUrl: release.apk_url || '',
                sizeBytes: Number(release.size_bytes || 0),
                sha256: release.sha256 || '',
                minStoreVersion: release.min_store_version || '',
                mandatory: Boolean(release.is_mandatory),
                notes: release.release_notes || '',
                publishedAt: release.published_at || null,
                source: 'ows-store-api',
                warning: release.apk_url ? '' : 'Release Android publicada sin apk_url.',
            };
        }

        async function fetchLatestFloretRelease() {
            const now = Date.now();
            if (floretProjectReleaseCache && (now - floretProjectReleaseCache.checkedAt) < 120000) {
                return floretProjectReleaseCache;
            }

            try {
                const latest = await fetchLatestAndroidReleaseFromStoreApi(FLORET_ANDROID_SLUG, FLORET_RELEASES_URL);
                const payload = {
                    version: latest.version || null,
                    installerUrl: '',
                    installerSize: 0,
                    installerAvailable: false,
                    androidApkUrl: latest.downloadUrl || '',
                    androidApkSize: Number(latest.sizeBytes || 0),
                    androidAabUrl: '',
                    androidAabSize: 0,
                    androidAvailable: Boolean(latest.downloadUrl),
                    releaseUrl: FLORET_RELEASES_URL,
                    publishedAt: latest.publishedAt || null,
                    warning: latest.warning || '',
                    checkedAt: now,
                };
                floretProjectReleaseCache = payload;
                return payload;
            } catch (err) {
                const fallback = {
                    version: null,
                    installerUrl: '',
                    installerSize: 0,
                    installerAvailable: false,
                    androidApkUrl: '',
                    androidApkSize: 0,
                    androidAabUrl: '',
                    androidAabSize: 0,
                    androidAvailable: false,
                    releaseUrl: FLORET_RELEASES_URL,
                    publishedAt: null,
                    warning: 'No se pudo resolver release Android desde OWS Store API.',
                    checkedAt: now,
                };
                floretProjectReleaseCache = fallback;
                return fallback;
            }
        }

        async function fetchLatestOWSStoreAndroidRelease() {
            const now = Date.now();
            if (owsStoreAndroidReleaseCache && (now - owsStoreAndroidReleaseCache.checkedAt) < 120000) {
                return owsStoreAndroidReleaseCache;
            }

            try {
                const latest = await fetchLatestAndroidReleaseFromStoreApi(OWS_STORE_ANDROID_SLUG, OWS_STORE_RELEASES_URL);
                const payload = {
                    version: latest.version || '',
                    downloadUrl: latest.downloadUrl || OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL,
                    sizeBytes: Number(latest.sizeBytes || 0),
                    publishedAt: latest.publishedAt || null,
                    source: latest.source || 'ows-store-api',
                    warning: latest.warning || '',
                    checkedAt: now
                };
                owsStoreAndroidReleaseCache = payload;
                return payload;
            } catch (err) {
                const fallback = {
                    version: '',
                    downloadUrl: OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL,
                    sizeBytes: 0,
                    publishedAt: null,
                    source: 'release-page',
                    warning: 'No se pudo resolver release Android desde OWS Store API.',
                    checkedAt: now
                };
                owsStoreAndroidReleaseCache = fallback;
                return fallback;
            }
        }

        function renderOWSStoreAndroidMeta() {
            const meta = document.getElementById('ows-android-release-meta');
            if (!meta) return;
            const versionText = owsStoreAndroidState.version ? `Tag ${owsStoreAndroidState.version}` : 'Tag sin resolver';
            const sizeText = owsStoreAndroidState.sizeBytes > 0 ? formatByteSize(owsStoreAndroidState.sizeBytes) : '-';
            const dateText = owsStoreAndroidState.publishedAt ? formatDateTime(owsStoreAndroidState.publishedAt) : 'sin fecha';
            const sourceText = owsStoreAndroidState.source === 'release-asset'
                ? 'source: release asset'
                : 'source: release page';
            const warningText = owsStoreAndroidState.warning ? ` | ${owsStoreAndroidState.warning}` : '';
            meta.textContent = `${versionText} | ${sizeText} | ${dateText} | ${sourceText}${warningText}`;
        }

        async function refreshStoreAndroidReleaseLink() {
            const payload = await fetchLatestOWSStoreAndroidRelease();
            owsStoreAndroidState.downloadUrl = payload?.downloadUrl || OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL;
            owsStoreAndroidState.version = payload?.version || '';
            owsStoreAndroidState.sizeBytes = Number(payload?.sizeBytes || 0);
            owsStoreAndroidState.publishedAt = payload?.publishedAt || null;
            owsStoreAndroidState.source = payload?.source || 'release-page';
            owsStoreAndroidState.warning = payload?.warning || '';
            renderOWSStoreAndroidMeta();
        }

        function formatDateTime(value) {
            if (!value) return 'Sin fecha';
            const d = new Date(value);
            if (Number.isNaN(d.getTime())) return 'Sin fecha';
            return d.toLocaleString();
        }

        function getProjectIcon(project, size = 64) {
            if (isWildWeaponProject(project)) return WILDWEAPON_LOCAL_ICON;
            if (isSSAProject(project)) return project?.icon_url || `https://placehold.co/${size}/0f172a/00f3ff?text=SSA`;
            if (isOceanPayProject(project)) return project?.icon_url || OCEAN_PAY_LOCAL_ICON;
            if (isFloretProject(project)) return project?.icon_url || FLORET_LOCAL_ICON || `https://placehold.co/${size}/2b0a45/f2a3ff?text=FLR`;
            return project?.icon_url || `https://placehold.co/${size}/0f172a/00f3ff?text=OWS`;
        }

        function isWildWeaponProject(project) {
            if (!project) return false;
            const slug = String(project.slug || '').toLowerCase();
            const name = String(project.name || '').toLowerCase();
            return slug.includes('wildweapon') || name.includes('wildweapon mayhem');
        }

        function getPlatformTokens(project) {
            const raw = [project?.platform, project?.platforms]
                .filter(Boolean)
                .join(',')
                .toLowerCase();
            return new Set(
                raw
                    .split(/[\s,;/|]+/)
                    .map((x) => x.trim())
                    .filter(Boolean)
            );
        }

        function supportsWindowsInstaller(project) {
            if (!project) return false;
            const tokens = getPlatformTokens(project);
            if (isWildWeaponProject(project) || isSSAProject(project) || isOceanPayProject(project)) return true;
            if (tokens.has('windows') || tokens.has('win')) return true;
            return Boolean(project.installer_url || project.release_url || project.windows_installer_url);
        }

        function supportsAndroidDownloads(project) {
            if (!project) return false;
            const tokens = getPlatformTokens(project);
            if (tokens.has('android')) return true;
            if (isFloretProject(project)) return true;
            return Boolean(project.android_apk_url || project.android_aab_url || project.android_release_url);
        }

        function getProjectInstallTargets(project) {
            if (!project) return [];
            const targets = [];
            if (supportsWindowsInstaller(project)) {
                const winUrl = getInstallerUrl(project);
                const winPending = project.pending_release || project.installer_available === false;
                targets.push({
                    id: 'windows',
                    kind: 'windows',
                    label: 'Windows (.exe)',
                    actionLabel: 'Instalar en Windows',
                    url: winUrl,
                    sizeBytes: Number(project.installer_size || 0),
                    version: project.version || '',
                    available: Boolean(winUrl) && !winPending,
                    pending: Boolean(winPending),
                });
            }

            if (supportsAndroidDownloads(project)) {
                const apkUrl = project.android_apk_url || '';
                targets.push({
                    id: 'android-apk',
                    kind: 'android',
                    label: 'Android (APK)',
                    actionLabel: 'Descargar APK',
                    url: apkUrl,
                    sizeBytes: Number(project.android_apk_size || 0),
                    version: project.android_version || project.version || '',
                    available: Boolean(apkUrl),
                    pending: !apkUrl,
                });
            }
            return targets;
        }

        function getSelectedInstallTarget(project) {
            const targets = getProjectInstallTargets(project);
            if (!targets.length) return null;
            const selectedId = selectedInstallTargetBySlug[project.slug];
            if (selectedId) {
                const selected = targets.find((t) => t.id === selectedId);
                if (selected) return selected;
            }
            return targets.find((t) => t.available) || targets[0];
        }

        function selectInstallTarget(slug, targetId) {
            selectedInstallTargetBySlug[slug] = targetId;
            openDetails(slug);
        }

        function getProjectPlatformLabel(project) {
            const targets = getProjectInstallTargets(project);
            const hasWin = targets.some((t) => t.kind === 'windows');
            const hasAndroid = targets.some((t) => t.kind === 'android');
            const anyAvailable = targets.some((t) => t.available);
            if (!anyAvailable && (project.pending_release || project.installer_available === false)) return 'PENDING RELEASE';
            if (hasWin && hasAndroid) return 'WIN + ANDROID';
            if (hasAndroid) return 'ANDROID';
            if (hasWin) return 'WINDOWS';
            return (project.status || 'launched').toUpperCase();
        }

        async function applyLatestInstallerData(projects) {
            if (!Array.isArray(projects)) return;
            const wildWeapon = projects.find(p => isWildWeaponProject(p));
            const ssa = projects.find(p => isSSAProject(p));
            const oceanPay = projects.find(p => isOceanPayProject(p));
            const floret = projects.find(p => isFloretProject(p));

            if (wildWeapon) {
                wildWeapon.platform = 'windows';
                wildWeapon.install_type = 'external';
                if (!wildWeapon.installer_url) wildWeapon.installer_url = WILDWEAPON_RELEASES_URL;
                wildWeapon.icon_url = WILDWEAPON_LOCAL_ICON;
                wildWeapon.installer_available = false;
                wildWeapon.last_update_at = null;
                wildWeapon.pending_release = false;
                wildWeapon.installer_size = Number(wildWeapon.installer_size || 0);

                try {
                    const latest = await fetchLatestWildWeaponRelease();
                    if (latest?.version) wildWeapon.version = latest.version;
                    if (latest?.installerUrl) wildWeapon.installer_url = latest.installerUrl;
                    wildWeapon.installer_size = Number(latest?.installerSize || 0);
                    wildWeapon.installer_available = Boolean(latest?.installerAvailable);
                    wildWeapon.last_update_at = latest?.publishedAt || null;
                    wildWeapon.pending_release = !wildWeapon.installer_available;
                    if (latest?.warning) {
                        wildWeapon.pending_release = true;
                        wildWeapon.release_warning = latest.warning;
                    } else {
                        wildWeapon.release_warning = '';
                    }
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de WildWeapon:', err?.message || err);
                    wildWeapon.pending_release = true;
                    wildWeapon.release_warning = 'No se pudo validar el instalador de la ultima release.';
                }
            }

            if (ssa) {
                ssa.platform = 'windows';
                ssa.install_type = 'external';
                if (!ssa.installer_url) ssa.installer_url = SSA_RELEASES_URL;
                ssa.icon_url = SSA_LOCAL_ICON;
                ssa.installer_available = false;
                ssa.last_update_at = null;
                ssa.pending_release = false;
                ssa.short = 'SSA';
                ssa.installer_size = Number(ssa.installer_size || 0);

                try {
                    const latest = await fetchLatestSSARelease();
                    if (latest?.version) ssa.version = latest.version;
                    if (latest?.installerUrl) ssa.installer_url = latest.installerUrl;
                    ssa.installer_size = Number(latest?.installerSize || 0);
                    ssa.installer_available = Boolean(latest?.installerAvailable);
                    ssa.last_update_at = latest?.publishedAt || null;
                    ssa.pending_release = !ssa.installer_available;
                    if (latest?.warning) {
                        ssa.pending_release = true;
                        ssa.release_warning = latest.warning;
                    } else {
                        ssa.release_warning = '';
                    }
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de SSA:', err?.message || err);
                    ssa.pending_release = true;
                    ssa.release_warning = 'No se pudo validar el instalador de la ultima release.';
                }
            }

            if (oceanPay) {
                oceanPay.platform = 'windows';
                oceanPay.install_type = 'external';
                if (!oceanPay.installer_url) oceanPay.installer_url = OCEAN_PAY_RELEASES_URL;
                oceanPay.icon_url = OCEAN_PAY_LOCAL_ICON;
                oceanPay.installer_available = false;
                oceanPay.last_update_at = null;
                oceanPay.pending_release = false;
                oceanPay.installer_size = Number(oceanPay.installer_size || 0);

                try {
                    const latest = await fetchLatestOceanPayRelease();
                    if (latest?.version) oceanPay.version = latest.version;
                    if (latest?.installerUrl) oceanPay.installer_url = latest.installerUrl;
                    oceanPay.installer_size = Number(latest?.installerSize || 0);
                    oceanPay.installer_available = Boolean(latest?.installerAvailable);
                    oceanPay.last_update_at = latest?.publishedAt || null;
                    oceanPay.pending_release = !oceanPay.installer_available;
                    if (latest?.warning) {
                        oceanPay.pending_release = true;
                        oceanPay.release_warning = latest.warning;
                    } else {
                        oceanPay.release_warning = '';
                    }
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de Ocean Pay:', err?.message || err);
                    oceanPay.pending_release = true;
                    oceanPay.release_warning = 'No se pudo validar el instalador de la ultima release.';
                }
            }

            if (floret) {
                floret.platform = 'android,windows';
                floret.install_type = 'external';
                if (!floret.android_release_url) floret.android_release_url = FLORET_RELEASES_URL;
                if (!floret.android_apk_url) floret.android_apk_url = '';
                floret.icon_url = floret.icon_url || FLORET_LOCAL_ICON;
                floret.installer_available = false;
                floret.android_available = false;
                floret.last_update_at = null;
                floret.pending_release = false;
                floret.installer_size = Number(floret.installer_size || 0);
                floret.android_apk_size = Number(floret.android_apk_size || 0);
                floret.android_aab_size = Number(floret.android_aab_size || 0);

                try {
                    const latest = await fetchLatestFloretRelease();
                    if (latest?.version) floret.version = latest.version;
                    if (latest?.installerUrl) floret.installer_url = latest.installerUrl;
                    if (latest?.releaseUrl) floret.android_release_url = latest.releaseUrl;
                    if (latest?.androidApkUrl) floret.android_apk_url = latest.androidApkUrl;
                    if (latest?.androidAabUrl) floret.android_aab_url = latest.androidAabUrl;
                    floret.installer_size = Number(latest?.installerSize || 0);
                    floret.installer_available = Boolean(latest?.installerAvailable);
                    floret.android_apk_size = Number(latest?.androidApkSize || 0);
                    floret.android_aab_size = Number(latest?.androidAabSize || 0);
                    floret.android_available = Boolean(latest?.androidAvailable || floret.android_apk_url || floret.android_aab_url);
                    floret.last_update_at = latest?.publishedAt || null;
                    floret.pending_release = !floret.installer_available && !floret.android_available;
                    floret.release_warning = latest?.warning || '';
                } catch (err) {
                    console.log('No se pudo resolver la ultima release de Floret Shop:', err?.message || err);
                    floret.pending_release = false;
                    floret.release_warning = 'No se pudo validar la release Android de Floret Shop.';
                }
            }
        }
        function isExternalInstallerProject(project) {
            if (!project) return false;
            return supportsWindowsInstaller(project) || supportsAndroidDownloads(project);
        }

        function getInstallerUrl(project) {
            if (!project) return '';
            if (project.installer_available === false) return '';
            if (project.installer_url) return project.installer_url;
            if (project.release_url) return project.release_url;
            if (isWildWeaponProject(project)) return WILDWEAPON_RELEASES_URL;
            if (isSSAProject(project)) return SSA_RELEASES_URL;
            if (isOceanPayProject(project)) return OCEAN_PAY_RELEASES_URL;
            if (isFloretProject(project)) return FLORET_RELEASES_URL;
            return '';
        }

        function openExternal(url) {
            if (!url) return;
            const isApkUrl = /\.apk(?:$|[?#])/i.test(String(url));
            const isNativeRuntime = Boolean(window.Capacitor?.isNativePlatform?.());
            if (isApkUrl && isNativeRuntime) {
                try {
                    const anchor = document.createElement('a');
                    anchor.href = url;
                    anchor.download = '';
                    anchor.rel = 'noopener noreferrer';
                    anchor.target = '_self';
                    document.body.appendChild(anchor);
                    anchor.click();
                    anchor.remove();
                    return;
                } catch (_) {
                    try {
                        window.location.assign(url);
                        return;
                    } catch (_) {}
                }
            }
            if (window.owsUpdater?.openExternalUrl) {
                window.owsUpdater.openExternalUrl(url);
                return;
            }
            window.open(url, '_blank', 'noopener,noreferrer');
        }

        function findWildWeaponProject() {
            return Array.isArray(allProjects) ? allProjects.find(p => isWildWeaponProject(p)) : null;
        }

        function getInstalledVersion(slug) {
            return localStorage.getItem(`installed_${slug}`) || '';
        }

        function getInstalledPlatform(slug) {
            return localStorage.getItem(`installed_platform_${slug}`) || '';
        }

        function getInstallHints(project) {
            const slug = String(project?.slug || '').toLowerCase();
            const name = String(project?.name || '').trim();
            const fallbackName = name || 'App';
            if (isWildWeaponProject(project)) {
                return {
                    installDirNames: ['WildWeapon Mayhem', 'wildweapon-mayhem'],
                    executableNames: ['WildWeapon Mayhem.exe', 'wildweapon-mayhem.exe'],
                    uninstallerNames: ['Uninstall WildWeapon Mayhem.exe', 'unins000.exe']
                };
            }
            if (isSSAProject(project)) {
                return {
                    installDirNames: ['Savage Space Animals', 'savagespaceanimals', 'savage-space-animals'],
                    executableNames: ['Savage Space Animals.exe', 'savagespaceanimals.exe', 'savage-space-animals.exe'],
                    uninstallerNames: ['Uninstall Savage Space Animals.exe', 'unins000.exe']
                };
            }
            if (isFloretProject(project)) {
                return {
                    installDirNames: ['Floret Shop', 'floretshop', 'floret-shop'],
                    executableNames: ['Floret Shop.exe', 'floretshop.exe', 'floret-shop.exe'],
                    uninstallerNames: ['Uninstall Floret Shop.exe', 'unins000.exe']
                };
            }
            return {
                installDirNames: [fallbackName, slug, fallbackName.replace(/\s+/g, '')],
                executableNames: [`${fallbackName}.exe`, `${slug}.exe`, `${fallbackName.replace(/\s+/g, '')}.exe`],
                uninstallerNames: [`Uninstall ${fallbackName}.exe`, 'unins000.exe']
            };
        }

        async function resolveInstalledApp(project) {
            if (!window.owsUpdater?.resolveInstalledApp) return { installed: false };
            const hints = getInstallHints(project);
            const result = await window.owsUpdater.resolveInstalledApp(hints);
            return result || { installed: false };
        }

        async function refreshInstallationStates() {
            const next = {};
            for (const p of allProjects) {
                const marker = getInstalledVersion(p.slug);
                const runtime = getRuntimeState(p.slug);
                const installingRuntime = ['queued', 'waiting', 'preparing', 'downloading', 'launching'].includes(runtime.phase);
                const suppressed = uninstallSuppressedBySlug[p.slug] === true;
                if (isExternalInstallerProject(p)) {
                    try {
                        const detected = await resolveInstalledApp(p);
                        const installedBySystem = Boolean(detected?.installed || marker);
                        const installed = installingRuntime ? true : (suppressed ? false : installedBySystem);
                        if (!installed && suppressed) uninstallSuppressedBySlug[p.slug] = false;
                        next[p.slug] = {
                            installed,
                            version: marker || '',
                            exePath: detected?.exePath || '',
                            uninstallPath: detected?.uninstallPath || '',
                            installDir: detected?.installDir || '',
                            runtime,
                        };
                    } catch (_) {
                        const installed = installingRuntime ? true : (suppressed ? false : Boolean(marker));
                        next[p.slug] = { installed, version: marker || '', runtime };
                    }
                } else {
                    const installed = suppressed ? false : Boolean(marker);
                    next[p.slug] = { installed, version: marker || '', runtime };
                }
            }
            installStateBySlug = next;
        }

        async function openWildWeaponAction(event) {
            if (event && typeof event.preventDefault === 'function') event.preventDefault();
            const p = findWildWeaponProject();
            if (!p) {
                addNotification('WildWeapon Mayhem no esta disponible en el listado actual.', 'warning');
                showActionMessage('WildWeapon Mayhem no esta disponible en el listado actual.');
                return;
            }
            openDetails(p.slug);
        }

        function renderProjects(projects) {
            const container = document.getElementById('projects-container');
            container.innerHTML = '';
            if (!projects.length) {
                container.innerHTML = `<p style="color:var(--text-dim)">No hay resultados para tu busqueda/filtro.</p>`;
                return;
            }
            projects.forEach(p => {
                const card = document.createElement('div');
                card.className = 'app-card ecosystem-row';
                card.onclick = () => openDetails(p.slug);
                const isComingSoon = p.status === 'coming_soon';
                const runtime = getRuntimeState(p.slug);
                const isInstalling = isInstallingPhase(runtime.phase);
                const isQueued = runtime.phase === 'queued';
                const isPreparing = runtime.phase === 'preparing';
                const availabilityLabel = getProjectPlatformLabel(p);
                const short = getProjectShort(p);
                const updateHint = (isWildWeaponProject(p) || isSSAProject(p) || isOceanPayProject(p) || isFloretProject(p))
                    ? (p.last_update_at ? `Ultima actualizacion: ${formatDateTime(p.last_update_at)}` : 'Ultima actualizacion: pendiente')
                    : (p.description || 'Proyecto oficial del ecosistema Ocean and Wild Studios.');
                const updateInfoHtml = (isWildWeaponProject(p) || isSSAProject(p) || isOceanPayProject(p) || isFloretProject(p))
                    ? `<div class="ecosystem-submeta">${updateHint}</div>`
                    : '';
                const installingHtml = `
                    <div id="installing-text-${p.slug}" class="ecosystem-submeta" style="color:var(--brand-2); display:${(isInstalling || isQueued || isPreparing) ? 'block' : 'none'};">
                        ${isQueued ? 'En cola para descarga...' : (isPreparing ? 'Preparando instalador...' : (isInstalling ? `Instalando: ${Math.round(runtime.percent || 0)}%` : ''))}
                    </div>
                `;
                const countdownHtml = (isComingSoon && p.release_date)
                    ? `<span class="countdown" data-date="${p.release_date}">Cargando...</span>`
                    : `<span>${p.pending_release ? 'Esperando release' : 'Disponible'}</span>`;
                card.innerHTML = `
                    <div class="progress-overlay" id="loader-${p.slug}">
                        <div style="font-weight: 800; font-size: 0.8rem;">INSTALANDO...</div>
                        <div class="progress-bar-container"><div class="progress-fill" id="fill-${p.slug}"></div></div>
                    </div>
                    <img src="${getProjectIcon(p, 64)}" class="app-icon" alt="Icon">
                    <div class="ecosystem-main">
                        <div class="ecosystem-topline">
                            <div class="app-name">${p.name}${short ? ` <span style="font-size:0.72rem;color:var(--brand-2);">(${short})</span>` : ''}</div>
                            <span class="ecosystem-platform">${availabilityLabel}</span>
                        </div>
                        <div class="app-meta"><span>v${p.version || '1.0.0'}</span>${countdownHtml}</div>
                        ${updateInfoHtml || `<div class="ecosystem-submeta">${updateHint}</div>`}
                        ${installingHtml}
                    </div>
                    <button class="btn-install ecosystem-open-btn" onclick="event.stopPropagation(); openDetails('${p.slug}')">
                        <i class="fas fa-circle-info"></i> Ver ficha
                    </button>
                `;
                container.appendChild(card);
            });
            startCountdowns();
        }

        function renderLibrary() {
            const container = document.getElementById('library-container');
            if (!container) return;
            container.innerHTML = '';
            const installedProjects = allProjects.filter((p) => Boolean(installStateBySlug[p.slug]?.installed));
            if (!installedProjects.length) {
                container.innerHTML = `<p style="color:var(--text-dim)">No tienes proyectos instalados aun.</p>`;
                return;
            }

            installedProjects.forEach((p) => {
                const state = installStateBySlug[p.slug] || {};
                const runtime = getRuntimeState(p.slug);
                const isDownloading = isInstallingPhase(runtime.phase);
                const isQueued = runtime.phase === 'queued';
                const isPreparing = runtime.phase === 'preparing';
                const updateInfo = getProjectUpdateInfo(p);
                const card = document.createElement('div');
                card.className = 'app-card';
                const metaVersion = state.version || p.version || '1.0.0';
                const installDate = (isWildWeaponProject(p) || isSSAProject(p) || isOceanPayProject(p) || isFloretProject(p)) && p.last_update_at ? formatDateTime(p.last_update_at) : 'Sin datos';
                const installedPlatform = getInstalledPlatform(p.slug);
                const openLabel = installedPlatform === 'android' ? 'Abrir APK' : 'Abrir';
                const statusLabel = isQueued
                    ? 'EN COLA'
                    : (isPreparing ? 'PREPARANDO' : (isDownloading ? `DESCARGANDO ${Math.round(runtime.percent || 0)}%` : 'INSTALADO'));
                const progressHtml = `
                    <div id="lib-progress-${p.slug}" class="progress-bar-container" style="margin-bottom:0.8rem; display:${isDownloading ? 'block' : 'none'};">
                        <div id="lib-fill-${p.slug}" class="progress-fill" style="width:${Math.round(runtime.percent || 0)}%"></div>
                    </div>
                `;
                const actionsHtml = (isDownloading || isPreparing || isQueued)
                    ? `<div class="library-actions">
                        <button class="btn-install full" style="background:#b96700;" onclick="cancelInstallFromLibrary('${p.slug}')"><i class="fas fa-ban"></i> Cancelar instalacion</button>
                    </div>`
                    : `<div class="library-actions">
                        <button class="btn-install" onclick="launchFromLibrary('${p.slug}')"><i class="fas fa-play"></i> ${openLabel}</button>
                        <button class="btn-install" style="background:linear-gradient(90deg,var(--brand-2),#2aa0a6);" onclick="reinstallFromLibrary('${p.slug}')"><i class="fas fa-rotate"></i> ${updateInfo.needsUpdate ? 'Actualizar' : 'Reinstalar'}</button>
                        <button class="btn-install full" style="background:#2b2e37;" onclick="uninstallFromLibrary('${p.slug}')"><i class="fas fa-trash"></i> Desinstalar</button>
                    </div>`;
                const updateBadgeHtml = updateInfo.needsUpdate
                    ? `<div style="font-size:0.74rem; color:var(--brand-2); margin-bottom:0.8rem; font-weight:700;">Actualizacion disponible: v${updateInfo.latestVersion}</div>`
                    : '';
                card.innerHTML = `
                    <img src="${getProjectIcon(p, 64)}" class="app-icon" alt="Icon">
                    <div class="app-name">${p.name}</div>
                    <div class="app-meta"><span>v${metaVersion}</span><span id="lib-status-${p.slug}">${statusLabel}</span></div>
                    <div style="font-size:0.74rem; color:var(--ink-soft); margin-bottom:0.8rem;">Ult. update: ${installDate}</div>
                    ${updateBadgeHtml}
                    ${progressHtml}
                    ${actionsHtml}
                `;
                container.appendChild(card);
            });
        }

        function openDetails(slug) {
            const p = allProjects.find(pro => pro.slug === slug);
            if (!p) return;
            document.getElementById('m-title').innerText = getProjectShort(p) ? `${p.name} (${getProjectShort(p)})` : p.name;
            document.getElementById('m-desc').innerText = p.description || "Explora una nueva dimension de entretenimiento con este proyecto oficial de Ocean and Wild Studios.";
            if (isWildWeaponProject(p) || isSSAProject(p) || isOceanPayProject(p) || isFloretProject(p)) {
                const statusText = p.pending_release
                    ? (p.release_warning || 'Pendiente de publicacion en Releases')
                    : `Ultima actualizacion: ${formatDateTime(p.last_update_at)}`;
                document.getElementById('m-desc').innerText += `\n\n${statusText}.`;
            }
            document.getElementById('m-version').innerText = p.version || '1.0.0';
            document.getElementById('m-status').innerText = (isWildWeaponProject(p) || isSSAProject(p) || isOceanPayProject(p) || isFloretProject(p))
                ? (p.pending_release ? 'PENDING RELEASE' : 'READY TO INSTALL')
                : (p.status || 'launched').toUpperCase();
            document.getElementById('m-icon').src = getProjectIcon(p, 140);
            document.getElementById('m-banner').style.backgroundImage = `url(${p.banner_url || 'https://images.unsplash.com/photo-1614850523296-d8c1af93d400?auto=format&fit=crop&q=80&w=800'})`;

            const targets = getProjectInstallTargets(p);
            const selectedTarget = getSelectedInstallTarget(p);
            if (selectedTarget) selectedInstallTargetBySlug[p.slug] = selectedTarget.id;
            const platformsWrap = document.getElementById('m-platforms');
            const platformOptions = document.getElementById('m-platform-options');
            const platformMeta = document.getElementById('m-platform-meta');
            if (platformsWrap && platformOptions && platformMeta) {
                if (targets.length > 1) {
                    platformOptions.innerHTML = targets.map((t) => `
                        <button class="platform-pill ${selectedTarget?.id === t.id ? 'active' : ''} ${t.available ? '' : 'is-disabled'}"
                                onclick="event.stopPropagation(); selectInstallTarget('${p.slug}', '${t.id}')">
                            ${t.label}
                        </button>
                    `).join('');
                    const sizeLabel = selectedTarget?.sizeBytes > 0 ? formatByteSize(selectedTarget.sizeBytes) : '-';
                    const versionLabel = selectedTarget?.version ? `v${selectedTarget.version}` : 'sin version';
                    const stateLabel = selectedTarget?.available ? 'Disponible' : 'Pendiente';
                    platformMeta.textContent = `${selectedTarget?.label || 'Target'} | ${stateLabel} | Tamano ${sizeLabel} | ${versionLabel}`;
                    platformsWrap.style.display = 'block';
                } else if (targets.length === 1) {
                    const t = targets[0];
                    platformOptions.innerHTML = '';
                    const sizeLabel = t?.sizeBytes > 0 ? formatByteSize(t.sizeBytes) : '-';
                    const versionLabel = t?.version ? `v${t.version}` : 'sin version';
                    const stateLabel = t?.available ? 'Disponible' : 'Pendiente';
                    platformMeta.textContent = `${t.label} | ${stateLabel} | Tamano ${sizeLabel} | ${versionLabel}`;
                    platformsWrap.style.display = 'block';
                } else {
                    platformOptions.innerHTML = '';
                    platformMeta.textContent = '';
                    platformsWrap.style.display = 'none';
                }
            }

            const actions = document.getElementById('m-actions');
            actions.innerHTML = '';
            const isComingSoon = p.status === 'coming_soon';
            const state = installStateBySlug[p.slug] || {};
            const installedV = state.version || localStorage.getItem(`installed_${p.slug}`);
            const isExternal = isExternalInstallerProject(p);
            const busy = isBusyInstalling(p.slug);
            const phase = getRuntimeState(p.slug).phase;
            const updateInfo = getProjectUpdateInfo(p);
            const selectedIsAndroid = selectedTarget?.kind === 'android';
            const selectedIsWindows = !selectedTarget || selectedTarget.kind === 'windows';

            let btnText = '<i class="fas fa-download"></i> INSTALAR PROYECTO';
            let btnClass = 'btn-install';
            if (isComingSoon) { btnText = 'PROXIMAMENTE'; btnClass += ' coming-soon'; }
            else if (busy) {
                if (phase === 'queued' || phase === 'waiting') btnText = '<i class="fas fa-list"></i> EN COLA...';
                else if (phase === 'preparing') btnText = '<i class="fas fa-gear"></i> PREPARANDO...';
                else btnText = '<i class="fas fa-spinner"></i> INSTALANDO...';
                btnClass += ' unavailable';
            }
            else if (isExternal) {
                if (selectedIsAndroid) {
                    if (!selectedTarget?.available || !selectedTarget?.url) {
                        btnText = '<i class="fas fa-clock"></i> APK PENDIENTE';
                        btnClass += ' unavailable';
                    } else {
                        btnText = '<i class="fas fa-mobile-screen-button"></i> DESCARGAR APK';
                    }
                } else if (selectedIsWindows) {
                    if (p.pending_release || p.installer_available === false) {
                        btnText = '<i class="fas fa-clock"></i> PENDIENTE DE RELEASE';
                        btnClass += ' unavailable';
                    } else if (updateInfo.needsUpdate) btnText = '<i class="fas fa-arrow-up"></i> ACTUALIZAR A v' + (p.version || 'latest');
                    else if (state.installed || installedV) btnText = '<i class="fas fa-rotate"></i> VER ULTIMA VERSION';
                    else btnText = '<i class="fas fa-download"></i> INSTALAR PROYECTO';
                }
            } else if (installedV) {
                if (updateInfo.needsUpdate) btnText = '<i class="fas fa-arrow-up"></i> ACTUALIZAR A v' + p.version;
                else btnText = '<i class="fas fa-play"></i> JUGAR AHORA';
            }

            const btn = document.createElement('button');
            btn.className = btnClass;
            btn.innerHTML = btnText;
            btn.onclick = async (e) => { closeDetails(); await handleProjectAction(e, p); };
            actions.appendChild(btn);
            if (busy) {
                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'btn-install';
                cancelBtn.style.marginTop = '0.6rem';
                cancelBtn.style.background = '#b96700';
                cancelBtn.innerHTML = '<i class="fas fa-ban"></i> CANCELAR INSTALACION';
                cancelBtn.onclick = async () => { closeDetails(); await cancelInstallFromLibrary(p.slug); };
                actions.appendChild(cancelBtn);
            }
            document.getElementById('details-modal').classList.add('active');
        }

        function closeDetails() { document.getElementById('details-modal').classList.remove('active'); }

        async function handleProjectAction(e, project) {
            e.stopPropagation();
            if (!project) return;
            uninstallSuppressedBySlug[project.slug] = false;
            if (isExternalInstallerProject(project) && (isProjectQueued(project.slug) || activeInstallTaskKey === getDownloadKeyForProject(project))) {
                addNotification(project.name + ' ya esta en cola de descarga.', 'warning');
                showActionMessage(project.name + ' ya esta en cola de descarga.', { state: 'info' });
                return;
            }
            if (isBusyInstalling(project.slug)) {
                addNotification('Ya hay una instalacion en curso para ' + project.name + '.', 'warning');
                showActionMessage('Instalacion en curso para ' + project.name + '.');
                return;
            }
            if (project.status === 'coming_soon') {
                addNotification(project.name + ' aun no esta disponible.', 'warning');
                showActionMessage(project.name + ' aun no esta disponible.');
                return;
            }
            const installedV = localStorage.getItem(`installed_${project.slug}`);
            const selectedTarget = getSelectedInstallTarget(project);
            if (isExternalInstallerProject(project)) {
                if (selectedTarget?.kind === 'android') {
                    if (!selectedTarget.url) {
                        const warningText = `No hay enlace de descarga ${selectedTarget.label} para ${project.name}.`;
                        addNotification(warningText, 'warning');
                        showActionMessage(warningText);
                        return;
                    }
                    const updatesStatus = document.getElementById('updates-project-status');
                    if (updatesStatus) updatesStatus.textContent = 'Descargando APK de ' + project.name + '...';
                    addNotification('Iniciando instalacion Android de ' + project.name + '...', 'neutral');
                    showActionMessage('Agregando ' + project.name + ' a la cola de instalacion Android...', { state: 'info' });
                    const queueKey = getDownloadKeyForProject(project);
                    const safeBaseName = String(project.name || 'android-app').replace(/[^\w.\-]+/g, '-').replace(/-+/g, '-');
                    const safeVersion = String(selectedTarget.version || project.version || 'latest').replace(/[^\w.\-]+/g, '-').replace(/-+/g, '-');
                    const queueItem = {
                        key: queueKey,
                        slug: project.slug,
                        platform: 'android',
                        url: selectedTarget.url,
                        fileName: `${safeBaseName}-${safeVersion}.apk`,
                        targetLabel: selectedTarget.label || 'Android (APK)',
                        sizeBytes: Number(selectedTarget.sizeBytes || project.android_apk_size || 0),
                        versionName: selectedTarget.version || project.version || 'latest',
                        versionCode: Number(project.android_version_code || 0),
                    };
                    projectInstallQueue.push(queueItem);
                    setRuntimeState(project.slug, { phase: 'queued', percent: 0, taskId: `install_${project.slug}` });
                    updateDownloadSession(queueKey, {
                        name: project.name,
                        slug: project.slug,
                        icon: getProjectIcon(project, 64),
                        phase: 'queued',
                        percent: 0,
                        status: 'En cola para descargar APK...',
                        sizeBytes: Number(queueItem.sizeBytes || 0),
                        isApp: false,
                    });
                    scheduleSectionRender({ projects: true, library: true, immediate: false });
                    syncQueueMarkers();
                    processProjectInstallQueue();
                    return;
                }

                setRuntimeState(project.slug, { phase: 'queued', percent: 0, taskId: `install_${project.slug}` });
                scheduleSectionRender({ projects: true, library: true, immediate: false });
                showActionMessage('Validando release de ' + project.name + '...', { state: 'checking' });
                if (isWildWeaponProject(project) || isSSAProject(project) || isOceanPayProject(project) || isFloretProject(project)) {
                    const refreshRelease = async () => {
                        const latest = isWildWeaponProject(project)
                            ? await fetchLatestWildWeaponRelease()
                            : (isSSAProject(project)
                                ? await fetchLatestSSARelease()
                                : (isOceanPayProject(project)
                                    ? await fetchLatestOceanPayRelease()
                                    : await fetchLatestFloretRelease()));
                        if (latest?.version) project.version = latest.version;
                        if (latest?.installerUrl) project.installer_url = latest.installerUrl;
                        project.installer_size = Number(latest?.installerSize || 0);
                        project.installer_available = Boolean(latest?.installerAvailable);
                        if (latest?.androidApkUrl) project.android_apk_url = latest.androidApkUrl;
                        if (latest?.androidAabUrl) project.android_aab_url = latest.androidAabUrl;
                        project.android_apk_size = Number(latest?.androidApkSize || 0);
                        project.android_aab_size = Number(latest?.androidAabSize || 0);
                        project.android_available = Boolean(latest?.androidAvailable || project.android_apk_url || project.android_aab_url);
                        project.last_update_at = latest?.publishedAt || null;
                        project.pending_release = !project.installer_available && !project.android_available;
                        project.release_warning = latest?.warning || '';
                    };
                    const requiresBlockingRefresh = !project.installer_url || project.installer_available === false || project.pending_release;
                    if (requiresBlockingRefresh) {
                        try {
                            await refreshRelease();
                        } catch (err) {
                            console.log('No se pudo actualizar metadata release externa:', err?.message || err);
                            addNotification(`No se pudo resolver la ultima release de ${project.name}.`, 'warning');
                            project.pending_release = true;
                            project.release_warning = 'No se pudo validar el instalador de la ultima release.';
                        }
                    } else {
                        refreshRelease()
                            .then(() => scheduleSectionRender({ projects: true, library: true, immediate: false }))
                            .catch((err) => console.log('Refresh release en background fallo:', err?.message || err));
                    }
                }
                const installerUrl = getInstallerUrl(project);
                if (!installerUrl) {
                    const updatesStatus = document.getElementById('updates-project-status');
                    if (updatesStatus) updatesStatus.textContent = 'Pendiente: instalador no publicado';
                    const warningText = project.release_warning || `${project.name} todavia no tiene instalador publicado en Releases.`;
                    addNotification(warningText, 'warning');
                    showActionMessage(warningText);
                    return alert(warningText);
                }
                const updatesStatus = document.getElementById('updates-project-status');
                if (updatesStatus) updatesStatus.textContent = 'Descargando instalador de ' + project.name + '...';
                addNotification('Iniciando instalacion de ' + project.name + '...', 'neutral');
                showActionMessage('Agregando ' + project.name + ' a la cola de instalacion...', { state: 'info' });
                const queueKey = getDownloadKeyForProject(project);
                const queueItem = {
                    key: queueKey,
                    slug: project.slug,
                    url: installerUrl,
                    fileName: `${project.name || 'installer'}-${project.version || 'latest'}.exe`,
                    sizeBytes: Number(project.installer_size || 0),
                };
                projectInstallQueue.push(queueItem);
                setRuntimeState(project.slug, { phase: 'queued', percent: 0, taskId: `install_${project.slug}` });
                updateDownloadSession(queueKey, {
                    name: project.name,
                    slug: project.slug,
                    icon: getProjectIcon(project, 64),
                    phase: 'queued',
                    percent: 0,
                    status: 'En cola para descarga...',
                    sizeBytes: Number(project.installer_size || 0),
                    isApp: false,
                });
                scheduleSectionRender({ projects: true, library: true, immediate: false });
                syncQueueMarkers();
                processProjectInstallQueue();
                return;
            }
            if (installedV === project.version) launchGame(project.url);
            else simulateInstall(project.slug, project.version);
        }

        async function launchFromLibrary(slug) {
            const project = allProjects.find((p) => p.slug === slug);
            if (!project) return;
            if (isExternalInstallerProject(project)) {
                const state = installStateBySlug[slug] || {};
                const installedPlatform = getInstalledPlatform(slug);
                const androidTarget = getProjectInstallTargets(project).find((t) => t.id === 'android-apk' && t.url);
                const shouldUseAndroid = installedPlatform === 'android' || (!state.exePath && Boolean(androidTarget));
                if (shouldUseAndroid) {
                    if (!androidTarget?.url) {
                        addNotification('No se encontro APK para ' + project.name + '.', 'warning');
                        showActionMessage('No se encontro APK para ' + project.name + '.');
                        return;
                    }
                    if (window.owsUpdater?.installExternalInstaller) {
                        await handleProjectAction({ stopPropagation: () => {} }, project);
                        return;
                    }
                    openExternal(androidTarget.url);
                    addNotification('Abriendo APK de ' + project.name + '...', 'neutral');
                    showActionMessage('Abriendo APK de ' + project.name + '...', { state: 'info' });
                    return;
                }
                if (!state.exePath) {
                    addNotification('No se encontro ejecutable instalado para ' + project.name + '.', 'warning');
                    showActionMessage('No se encontro ejecutable instalado para ' + project.name + '.');
                    return;
                }
                const result = await window.owsUpdater?.launchInstalledApp?.({ exePath: state.exePath });
                if (!result?.ok) {
                    addNotification('No se pudo abrir ' + project.name + ': ' + (result?.error || 'desconocido'), 'error');
                    return;
                }
                addNotification('Abriendo ' + project.name + '...', 'success');
                return;
            }
            launchGame(project.url);
        }

        async function reinstallFromLibrary(slug) {
            const project = allProjects.find((p) => p.slug === slug);
            if (!project) return;
            await handleProjectAction({ stopPropagation: () => {} }, project);
        }

        async function cancelInstallFromLibrary(slug) {
            const runtime = getRuntimeState(slug);
            const taskId = runtime.taskId || `install_${slug}`;
            const project = allProjects.find((p) => p.slug === slug);
            const key = `project_${slug}`;
            const queuedIdx = projectInstallQueue.findIndex((item) => item.slug === slug);
            if (queuedIdx >= 0) {
                projectInstallQueue.splice(queuedIdx, 1);
                updateDownloadSession(key, { phase: 'cancelled', status: 'Descarga retirada de la cola.' });
                setRuntimeState(slug, { phase: 'idle', percent: 0, taskId: '' });
                syncQueueMarkers();
                await refreshInstallationStates();
                scheduleSectionRender({ projects: true, library: true, immediate: true });
                if (project) {
                    addNotification('Instalacion cancelada para ' + project.name + '.', 'warning');
                    showActionMessage('Instalacion cancelada para ' + project.name + '.', { state: 'info' });
                }
                return;
            }
            if (window.owsUpdater?.cancelExternalInstaller) {
                await window.owsUpdater.cancelExternalInstaller({ taskId });
            }
            setRuntimeState(slug, { phase: 'idle', percent: 0, taskId: '' });
            updateDownloadSession(key, { phase: 'cancelled', status: 'Instalacion cancelada por el usuario.' });
            await refreshInstallationStates();
            scheduleSectionRender({ projects: true, library: true, immediate: true });
            if (project) {
                addNotification('Instalacion cancelada para ' + project.name + '.', 'warning');
                showActionMessage('Instalacion cancelada para ' + project.name + '.');
            }
        }

        async function uninstallFromLibrary(slug) {
            const project = allProjects.find((p) => p.slug === slug);
            if (!project) return;
            uninstallSuppressedBySlug[slug] = true;
            localStorage.removeItem(`installed_${slug}`);
            localStorage.removeItem(`installed_platform_${slug}`);
            localStorage.removeItem(`installed_version_code_${slug}`);
            installStateBySlug[slug] = { ...(installStateBySlug[slug] || {}), installed: false, version: '' };
            scheduleSectionRender({ projects: true, library: true, immediate: true });
            const state = installStateBySlug[slug] || {};
            if (isExternalInstallerProject(project) && state.uninstallPath) {
                const result = await window.owsUpdater?.uninstallInstalledApp?.({ uninstallPath: state.uninstallPath });
                if (!result?.ok) {
                    uninstallSuppressedBySlug[slug] = false;
                    addNotification('No se pudo abrir desinstalador: ' + (result?.error || 'desconocido'), 'error');
                    await refreshInstallationStates();
                    scheduleSectionRender({ projects: true, library: true, immediate: true });
                    return;
                }
                addNotification('Desinstalador iniciado para ' + project.name + '.', 'neutral');
                await refreshInstallationStates();
                scheduleSectionRender({ projects: true, library: true, immediate: true });
                return;
            }
            await refreshInstallationStates();
            scheduleSectionRender({ projects: true, library: true, immediate: true });
            addNotification(project.name + ' removido de Biblioteca.', 'neutral');
        }

        function launchGame(url) {
            document.body.classList.add('no-scroll');
            document.getElementById('game-overlay').style.display = 'flex';
            document.getElementById('game-frame').src = url || 'about:blank';
        }

        function closeGame() {
            document.getElementById('game-overlay').style.display = 'none';
            document.getElementById('game-frame').src = 'about:blank';
            document.body.classList.remove('no-scroll');
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        function simulateInstall(slug, version) {
            const overlay = document.getElementById(`loader-${slug}`);
            const fill = document.getElementById(`fill-${slug}`);
            if (!overlay) return;
            overlay.style.display = 'flex';
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        localStorage.setItem(`installed_${slug}`, version);
                        overlay.style.display = 'none';
                        loadProjects();
                    }, 500);
                }
                if (fill) fill.style.width = progress + '%';
            }, 300);
        }

        function startCountdowns() {
            setInterval(() => {
                document.querySelectorAll('.countdown').forEach(el => {
                    const target = new Date(el.dataset.date).getTime();
                    const diff = target - Date.now();
                    if (diff <= 0) { el.innerText = "DISPONIBLE!"; el.style.color = "var(--success)"; return; }
                    const d = Math.floor(diff / 86400000), h = Math.floor((diff % 86400000) / 3600000), m = Math.floor((diff % 3600000) / 60000), s = Math.floor((diff % 60000) / 1000);
                    el.innerText = `${d}d ${h}h ${m}m ${s}s`;
                });
            }, 1000);
        }

        function showSection(id, triggerEl = null) {
            activeSection = id;
            document.querySelectorAll('main section').forEach(s => s.style.display = 'none');
            const target = document.getElementById(`${id}-view`);
            if (!target) return;
            target.style.display = 'block';
            document.querySelectorAll('.nav-menu .nav-item').forEach(i => i.classList.remove('active'));
            if (triggerEl) triggerEl.classList.add('active');
            if (id === 'library') {
                refreshInstallationStates().then(() => scheduleSectionRender({ projects: true, library: true, immediate: true }));
            }
            if (id === 'updates') {
                renderDownloadSurfaces();
            }
        }

        function initUpdater() {
            if (typeof window.owsUpdater === 'undefined') return;
            const isExternalInstallActive = () => Boolean(activeInstallTaskKey && activeInstallTaskKey !== STORE_DOWNLOAD_KEY);
            window.owsUpdater.getAppVersion?.().then(v => {
                const el = document.getElementById('app-version');
                if (el) el.textContent = 'v' + v;
                const updatesVersion = document.getElementById('updates-app-version');
                if (updatesVersion) updatesVersion.textContent = 'v' + v;
            });
            const banner = document.getElementById('update-banner');
            const btn = document.getElementById('btn-install-update');
            const wrap = document.getElementById('update-progress-wrap');
            const fill = document.getElementById('update-progress-fill');
            const closeBtn = document.getElementById('btn-close-update-banner');
            const status = document.getElementById('updates-status');
            if (fill) fill.style.width = '0%';
            if (wrap) wrap.style.display = 'none';
            if (btn) btn.style.display = 'none';
            if (closeBtn) {
                closeBtn.disabled = true;
                closeBtn.style.opacity = '0.45';
                closeBtn.style.cursor = 'not-allowed';
            }
            setUpdateBannerVisual({
                state: 'checking',
                title: 'Buscando updates',
                message: 'Comprobando nuevas versiones de OWS Store...',
                iconClass: 'fa-magnifying-glass',
                iconSpin: true,
                meta: 'Tamano: - | ETA: -'
            });
            updateDownloadSession(STORE_DOWNLOAD_KEY, {
                name: 'OWS Store',
                icon: STORE_LOCAL_ICON,
                isApp: true,
                phase: 'checking',
                percent: 0,
                status: 'Verificando disponibilidad de update...',
                sizeBytes: 0,
                downloadedBytes: 0,
                speedBps: 0,
                etaSeconds: null,
            });
            if (banner) banner.classList.add('visible');
            if (status) status.textContent = 'Buscando actualizaciones...';
            setUpdateMetaUI({ sizeBytes: 0, etaSeconds: null, transferredBytes: null, speedBps: 0 });
            addNotification('Buscando actualizaciones de OWS Store...', 'neutral');
            window.owsUpdater.onUpdateAvailable?.((info) => {
                const banner = document.getElementById('update-banner');
                const msg = document.getElementById('update-msg');
                const btn = document.getElementById('btn-install-update');
                const dot = document.getElementById('update-indicator-dot');
                const closeBtn = document.getElementById('btn-close-update-banner');
                appUpdateSizeBytes = extractUpdateSizeBytes(info);
                appUpdateEtaSeconds = null;
                if (!isExternalInstallActive()) {
                    if (msg) msg.textContent = 'Version ' + (info?.version || 'nueva') + ' disponible. Descargando...';
                    if (banner) banner.classList.add('visible');
                    if (btn) btn.style.display = 'none';
                    if (closeBtn) {
                        closeBtn.disabled = true;
                        closeBtn.style.opacity = '0.45';
                        closeBtn.style.cursor = 'not-allowed';
                    }
                }
                if (dot) dot.style.display = 'block';
                appUpdateAvailable = true;
                syncUpdatesBadge();
                if (status) status.textContent = 'Descargando update v' + (info?.version || 'nueva');
                if (!isExternalInstallActive()) {
                    setUpdateBannerVisual({
                        state: 'available',
                        title: 'Actualizacion disponible',
                        message: 'Version ' + (info?.version || 'nueva') + ' detectada. Iniciando descarga...',
                        iconClass: 'fa-arrow-up',
                        iconSpin: false,
                    });
                }
                setUpdateMetaUI({ sizeBytes: appUpdateSizeBytes, etaSeconds: null, transferredBytes: 0, speedBps: 0 });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    phase: 'available',
                    percent: 0,
                    sizeBytes: appUpdateSizeBytes,
                    downloadedBytes: 0,
                    speedBps: 0,
                    etaSeconds: null,
                    status: 'Update detectada: v' + (info?.version || 'nueva'),
                });
                const sizeLabel = formatByteSize(appUpdateSizeBytes);
                addNotification('Actualizacion encontrada: v' + (info?.version || 'nueva') + (sizeLabel !== '-' ? ` (${sizeLabel})` : '') + '.', 'success');
            });
            window.owsUpdater.onDownloadProgress?.((p) => {
                const wrap = document.getElementById('update-progress-wrap');
                const fill = document.getElementById('update-progress-fill');
                const totalBytes = Number(p?.total || 0);
                const transferredBytes = Number(p?.transferred || 0);
                const speedBps = Number(p?.bytesPerSecond || 0);
                if (totalBytes > 0) appUpdateSizeBytes = totalBytes;
                const remainingBytes = appUpdateSizeBytes > 0 ? Math.max(appUpdateSizeBytes - transferredBytes, 0) : 0;
                appUpdateEtaSeconds = speedBps > 0 && remainingBytes > 0 ? (remainingBytes / speedBps) : null;
                if (!isExternalInstallActive()) {
                    if (wrap) wrap.style.display = 'block';
                    if (fill) fill.style.width = (p?.percent || 0) + '%';
                    setUpdateBannerVisual({
                        state: 'downloading',
                        title: 'Descargando update',
                        message: 'Progreso: ' + Math.round(p?.percent || 0) + '%',
                        iconClass: 'fa-download',
                        iconSpin: true,
                    });
                }
                if (status) status.textContent = 'Descargando update: '
                    + Math.round(p?.percent || 0) + '%'
                    + (appUpdateSizeBytes > 0 ? ` (${formatByteSize(transferredBytes)} / ${formatByteSize(appUpdateSizeBytes)})` : '')
                    + (appUpdateEtaSeconds !== null ? ` - ETA ${formatEta(appUpdateEtaSeconds)}` : '');
                setUpdateMetaUI({
                    sizeBytes: appUpdateSizeBytes,
                    etaSeconds: appUpdateEtaSeconds,
                    transferredBytes,
                    speedBps
                });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    phase: 'downloading',
                    percent: Number(p?.percent || 0),
                    sizeBytes: appUpdateSizeBytes,
                    downloadedBytes: transferredBytes,
                    speedBps,
                    etaSeconds: appUpdateEtaSeconds,
                    status: 'Descargando update de OWS Store...',
                });
            });
            window.owsUpdater.onUpdateDownloaded?.(() => {
                const msg = document.getElementById('update-msg');
                const btn = document.getElementById('btn-install-update');
                const wrap = document.getElementById('update-progress-wrap');
                const closeBtn = document.getElementById('btn-close-update-banner');
                if (!isExternalInstallActive()) {
                    if (msg) msg.textContent = 'Descarga completa. Reinicia para instalar.';
                    if (wrap) wrap.style.display = 'none';
                    if (btn) btn.style.display = 'flex';
                    if (closeBtn) {
                        closeBtn.disabled = false;
                        closeBtn.style.opacity = '1';
                        closeBtn.style.cursor = 'pointer';
                    }
                    setUpdateBannerVisual({
                        state: 'ready',
                        title: 'Update lista para instalar',
                        message: 'Descarga completa. Reinicia para aplicar la nueva version.',
                        iconClass: 'fa-circle-check',
                        iconSpin: false,
                    });
                }
                if (status) status.textContent = 'Lista para instalar';
                setUpdateMetaUI({
                    sizeBytes: appUpdateSizeBytes,
                    etaSeconds: 0,
                    transferredBytes: appUpdateSizeBytes > 0 ? appUpdateSizeBytes : null,
                    speedBps: 0
                });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    phase: 'ready',
                    percent: 100,
                    sizeBytes: appUpdateSizeBytes,
                    downloadedBytes: appUpdateSizeBytes,
                    speedBps: 0,
                    etaSeconds: 0,
                    status: 'Descarga completa. Reinicia para instalar.',
                });
                addNotification('Actualizacion descargada, lista para instalar.', 'success');
            });
            window.owsUpdater.onUpdateNotAvailable?.(() => {
                const banner = document.getElementById('update-banner');
                const msg = document.getElementById('update-msg');
                const dot = document.getElementById('update-indicator-dot');
                const closeBtn = document.getElementById('btn-close-update-banner');
                appUpdateSizeBytes = 0;
                appUpdateEtaSeconds = null;
                if (!isExternalInstallActive() && msg) msg.textContent = 'No hay actualizaciones disponibles.';
                if (dot) dot.style.display = 'none';
                appUpdateAvailable = false;
                syncUpdatesBadge();
                if (status) status.textContent = 'Sin actualizaciones pendientes';
                if (!isExternalInstallActive()) {
                    setUpdateBannerVisual({
                        state: 'success',
                        title: 'OWS Store actualizada',
                        message: 'No hay actualizaciones pendientes en este momento.',
                        iconClass: 'fa-circle-check',
                        iconSpin: false,
                    });
                    if (closeBtn) {
                        closeBtn.disabled = false;
                        closeBtn.style.opacity = '1';
                        closeBtn.style.cursor = 'pointer';
                    }
                }
                setUpdateMetaUI({ sizeBytes: 0, etaSeconds: null, transferredBytes: null, speedBps: 0 });
                removeDownloadSession(STORE_DOWNLOAD_KEY);
                addNotification('No hay actualizaciones pendientes.', 'neutral');
                if (!isExternalInstallActive()) {
                    setTimeout(() => {
                        if (banner && !actionBannerSticky) dismissUpdateBanner(true);
                    }, 5000);
                }
            });
            window.owsUpdater.onUpdateError?.((err) => {
                const banner = document.getElementById('update-banner');
                const msg = document.getElementById('update-msg');
                const closeBtn = document.getElementById('btn-close-update-banner');
                appUpdateEtaSeconds = null;
                if (!isExternalInstallActive()) {
                    if (msg) msg.textContent = 'Error buscando actualizaciones: ' + (err || 'desconocido');
                    if (banner) banner.classList.add('visible');
                }
                appUpdateAvailable = false;
                syncUpdatesBadge();
                if (status) status.textContent = 'Error de verificacion';
                if (!isExternalInstallActive()) {
                    setUpdateBannerVisual({
                        state: 'error',
                        title: 'Error de actualizacion',
                        message: 'No se pudo completar la verificacion de updates: ' + (err || 'desconocido'),
                        iconClass: 'fa-triangle-exclamation',
                        iconSpin: false,
                    });
                    if (closeBtn) {
                        closeBtn.disabled = false;
                        closeBtn.style.opacity = '1';
                        closeBtn.style.cursor = 'pointer';
                    }
                }
                setUpdateMetaUI({ sizeBytes: appUpdateSizeBytes, etaSeconds: null, transferredBytes: null, speedBps: 0 });
                updateDownloadSession(STORE_DOWNLOAD_KEY, {
                    phase: 'error',
                    percent: 0,
                    status: 'Error en update de OWS Store: ' + (err || 'desconocido'),
                });
                addNotification('Error de actualizacion: ' + (err || 'desconocido'), 'error');
            });
            window.owsUpdater.onExternalInstallStatus?.((payload) => {
                const projectStatus = document.getElementById('updates-project-status');
                if (!payload?.message) return;
                const payloadTaskId = String(payload?.taskId || '');
                const slug = payloadTaskId.startsWith('install_') ? payloadTaskId.replace(/^install_/, '') : '';
                const uiKey = slug ? `project_${slug}` : '';
                const shouldPaintProgress = shouldRefreshExternalProgressUi(uiKey, payload);
                if (projectStatus && payload?.message && (payload.phase !== 'downloading' || shouldPaintProgress)) {
                    projectStatus.textContent = payload.message;
                }
                if (slug) {
                    const project = getProjectBySlug(slug);
                    const key = `project_${slug}`;
                    const downloadedBytes = Number(payload?.downloadedBytes || 0);
                    const totalBytes = Number(payload?.totalBytes || 0);
                    const speedBps = Number(payload?.bytesPerSecond || 0);
                    const etaSeconds = speedBps > 0 && totalBytes > downloadedBytes
                        ? (totalBytes - downloadedBytes) / speedBps
                        : null;
                    if (payload.phase === 'downloading') {
                        if (!shouldPaintProgress) return;
                        setRuntimeState(slug, { phase: 'downloading', percent: Number(payload.percent || 0), taskId: payloadTaskId });
                        const wrap = document.getElementById('update-progress-wrap');
                        const fill = document.getElementById('update-progress-fill');
                        if (wrap) wrap.style.display = 'block';
                        if (fill) fill.style.width = `${Math.round(Number(payload.percent || 0))}%`;
                        setUpdateMetaUI({
                            sizeBytes: totalBytes,
                            etaSeconds,
                            transferredBytes: downloadedBytes,
                            speedBps
                        });
                        setUpdateBannerVisual({
                            state: 'downloading',
                            title: project ? project.name : 'Descargando proyecto',
                            message: payload.message,
                            iconClass: 'fa-download',
                            iconSpin: true,
                        });
                        updateDownloadSession(key, {
                            name: project?.name || slug,
                            slug,
                            icon: project ? getProjectIcon(project, 64) : STORE_LOCAL_ICON,
                            phase: 'downloading',
                            percent: Number(payload.percent || 0),
                            sizeBytes: totalBytes,
                            downloadedBytes,
                            speedBps,
                            etaSeconds,
                            status: payload.message,
                        });
                    } else if (payload.phase === 'launching') {
                        setRuntimeState(slug, { phase: 'launching', percent: 100, taskId: payloadTaskId });
                        const fill = document.getElementById('update-progress-fill');
                        if (fill) fill.style.width = '100%';
                        updateDownloadSession(key, {
                            name: project?.name || slug,
                            slug,
                            icon: project ? getProjectIcon(project, 64) : STORE_LOCAL_ICON,
                            phase: 'launching',
                            percent: 100,
                            status: payload.message || 'Abriendo instalador...',
                        });
                    } else if (payload.phase === 'done') {
                        setRuntimeState(slug, { phase: 'installed', percent: 100, taskId: '' });
                        const wrap = document.getElementById('update-progress-wrap');
                        if (wrap) wrap.style.display = 'none';
                        updateDownloadSession(key, {
                            name: project?.name || slug,
                            slug,
                            icon: project ? getProjectIcon(project, 64) : STORE_LOCAL_ICON,
                            phase: 'done',
                            percent: 100,
                            status: payload.message || 'Instalador abierto.',
                            etaSeconds: 0,
                        });
                    } else if (payload.phase === 'cancelled' || payload.phase === 'error') {
                        setRuntimeState(slug, { phase: 'idle', percent: 0, taskId: '' });
                        const wrap = document.getElementById('update-progress-wrap');
                        if (wrap) wrap.style.display = 'none';
                        updateDownloadSession(key, {
                            name: project?.name || slug,
                            slug,
                            icon: project ? getProjectIcon(project, 64) : STORE_LOCAL_ICON,
                            phase: payload.phase,
                            percent: 0,
                            status: payload.message || (payload.phase === 'error' ? 'Error de instalacion.' : 'Instalacion cancelada.'),
                        });
                        activeInstallTaskKey = '';
                        processProjectInstallQueue();
                    }
                    // Avoid full card re-render while progress is streaming; patch UI in place instead.
                    if (payload.phase === 'downloading') {
                        patchInstallProgressUI(slug);
                    } else {
                        scheduleSectionRender({
                            projects: true,
                            library: true,
                            immediate: true
                        });
                    }
                }
                if (payload.phase === 'downloading') {
                    if (!shouldPaintProgress) return;
                    showActionMessage(payload.message, { sticky: true, state: 'downloading', showProgress: true });
                    return;
                }
                const key = `${payload.phase}:${payload.message}`;
                if (key !== lastExternalStatusNotification) {
                    addNotification(payload.message, payload?.phase === 'error' ? 'error' : 'neutral');
                    lastExternalStatusNotification = key;
                }
                showActionMessage(payload.message);
            });
            window.owsUpdater.checkForUpdates?.();
        }
        function installUpdate() {
            if (window.owsUpdater?.installUpdate) window.owsUpdater.installUpdate();
        }

        function openStoreAndroidDownload() {
            openExternal(owsStoreAndroidState.downloadUrl || OWS_STORE_ANDROID_ARTIFACT_FALLBACK_URL);
        }

        function initSearch() {
            const input = document.getElementById('search-input');
            if (!input) return;
            input.addEventListener('input', () => {
                currentSearchTerm = input.value || '';
                renderVisibleProjects();
            });
        }

        window.onload = () => {
            initTheme();
            renderOWSStoreAndroidMeta();
            initOceanPayStore();
            renderDownloadSurfaces();
            loadProjects();
            initBrandCycle();
            initUpdater();
            refreshStoreAndroidReleaseLink().catch(() => {
                renderOWSStoreAndroidMeta();
            });
            initSearch();
            setInterval(() => {
                if (document.hidden) return;
                checkProjectUpdatesAndNotify().then(() => {
                    scheduleSectionRender({ projects: true, library: true, immediate: false });
                }).catch(() => {});
                refreshStoreAndroidReleaseLink().catch(() => {});
            }, 120000);
        };

        window.onbeforeunload = () => {
            if (brandCycleTimer) clearInterval(brandCycleTimer);
        };
    </script>
</body>

</html>





