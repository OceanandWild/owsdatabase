<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Velocity Surge - Racing Champions</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap');

        :root {
            --bg-dark: #0a0a1a;
            --bg-card: rgba(20, 20, 40, 0.9);
            --accent-cyan: #00f7ff;
            --accent-purple: #a855f7;
            --accent-pink: #ff3e8d;
            --accent-gold: #ffd700;
            --common: #9ca3af;
            --uncommon: #22c55e;
            --rare: #3b82f6;
            --epic: #a855f7;
            --legendary: #f59e0b;
            --mythic: linear-gradient(135deg, #ff3e8d, #00f7ff, #a855f7);
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg-dark);
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }

        /* MENU PRINCIPAL */
        #mainMenu {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .menu-bg {
            position: absolute;
            inset: 0;
            overflow: hidden;
        }

        .menu-bg::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background: radial-gradient(circle at 30% 40%, rgba(0, 247, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 70% 60%, rgba(168, 85, 247, 0.1) 0%, transparent 40%);
            animation: rotateBg 20s linear infinite;
        }

        @keyframes rotateBg {
            to {
                transform: rotate(360deg);
            }
        }

        .countdown-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 15rem;
            font-weight: 900;
            background: var(--mythic);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: countdownPulse 1s ease-in-out;
            text-shadow: 0 0 50px rgba(0, 247, 255, 0.5);
        }

        .game-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple), var(--accent-pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 60px rgba(0, 247, 255, 0.5);
            margin-bottom: 0.5rem;
            z-index: 1;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.2);
            }
        }

        .game-subtitle {
            font-size: 1.5rem;
            color: var(--accent-cyan);
            margin-bottom: 3rem;
            z-index: 1;
            letter-spacing: 0.5rem;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            z-index: 1;
        }

        .menu-btn {
            padding: 1rem 3rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            border: 2px solid var(--accent-cyan);
            background: rgba(0, 247, 255, 0.1);
            color: var(--accent-cyan);
            cursor: pointer;
            transition: all 0.3s ease;
            clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 100%, 0 100%);
            min-width: 250px;
        }

        .menu-btn:hover {
            background: var(--accent-cyan);
            color: var(--bg-dark);
            transform: translateX(10px);
            box-shadow: 0 0 30px rgba(0, 247, 255, 0.5);
        }

        .coins-display {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--bg-card);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid var(--accent-gold);
        }

        .coins-display span {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-gold);
            font-size: 1.2rem;
        }

        /* SELECCIÓN DE PERSONAJE */
        #characterSelect {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0a1a, #1a1a3a);
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            z-index: 1000;
            overflow-y: auto;
        }

        .select-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--accent-cyan);
            margin-bottom: 2rem;
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            max-width: 1200px;
            width: 100%;
            padding: 1rem;
        }

        .char-card {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .char-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .char-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .char-card.locked::after {
            content: '🔒';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
        }

        .char-card.selected {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 30px rgba(0, 247, 255, 0.5);
        }

        .char-avatar {
            width: 100px;
            height: 100px;
            margin: 0 auto 1rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .char-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .char-rarity {
            font-size: 0.85rem;
            padding: 4px 12px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 0.5rem;
        }

        .rarity-common {
            background: var(--common);
            color: #000;
        }

        .rarity-uncommon {
            background: var(--uncommon);
            color: #000;
        }

        .rarity-rare {
            background: var(--rare);
        }

        .rarity-epic {
            background: var(--epic);
        }

        .rarity-legendary {
            background: var(--legendary);
            color: #000;
        }

        .rarity-mythic {
            background: var(--mythic);
        }

        .char-effect {
            font-size: 0.8rem;
            color: #888;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #fff;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            z-index: 1001;
        }

        .start-race-btn {
            margin-top: 2rem;
            padding: 1.2rem 4rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .start-race-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 247, 255, 0.6);
        }

        /* REVOLUCIÓN HUD CARRERA */
        #gameScreen {
            position: fixed;
            inset: 0;
            display: none;
            background: #050510;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            filter: contrast(1.1) brightness(1.1);
        }

        .game-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 100;
            pointer-events: none;
        }

        /* DISEÑO DE CONTENEDOR MODULAR */
        .hud-module {
            background: rgba(10, 10, 30, 0.7);
            backdrop-filter: blur(15px) saturate(180%);
            border: 1px solid rgba(0, 247, 255, 0.2);
            border-radius: 12px;
            padding: 15px 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), inset 0 0 15px rgba(0, 247, 255, 0.05);
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
        }

        .hud-pos-module {
            align-items: center;
            min-width: 180px;
            border-left: 4px solid var(--accent-gold);
        }

        .hud-progress-module {
            flex-grow: 1;
            margin: 0 40px;
            max-width: 800px;
            border-bottom: none;
            padding: 10px 20px;
            position: relative;
        }

        .position-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            line-height: 1;
            font-weight: 900;
            color: var(--accent-gold);
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            background: transparent;
            padding: 0;
            border: none;
        }

        .pos-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: -5px;
        }

        .lap-display {
            align-self: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: white;
            background: transparent;
            padding: 0;
            border: none;
        }

        /* VELOCÍMETRO DINÁMICO */
        .speedometer-module {
            text-align: right;
            border-right: 4px solid var(--accent-cyan);
        }

        .speed-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.2rem;
            font-weight: 900;
            color: var(--accent-cyan);
            margin-bottom: -5px;
        }

        .speed-unit {
            font-size: 0.8rem;
            color: rgba(0, 247, 255, 0.6);
            letter-spacing: 1px;
        }

        /* BARRA DE PROGRESO PREMIUM HORIZONTAL */
        .progress-track-horizontal {
            position: relative;
            width: 100%;
            height: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(0, 247, 255, 0.2);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
            margin-top: 15px;
        }

        .horizontal-finish-line {
            position: absolute;
            right: 0;
            top: -10px;
            bottom: -10px;
            width: 4px;
            background: var(--accent-gold);
            box-shadow: 0 0 15px var(--accent-gold);
            border-radius: 2px;
        }

        .horizontal-finish-line::after {
            content: '🏁';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
        }

        .racer-dot-horizontal {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(10, 10, 30, 0.8);
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 2;
            transition: left 0.3s ease-out;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .racer-dot-horizontal.player {
            border-color: var(--accent-cyan);
            background: var(--accent-cyan);
            color: black;
            box-shadow: 0 0 15px var(--accent-cyan);
            width: 28px;
            height: 28px;
            z-index: 3;
        }

        /* ITEMS */
        .items-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px 30px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(255, 255, 255, 0.05);
        }

        .item-slot {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
        }

        .item-slot.projectile {
            border-color: rgba(255, 62, 141, 0.3);
        }

        .item-slot.turbo {
            border-color: rgba(0, 247, 255, 0.3);
        }

        .item-slot.trap {
            border-color: rgba(168, 85, 247, 0.3);
        }

        .item-slot:not(.empty):hover {
            transform: scale(1.1) translateY(-5px);
            border-color: white;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .item-slot.empty {
            opacity: 0.3;
            filter: grayscale(1);
        }

        .item-key {
            position: absolute;
            bottom: -25px;
            font-size: 0.9rem;
            font-family: 'Orbitron', sans-serif;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 700;
        }

        .item-label {
            position: absolute;
            top: -25px;
            font-size: 0.7rem;
            font-family: 'Orbitron', sans-serif;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* RESULTADOS */
        #resultsScreen {
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 26, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .results-container {
            background: var(--bg-card);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid var(--accent-cyan);
            max-width: 500px;
        }

        .results-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .results-position {
            font-size: 4rem;
            margin: 1rem 0;
        }

        .rewards {
            margin: 2rem 0;
            padding: 1rem;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            border: 1px solid var(--accent-gold);
        }

        .reward-item {
            font-size: 1.3rem;
            color: var(--accent-gold);
            margin: 0.5rem 0;
        }

        .hidden {
            display: none !important;
        }

        /* SELECTOR DE MAPAS */
        #mapSelect {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0a1a, #1a1a3a);
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            z-index: 1000;
            overflow-y: auto;
        }

        .maps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            max-width: 1200px;
            width: 100%;
            padding: 1rem;
        }

        .map-card {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            position: relative;
            overflow: hidden;
            min-height: 200px;
        }

        .map-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.6);
        }

        .map-card.selected {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 40px rgba(0, 247, 255, 0.5);
        }

        .map-preview {
            width: 100%;
            height: 120px;
            border-radius: 10px;
            margin-bottom: 1rem;
            position: relative;
            overflow: hidden;
        }

        .map-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            color: var(--accent-cyan);
            margin-bottom: 0.5rem;
        }

        .map-description {
            font-size: 0.9rem;
            color: #888;
        }

        /* CUENTA REGRESIVA */
        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 26, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .countdown-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 15rem;
            font-weight: 900;
            background: var(--mythic);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: countdownPulse 1s ease-in-out;
            text-shadow: 0 0 50px rgba(0, 247, 255, 0.5);
        }

        @keyframes countdownPulse {
            0% {
                transform: scale(2);
                opacity: 0;
            }

            50% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(0.8);
                opacity: 0;
            }
        }

        .countdown-go {
            font-family: 'Orbitron', sans-serif;
            font-size: 8rem;
            font-weight: 900;
            background: linear-gradient(135deg, #00ff88, #00f7ff);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: goAnimation 0.8s ease-out forwards;
        }

        @keyframes goAnimation {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(1.5);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        /* EFECTOS DE PARTÍCULAS */
        .particle-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 50;
        }

        /* NOTIFICACIÓN DE ITEM */
        .item-notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 247, 255, 0.2), rgba(168, 85, 247, 0.2));
            border: 2px solid var(--accent-cyan);
            padding: 15px 30px;
            border-radius: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: white;
            z-index: 200;
            animation: slideInNotif 0.5s ease-out, fadeOutNotif 0.5s ease-in 1.5s forwards;
            backdrop-filter: blur(10px);
        }

        @keyframes slideInNotif {
            from {
                transform: translateX(-50%) translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeOutNotif {
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
        }

        /* EFECTO DE IMPACTO */
        .impact-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            pointer-events: none;
            animation: impactBurst 0.5s ease-out forwards;
        }

        @keyframes impactBurst {
            0% {
                transform: scale(0);
                opacity: 1;
            }

            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        /* BARRA LATERAL REDISEÑADA */
        .position-tracker {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 350px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            border: 2px solid rgba(0, 247, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 247, 255, 0.2);
        }

        .track-line {
            position: absolute;
            top: 40px;
            bottom: 40px;
            width: 2px;
            background: linear-gradient(180deg, var(--accent-cyan), var(--accent-purple), var(--accent-pink));
            box-shadow: 0 0 10px var(--accent-cyan);
        }

        .finish-label {
            position: absolute;
            top: -25px;
            font-family: 'Orbitron';
            font-size: 0.7rem;
            color: var(--accent-gold);
            text-shadow: 0 0 10px gold;
        }

        .racer-icon {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: top 0.1s linear, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background: black;
            border: 2px solid white;
            z-index: 105;
        }

        .racer-icon.player {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 15px var(--accent-cyan);
            z-index: 110;
        }

        .racer-icon:hover {
            transform: scale(1.3);
        }

        /* EFECTOS DE ESTADO */
        .status-frozen {
            animation: frozenShake 0.1s infinite;
        }

        @keyframes frozenShake {

            0%,
            100% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(2px);
            }
        }

        .status-burning {
            animation: burningGlow 0.3s infinite alternate;
        }

        @keyframes flashWhite {
            0% {
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        @keyframes titleEntrance {
            from {
                transform: scale(0.5);
                opacity: 0;
                filter: blur(20px);
            }

            to {
                transform: scale(1);
                opacity: 1;
                filter: blur(0);
            }
        }

        /* UPGRADE MODAL */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: var(--bg-card);
            border: 2px solid var(--accent-cyan);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
        }

        .upgrade-stats {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-bar-bg {
            flex-grow: 1;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0 15px;
            border-radius: 5px;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            background: var(--accent-cyan);
            transition: width 0.3s ease;
        }

        .stat-bar-fill.upgrade-pop {
            animation: upgradeBarPop 0.62s ease;
            box-shadow: 0 0 14px rgba(0, 247, 255, 0.65);
        }

        #upgradeCharacterPreview.upgrade-flare {
            animation: upgradePreviewFlare 0.9s ease;
            filter: drop-shadow(0 0 18px rgba(0, 247, 255, 0.6));
        }

        .modal-content.upgrade-celebrate {
            animation: upgradeModalKick 0.44s cubic-bezier(0.2, 0.86, 0.26, 1.1);
        }

        .upgrade-levelup-fx {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 6;
            animation: upgradeFxIn 0.18s ease;
        }

        .upgrade-levelup-fx.out {
            animation: upgradeFxOut 0.46s ease forwards;
        }

        .upgrade-levelup-ring {
            position: absolute;
            width: 280px;
            height: 280px;
            border-radius: 50%;
            border: 2px solid rgba(0, 247, 255, 0.72);
            box-shadow: 0 0 26px rgba(0, 247, 255, 0.48);
            animation: upgradeRingBlast 0.84s ease;
        }

        .upgrade-levelup-flash {
            position: absolute;
            width: 340px;
            height: 340px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.45), rgba(0, 247, 255, 0.16), transparent 72%);
            filter: blur(1px);
            animation: upgradeFlashPulse 0.9s ease;
        }

        .upgrade-levelup-explosion {
            position: absolute;
            width: 420px;
            height: 420px;
            border-radius: 50%;
            background:
                radial-gradient(circle, rgba(255, 255, 255, 0.52) 0%, rgba(0, 247, 255, 0.24) 28%, rgba(255, 170, 60, 0.14) 47%, transparent 70%);
            mix-blend-mode: screen;
            filter: blur(2px);
            animation: upgradeExplosionPulse 0.95s ease;
        }

        .upgrade-levelup-streaks,
        .upgrade-levelup-sparks {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .upgrade-levelup-streak {
            position: absolute;
            left: 50%;
            top: 50%;
            width: var(--len, 120px);
            height: 2px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.9), rgba(0, 247, 255, 0.5), rgba(255, 140, 40, 0));
            box-shadow: 0 0 8px rgba(0, 247, 255, 0.7);
            transform-origin: 0 50%;
            transform: rotate(var(--rot, 0deg)) translateX(0) scaleX(0.1);
            opacity: 0;
            animation: upgradeStreakLaunch var(--dur, 0.75s) ease-out var(--delay, 0s) forwards;
        }

        .upgrade-levelup-spark {
            position: absolute;
            left: 50%;
            top: 50%;
            width: var(--size, 6px);
            height: var(--size, 6px);
            border-radius: 50%;
            background: var(--spark, #ffffff);
            box-shadow: 0 0 10px var(--spark, #ffffff);
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.3);
            animation: upgradeSparkFly var(--dur, 0.9s) cubic-bezier(0.15, 0.7, 0.22, 1) var(--delay, 0s) forwards;
        }

        .upgrade-levelup-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            border-radius: 12px;
            background: linear-gradient(160deg, rgba(8, 16, 34, 0.94), rgba(15, 9, 26, 0.94));
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 10px 28px rgba(0, 0, 0, 0.52);
        }

        .upgrade-levelup-text {
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .upgrade-levelup-text .kicker {
            font-family: 'Orbitron';
            font-size: 0.62rem;
            letter-spacing: 1px;
            color: var(--accent-cyan);
            font-weight: 900;
        }

        .upgrade-levelup-text .name {
            font-family: 'Orbitron';
            font-size: 0.95rem;
            font-weight: 900;
        }

        .upgrade-levelup-text .lvl {
            font-size: 0.75rem;
            color: #e4f8ff;
            opacity: 0.88;
        }

        @keyframes upgradeBarPop {
            0% {
                filter: brightness(1);
                transform: scaleY(1);
            }

            35% {
                filter: brightness(1.85);
                transform: scaleY(1.28);
            }

            100% {
                filter: brightness(1);
                transform: scaleY(1);
            }
        }

        @keyframes upgradePreviewFlare {
            0% {
                transform: scale(1) rotate(0deg);
            }

            35% {
                transform: scale(1.1) rotate(4deg);
            }

            70% {
                transform: scale(1.03) rotate(-2deg);
            }

            100% {
                transform: scale(1) rotate(0deg);
            }
        }

        @keyframes upgradeModalKick {
            0% {
                transform: scale(1) translateX(0);
            }

            20% {
                transform: scale(1.025) translateX(-3px);
            }

            38% {
                transform: scale(1.018) translateX(3px);
            }

            55% {
                transform: scale(1.01) translateX(-2px);
            }

            100% {
                transform: scale(1) translateX(0);
            }
        }

        @keyframes upgradeFxIn {
            from {
                opacity: 0;
                transform: scale(0.88);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes upgradeFxOut {
            to {
                opacity: 0;
                transform: scale(1.07);
                filter: blur(1px);
            }
        }

        @keyframes upgradeRingBlast {
            0% {
                transform: scale(0.4);
                opacity: 0.9;
            }

            100% {
                transform: scale(1.28);
                opacity: 0;
            }
        }

        @keyframes upgradeFlashPulse {
            0% {
                opacity: 0;
            }

            18% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        @keyframes upgradeExplosionPulse {
            0% {
                transform: scale(0.35);
                opacity: 0;
            }

            24% {
                transform: scale(0.95);
                opacity: 0.95;
            }

            100% {
                transform: scale(1.55);
                opacity: 0;
            }
        }

        @keyframes upgradeStreakLaunch {
            0% {
                opacity: 0;
                transform: rotate(var(--rot, 0deg)) translateX(0) scaleX(0.1);
            }

            20% {
                opacity: 0.95;
            }

            100% {
                opacity: 0;
                transform: rotate(var(--rot, 0deg)) translateX(92px) scaleX(1);
            }
        }

        @keyframes upgradeSparkFly {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.24);
            }

            15% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                transform: translate(calc(-50% + var(--tx, 0px)), calc(-50% + var(--ty, 0px))) scale(0.05);
            }
        }

        /* MISSION PANEL */
        #missionsPanel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: var(--bg-card);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--accent-purple);
            max-width: 250px;
            z-index: 500;
        }

        .mission-item {
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: #ddd;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
            padding-bottom: 5px;
        }

        .mission-item.completed {
            color: var(--uncommon);
            text-decoration: line-through;
            opacity: 0.6;
        }

        /* CHEST SYSTEM */
        .chest-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 4000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: white;
            font-family: 'Orbitron';
            overflow-y: auto;
            padding: 12px;
            box-sizing: border-box;
        }

        .chest-modal-content {
            width: min(760px, 96vw);
            max-height: calc(100vh - 24px);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: linear-gradient(180deg, rgba(19, 20, 37, 0.96), rgba(12, 12, 20, 0.92));
            box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);
            padding: 14px 14px 20px;
        }

        .chest-container {
            width: 300px;
            height: 300px;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .chest-container:hover {
            transform: scale(1.05);
        }

        .chest-container.shake {
            animation: chestShake 0.5s infinite;
        }

        .chest-container.open {
            animation: chestOpen 0.8s forwards;
        }

        @keyframes chestShake {
            0% {
                transform: rotate(0);
            }

            25% {
                transform: rotate(5deg);
            }

            50% {
                transform: rotate(0);
            }

            75% {
                transform: rotate(-5deg);
            }

            100% {
                transform: rotate(0);
            }
        }

        @keyframes chestOpen {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.5) rotate(10deg);
                opacity: 0.5;
            }

            100% {
                transform: scale(2);
                opacity: 0;
                filter: blur(20px);
            }
        }

        .chest-rewards {
            margin-top: 14px;
            font-size: clamp(1rem, 2.8vw, 2rem);
            color: var(--accent-gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            opacity: 0;
            transform: translateY(20px);
            width: min(700px, 94%);
            max-height: 54vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px 8px 10px;
            box-sizing: border-box;
        }

        .chest-rewards.chest-single-large {
            width: min(760px, 96%);
            max-height: none;
            overflow: hidden;
            padding: 10px 12px 14px;
        }

        .chest-rewards.show {
            animation: rewardFade 0.5s forwards;
        }

        #chestCloseBtn {
            position: sticky;
            bottom: 6px;
            z-index: 3;
            margin-top: 16px !important;
        }

        .chest-unlock-fx {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
            animation: chestUnlockFxIn 0.26s ease;
        }

        .chest-unlock-fx.out {
            animation: chestUnlockFxOut 0.44s ease forwards;
        }

        .chest-unlock-flash {
            position: absolute;
            width: 340px;
            height: 340px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.48), rgba(0, 247, 255, 0.16), transparent 72%);
            filter: blur(2px);
            animation: chestUnlockFlashPulse 1.12s ease;
        }

        .chest-unlock-ring {
            position: absolute;
            width: 260px;
            height: 260px;
            border-radius: 50%;
            border: 2px solid rgba(0, 247, 255, 0.7);
            box-shadow: 0 0 24px rgba(0, 247, 255, 0.45);
            animation: chestUnlockRing 1.15s ease;
        }

        .chest-unlock-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 12px 16px;
            border-radius: 12px;
            background: linear-gradient(160deg, rgba(7, 15, 32, 0.92), rgba(12, 8, 24, 0.92));
            border: 1px solid rgba(255, 255, 255, 0.28);
            box-shadow: 0 10px 34px rgba(0, 0, 0, 0.5);
        }

        .chest-unlock-title {
            font-family: 'Orbitron';
            font-size: 0.72rem;
            color: var(--accent-cyan);
            letter-spacing: 1.2px;
            font-weight: 900;
        }

        .chest-unlock-name {
            font-family: 'Orbitron';
            font-size: 1.05rem;
            font-weight: 900;
            letter-spacing: 0.8px;
        }

        @keyframes chestUnlockFxIn {
            from {
                opacity: 0;
                transform: scale(0.86);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes chestUnlockFxOut {
            to {
                opacity: 0;
                transform: scale(1.08);
            }
        }

        @keyframes chestUnlockFlashPulse {
            0% {
                opacity: 0;
                transform: scale(0.35);
            }

            30% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                transform: scale(1.35);
            }
        }

        @keyframes chestUnlockRing {
            0% {
                opacity: 0;
                transform: scale(0.4);
            }

            20% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                transform: scale(1.24);
            }
        }

        @media (max-width: 680px) {
            .chest-container {
                width: 230px;
                height: 230px;
            }
        }

        @keyframes rewardFade {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* SHOP UI */
        #shopMenu {
            display: none;
            flex-direction: column;
            align-items: center;
            position: fixed;
            inset: 0;
            background: var(--bg-dark);
            z-index: 2500;
            padding: 40px;
            overflow-y: auto;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 1000px;
            margin-top: 30px;
        }

        .shop-card {
            background: var(--bg-card);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .shop-card:hover {
            border-color: var(--accent-cyan);
            transform: translateY(-10px);
            box-shadow: 0 10px 30px rgba(0, 247, 255, 0.2);
        }

        .shop-card h3 {
            color: white;
            margin: 15px 0 5px;
            font-size: 1.2rem;
        }

        .shop-card p {
            color: #aaa;
            font-size: 0.85rem;
            margin-bottom: 15px;
        }

        .shop-price {
            font-size: 1.4rem;
            color: var(--accent-gold);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .shop-buy-controls {
            margin-top: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .shop-qty-btn {
            min-width: 34px;
            height: 34px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.06);
            color: #fff;
            font-size: 1rem;
            cursor: pointer;
        }

        .shop-qty-value {
            min-width: 44px;
            padding: 7px 10px;
            border-radius: 10px;
            font-family: 'Orbitron';
            font-weight: 700;
            color: #dff8ff;
            background: rgba(0, 247, 255, 0.12);
            border: 1px solid rgba(0, 247, 255, 0.35);
            text-align: center;
        }

        .shop-buy-btn {
            border: 1px solid rgba(0, 247, 255, 0.45);
            background: linear-gradient(135deg, rgba(0, 247, 255, 0.18), rgba(168, 85, 247, 0.2));
            color: #fff;
            font-family: 'Orbitron';
            font-weight: 700;
            letter-spacing: 0.4px;
            border-radius: 10px;
            padding: 8px 12px;
            cursor: pointer;
        }

        .shop-chest-stash {
            width: min(1180px, 97vw);
            margin: 14px auto 30px;
            border-radius: 16px;
            border: 1px solid rgba(0, 247, 255, 0.26);
            background: linear-gradient(145deg, rgba(10, 18, 38, 0.92), rgba(7, 10, 22, 0.96));
            padding: 14px;
        }

        .shop-chest-stash-title {
            font-family: 'Orbitron';
            font-size: 0.95rem;
            letter-spacing: 1.2px;
            color: var(--accent-cyan);
            margin-bottom: 10px;
        }

        .shop-chest-stash-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
        }

        .shop-stash-card {
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.04);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 178px;
        }

        .shop-stash-count {
            font-family: 'Orbitron';
            font-size: 0.82rem;
            color: #dff8ff;
            text-align: center;
        }

        .shop-stash-actions {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 6px;
        }

        .shop-stash-btn {
            border: 1px solid rgba(0, 247, 255, 0.35);
            border-radius: 8px;
            background: rgba(0, 247, 255, 0.09);
            color: #fff;
            font-family: 'Orbitron';
            font-size: 0.66rem;
            font-weight: 700;
            letter-spacing: 0.3px;
            padding: 6px 4px;
            cursor: pointer;
        }

        .shop-stash-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .currency-display {
            position: absolute;
            top: 20px;
            right: 40px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid var(--accent-purple);
            display: flex;
            align-items: center;
            font-family: 'Orbitron';
            color: white;
            z-index: 1000;
        }

        /* SCREEN VERSUS */
        #versusScreen {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, rgba(10, 10, 30, 0.95) 0%, #000 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 5000;
            font-family: 'Orbitron', sans-serif;
            color: white;
            padding: 2rem;
        }

        .versus-header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 0.5s ease-out;
        }

        .versus-header h1 {
            font-size: 3rem;
            background: var(--mythic);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 247, 255, 0.3);
            margin-bottom: 0.5rem;
        }

        .versus-header p {
            color: var(--accent-cyan);
            letter-spacing: 2px;
            font-size: 1.2rem;
        }

        .versus-grid {
            display: flex;
            gap: 20px;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
        }

        .versus-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            width: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            animation: scaleIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) backwards;
        }

        .versus-card.is-player {
            border-color: var(--accent-cyan);
            background: rgba(0, 247, 255, 0.05);
            box-shadow: 0 0 20px rgba(0, 247, 255, 0.2);
        }

        .versus-card canvas {
            margin-bottom: 15px;
        }

        .versus-card .name {
            font-size: 1.1rem;
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }

        .versus-card .char-name {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        @keyframes fadeInDown {
            from {
                transform: translateY(-30px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* EVENTS SCREEN REDESIGN */
        .evt-layout {
            max-width: 900px;
            width: 92%;
            margin: 80px auto 40px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .evt-panel {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .evt-hero {
            border-radius: 20px;
            padding: 35px;
            position: relative;
            overflow: hidden;
            min-height: 180px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 30px;
        }

        .evt-countdown {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .cd-unit {
            text-align: center;
        }

        .cd-unit .cd-num {
            font-family: 'Orbitron';
            font-size: 2rem;
            font-weight: 900;
            display: block;
        }

        .cd-unit .cd-lbl {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tl-item {
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tl-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .tl-item.tl-active {
            border-color: var(--accent-cyan);
            background: rgba(0, 247, 255, 0.05);
            box-shadow: 0 0 15px rgba(0, 247, 255, 0.1);
        }

        .tl-item.tl-past {
            opacity: 0.45;
        }

        .tl-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .evt-offer {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 22px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .evt-offer:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 50px rgba(255, 215, 0, 0.15);
        }

        .evt-offer .offer-ribbon {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 0.6rem;
            font-family: 'Orbitron';
            font-weight: 900;
            letter-spacing: 1px;
        }

        .shop-offer-wrap {
            grid-column: 1/-1;
            margin-top: 10px;
            border-top: 1px solid rgba(255, 62, 141, 0.2);
            padding-top: 20px;
        }

        .shop-offer-card {
            background: linear-gradient(135deg, rgba(255, 62, 141, 0.1), rgba(168, 85, 247, 0.1));
            border: 2px solid rgba(255, 62, 141, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            animation: offerPulse 2s ease-in-out infinite alternate;
        }

        @keyframes offerPulse {
            from {
                box-shadow: 0 0 10px rgba(255, 62, 141, 0.1)
            }

            to {
                box-shadow: 0 0 30px rgba(255, 62, 141, 0.3)
            }
        }

        .shop-offer-card:hover {
            border-color: var(--accent-pink);
            transform: translateY(-10px) scale(1.03);
        }

        .shop-offer-card h3 {
            color: white;
            margin: 15px 0 5px;
            font-size: 1.2rem;
        }

        .shop-offer-card p {
            color: #ccc;
            font-size: 0.85rem;
            margin-bottom: 15px;
        }
    

/* Ultra Patch (inlined) */

        .garage-layout {
            width: min(1300px, 96vw);
            display: grid;
            grid-template-columns: 1.1fr 0.9fr;
            gap: 1rem;
            margin: 0 auto 1rem;
            min-height: 62vh;
        }

        .garage-roster {
            background: linear-gradient(180deg, rgba(15, 15, 35, 0.9), rgba(8, 8, 18, 0.92));
            border: 1px solid rgba(0, 247, 255, 0.22);
            border-radius: 16px;
            padding: 1rem;
            overflow: auto;
        }

        .garage-roster .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 0.8rem;
            max-width: none;
            padding: 0;
        }

        .garage-roster .char-card {
            padding: 0.8rem;
            border-radius: 12px;
            min-height: 140px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.35rem;
            background: rgba(255, 255, 255, 0.03);
        }

        .garage-roster .char-card.unlock-reveal {
            position: relative;
            overflow: hidden;
            animation: unlockCardNeutralize 1.15s ease forwards;
        }

        .garage-roster .char-card.unlock-reveal::before {
            content: '';
            position: absolute;
            inset: -40%;
            background: radial-gradient(circle, rgba(0, 247, 255, 0.3), transparent 62%);
            pointer-events: none;
            animation: unlockCardGlowSweep 1.1s ease;
        }

        .unlock-break-lock {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            z-index: 4;
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.8);
            animation: unlockLockBreak 0.65s ease forwards;
            pointer-events: none;
        }

        .unlock-break-flash {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.7), rgba(0, 247, 255, 0.18), transparent 68%);
            opacity: 0;
            z-index: 3;
            pointer-events: none;
            animation: unlockBreakFlash 0.62s ease forwards;
        }

        @keyframes unlockCardNeutralize {
            0% {
                filter: grayscale(1) brightness(0.68);
                border-color: rgba(144, 144, 144, 0.6);
                box-shadow: none;
            }

            40% {
                filter: grayscale(0.55) brightness(1);
                border-color: rgba(0, 247, 255, 0.95);
                box-shadow: 0 0 18px rgba(0, 247, 255, 0.45);
            }

            100% {
                filter: grayscale(0) brightness(1);
                border-color: rgba(255, 255, 255, 0.26);
                box-shadow: 0 0 10px rgba(0, 247, 255, 0.2);
            }
        }

        @keyframes unlockCardGlowSweep {
            from {
                opacity: 0;
                transform: translateX(-10%) scale(0.8);
            }

            35% {
                opacity: 1;
            }

            to {
                opacity: 0;
                transform: translateX(8%) scale(1.2);
            }
        }

        @keyframes unlockLockBreak {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            60% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.24) rotate(-8deg);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.6) rotate(22deg);
            }
        }

        @keyframes unlockBreakFlash {
            0% {
                opacity: 0;
            }

            30% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        .garage-roster .char-card .char-avatar {
            width: 72px;
            height: 72px;
            margin: 0;
        }

        .garage-roster .char-card .char-name {
            font-size: 0.85rem;
            margin: 0;
            text-align: center;
        }

        .garage-roster .char-card .char-rarity,
        .garage-roster .char-card .char-effect,
        .garage-roster .char-card .char-stats,
        .garage-roster .char-card .menu-btn {
            display: none !important;
        }

        .garage-detail {
            background: linear-gradient(160deg, rgba(16, 18, 40, 0.95), rgba(9, 9, 22, 0.96));
            border: 1px solid rgba(168, 85, 247, 0.35);
            border-radius: 16px;
            padding: 1rem;
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 74vh;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 247, 255, 0.5) transparent;
        }

        .garage-detail::before {
            content: '';
            position: absolute;
            inset: -30% auto auto -10%;
            width: 320px;
            height: 320px;
            background: radial-gradient(circle, rgba(0, 247, 255, 0.12), transparent 62%);
            pointer-events: none;
        }

        .garage-detail-header {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        .garage-detail-avatar {
            width: 110px;
            height: 110px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .garage-info-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.7rem;
            margin-top: 0.8rem;
        }

        .garage-info-block {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 0.65rem;
        }

        .garage-ability {
            font-size: 0.82rem;
            color: rgba(255, 255, 255, 0.85);
            margin-top: 0.25rem;
        }

        .garage-skills-panel {
            margin-top: 0.85rem;
            padding: 0.75rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.035);
        }

        .garage-skills-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 0.6rem;
        }

        .garage-skill-card {
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(7, 12, 28, 0.72);
            border-radius: 10px;
            padding: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .garage-skill-icon-wrap {
            width: 52px;
            height: 52px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .garage-skill-icon-wrap[data-tip]:hover::after {
            content: attr(data-tip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 15, 34, 0.96);
            border: 1px solid rgba(0, 247, 255, 0.35);
            border-radius: 8px;
            color: #dff8ff;
            font-family: Orbitron;
            font-size: 0.62rem;
            letter-spacing: 0.4px;
            padding: 6px 8px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 5;
        }

        .garage-skill-icon {
            width: 46px;
            height: 46px;
        }

        .garage-skill-track {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.4);
        }

        .garage-skill-fill {
            height: 100%;
            width: 0%;
            transition: width 0.25s ease;
        }

        .garage-skill-pct {
            font-family: Orbitron;
            font-size: 0.6rem;
            color: #bfe7ff;
            opacity: 0.95;
        }

        @media (max-width: 1120px) {
            .garage-detail {
                max-height: 68vh;
            }
            .garage-skills-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        @media (max-width: 760px) {
            .garage-skills-grid {
                grid-template-columns: 1fr;
            }
        }

        #modeSelectScreen {
            position: fixed;
            inset: 0;
            display: none;
            z-index: 1200;
            background: radial-gradient(circle at top right, rgba(0, 247, 255, 0.14), transparent 35%), linear-gradient(135deg, #090914 0%, #111229 45%, #090914 100%);
            padding: 1.6rem;
            overflow-y: auto;
        }

        .mode-grid {
            width: min(1180px, 96vw);
            margin: 1.2rem auto 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 0.9rem;
        }

        .mode-card {
            border: 1px solid rgba(0, 247, 255, 0.25);
            border-radius: 14px;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.04);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mode-card:hover {
            transform: translateY(-3px);
            border-color: rgba(0, 247, 255, 0.6);
        }

        .mode-card.active {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 2px rgba(0, 247, 255, 0.2) inset;
            background: rgba(0, 247, 255, 0.12);
        }

        #shopMenu {
            background: linear-gradient(180deg, #090910, #131328 55%, #0a0a16);
            gap: 1rem;
            padding: 1.2rem;
            overflow-y: auto;
        }

        #shopMenu .shop-grid {
            width: min(1320px, 97vw);
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1rem;
            align-items: stretch;
        }

        #shopMenu .shop-card {
            background: linear-gradient(155deg, rgba(19, 21, 45, 0.93), rgba(8, 10, 22, 0.96));
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.11);
            padding: 1rem;
            min-height: 280px;
            position: relative;
        }

        #shopMenu .shop-card::after {
            content: '';
            position: absolute;
            inset: auto 18px 10px 18px;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 247, 255, 0.55), transparent);
        }

        #eventsScreen {
            background: radial-gradient(circle at top left, rgba(255, 62, 141, 0.12), transparent 30%), radial-gradient(circle at 85% 15%, rgba(0, 247, 255, 0.12), transparent 35%), linear-gradient(180deg, #0b0718, #130a2a 45%, #090514 100%) !important;
        }

        #eventsScreen .evt-layout {
            width: min(1200px, 96vw);
            margin: 70px auto 25px;
            display: grid;
            gap: 0.9rem;
        }

        #eventsScreen .evt-panel,
        #eventsScreen .evt-hero {
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(14, 16, 38, 0.72);
            backdrop-filter: blur(6px);
        }

        #eventsScreen .evt-hero {
            min-height: 220px;
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            padding: 1.2rem;
        }

        .event-racer-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .event-racer-chip {
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            font-size: 0.76rem;
            font-family: 'Orbitron';
            cursor: pointer;
        }

        .event-racer-chip.active {
            border-color: var(--accent-cyan);
            background: rgba(0, 247, 255, 0.2);
        }

        #sandboxPanel {
            position: absolute;
            top: 90px;
            right: 18px;
            width: min(300px, 42vw);
            background: rgba(5, 8, 22, 0.88);
            border: 1px solid rgba(0, 247, 255, 0.35);
            border-radius: 14px;
            padding: 0.7rem;
            z-index: 1500;
            display: none;
        }

        .sandbox-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 6px;
            font-size: 0.85rem;
        }

        .sandbox-row button {
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 8px;
            padding: 5px 9px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            font-family: 'Orbitron';
            font-size: 0.68rem;
        }

        .sandbox-row button.off {
            border-color: #8b8b8b;
            color: #bbb;
        }

        .racer-dot-horizontal canvas {
            width: 100%;
            height: 100%;
            display: block;
            pointer-events: none;
        }

        @media (max-width: 980px) {
            .garage-layout {
                grid-template-columns: 1fr;
            }

            .garage-detail {
                order: -1;
            }
        }
    


/* Merged style blocks */

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    

    .op-tab-btn {
        flex: 1;
        padding: 10px;
        background: transparent;
        border: none;
        color: #666;
        font-family: 'Orbitron';
        font-size: 0.7rem;
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s;
        text-transform: uppercase;
    }

    .op-tab-btn.active {
        background: rgba(0, 247, 255, 0.1);
        color: var(--accent-cyan);
        box-shadow: inset 0 0 10px rgba(0, 247, 255, 0.1);
    }

    .op-card-item {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid #222;
        border-radius: 12px;
        padding: 15px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    .op-card-item:hover {
        background: rgba(0, 247, 255, 0.08);
        border-color: var(--accent-cyan);
        transform: translateX(8px);
        box-shadow: -5px 0 15px rgba(0, 247, 255, 0.1);
    }

    /* Scrollbar minimalista */
    #opCardList::-webkit-scrollbar {
        width: 4px;
    }

    #opCardList::-webkit-scrollbar-track {
        background: transparent;
    }

    #opCardList::-webkit-scrollbar-thumb {
        background: var(--accent-cyan);
        border-radius: 10px;
    }

</style>
    
</head>

<body>
    <!-- MENÚ PRINCIPAL -->
    <div id="mainMenu">
        <div class="menu-bg"></div>
        <div class="currency-display">
            <span id="playerLevelDisplay"
                style="color: var(--accent-purple); font-weight: bold; margin-right: 15px;">LVL 1</span>
            <canvas id="voltBitIcon" width="30" height="30" style="margin-right: 5px;"></canvas>
            <span id="voltBitsAmount">500</span>
        </div>

        <!-- MISIONES DIARIAS -->
        <div id="missionsPanel">
            <h3 style="font-family: 'Orbitron'; font-size: 0.9rem; color: var(--accent-cyan); margin-bottom: 10px;">
                MISIONES</h3>
            <div id="missionList">
                <!-- Se poblará por JS -->
            </div>
        </div>
        <h1 class="game-title">VELOCITY SURGE</h1>
        <p class="game-subtitle">RACING CHAMPIONS</p>
        <div class="menu-buttons">
            <button class="menu-btn" onclick="showCharacterSelect()">🏁 INICIAR CARRERA</button>
            <button class="menu-btn" onclick="showShop()"
                style="border-color: var(--accent-gold); color: var(--accent-gold);">🏬 TIENDA</button>
            <button class="menu-btn" onclick="showGarage()">🚗 GARAJE</button>
            <button class="menu-btn" onclick="showEvents()"
                style="border-color: var(--accent-pink); color: var(--accent-pink);">💖 EVENTOS</button>
        </div>
    </div>

    <!-- SELECCIÓN DE PERSONAJE -->
    <div id="characterSelect">
        <button class="back-btn" onclick="showMainMenu()">← Volver</button>
        <h2 class="select-title">ELIGE TU CORREDOR</h2>
        <div class="characters-grid" id="charactersGrid"></div>
        <button class="start-race-btn" onclick="showModeSelect()">SIGUIENTE: MODOS</button>
    </div>

    <div id="modeSelectScreen" style="display:none;">
        <button class="back-btn" onclick="showCharacterSelect()">← VOLVER</button>
        <h2 class="select-title" style="text-align:center;">SELECCIONA EL MODO</h2>
        <div class="mode-grid" id="modeGrid"></div>
        <div style="width:min(1180px,96vw);margin:12px auto 0;display:flex;justify-content:flex-end;">
            <button class="start-race-btn" onclick="continueToMapSelection()">SIGUIENTE: MAPAS</button>
        </div>
    </div>

    <!-- SELECCIÓN DE MAPA -->
    <div id="mapSelect">
        <button class="back-btn" onclick="showModeSelect()">← Volver</button>
        <h2 class="select-title">ELIGE TU CIRCUITO</h2>
        <div class="maps-grid" id="mapsGrid"></div>
        <button class="start-race-btn" onclick="startRaceWithCountdown()">🏁 COMENZAR CARRERA</button>
    </div>

    <!-- PANTALLA DE JUEGO -->
    <div id="gameScreen">
        <canvas id="gameCanvas"></canvas>

        <div class="game-hud">
            <!-- Módulo de Posición -->
            <div class="hud-module hud-pos-module">
                <span class="pos-label">POSICIÓN</span>
                <div class="position-display" id="currentPosition">1°</div>
            </div>

            <!-- Módulo de Progreso (Rediseñado) -->
            <div class="hud-module hud-progress-module">
                <div
                    style="display: flex; justify-content: space-between; font-family: 'Orbitron'; font-size: 0.7rem; letter-spacing: 2px; color: rgba(255,255,255,0.5);">
                    <span>INICIO</span>
                    <span id="raceProgressPercent" style="color: var(--accent-cyan); font-weight: bold;">0%</span>
                    <span>META</span>
                </div>
                <div class="progress-track-horizontal">
                    <div class="horizontal-finish-line"></div>
                    <div class="racer-dot-horizontal player" id="playerDot"></div>
                    <div class="racer-dot-horizontal bot" id="bot1Dot"></div>
                    <div class="racer-dot-horizontal bot" id="bot2Dot"></div>
                    <div class="racer-dot-horizontal bot" id="bot3Dot"></div>
                </div>
            </div>

            <!-- Módulo de Velocidad -->
            <div class="hud-module speedometer-module">
                <div class="speed-value" id="speedDisplay">000</div>
                <div class="speed-unit">KM/H</div>
            </div>
        </div>

        <div class="items-bar">
            <div class="item-slot projectile empty" id="slotProjectile" onclick="useTypedItem('projectile')">
                <span class="item-label">ATAQUE</span>
                <canvas id="canvasProjectile" width="60" height="60"></canvas>
                <span id="iconProjectile" class="hidden"></span>
                <span class="item-key">Q</span>
            </div>
            <div class="item-slot turbo empty" id="slotTurbo" onclick="useTypedItem('turbo')">
                <span class="item-label">TURBO</span>
                <canvas id="canvasTurbo" width="60" height="60"></canvas>
                <span id="iconTurbo" class="hidden"></span>
                <span class="item-key">SHIFT</span>
            </div>
            <div class="item-slot trap empty" id="slotTrap" onclick="useTypedItem('trap')">
                <span class="item-label">TRAMPA</span>
                <canvas id="canvasTrap" width="60" height="60"></canvas>
                <span id="iconTrap" class="hidden"></span>
                <span class="item-key">E</span>
            </div>
        </div>
    </div>
    </div>

    <!-- COUNTDOWN OVERLAY -->
    <div id="countdownOverlay" class="countdown-overlay hidden">
        <div id="countdownText" class="countdown-number">3</div>
    </div>

    <!-- RESULTADOS -->
    <div id="resultsScreen">
        <div class="results-container">
            <h2 class="results-title" id="resultsTitle">¡CARRERA TERMINADA!</h2>
            <div class="results-position" id="resultsPosition">🏆</div>
            <div class="rewards">
                <div class="reward-item" id="coinsReward"
                    style="display: flex; align-items: center; gap: 5px; justify-content: center;">
                    +<span id="resultsVoltBits">100</span> <canvas id="resultsCoinIcon" width="20" height="20"></canvas>
                </div>
                <div class="reward-item" id="expReward">+50 XP</div>
            </div>
            <button class="start-race-btn" onclick="showMainMenu()">CONTINUAR</button>
        </div>
    </div>

    <!-- PANTALLA VERSUS (Carga Pre-Carrera) -->
    <div id="versusScreen">
        <div class="versus-header">
            <h1 id="vsCupName">CYBER CUP</h1>
            <p id="vsMapInfo">CIUDAD NEÓN - 16,000 KM</p>
        </div>
        <div class="versus-grid" id="vsRacerGrid">
            <!-- Participantes aqui -->
        </div>
    </div>

    <!-- MODAL DE MEJORA -->
    <div id="upgradeModal" class="modal">
        <div class="modal-content">
            <button class="back-btn" onclick="closeUpgradeModal()"
                style="position: absolute; top: 10px; left: 10px;">X</button>
            <h2 class="select-title" id="upgradeTitle">MEJORAR NAVE</h2>
            <div id="upgradeCharacterPreview" style="height: 100px; margin-bottom: 20px;"></div>

            <div class="upgrade-stats">
                <div class="stat-row">
                    <span>VELOCIDAD</span>
                    <div class="stat-bar-bg">
                        <div id="bar-speed" class="stat-bar-fill"></div>
                    </div>
                    <span id="val-speed">5</span>
                </div>
                <div class="stat-row">
                    <span>ACELERACIÓN</span>
                    <div class="stat-bar-bg">
                        <div id="bar-accel" class="stat-bar-fill"></div>
                    </div>
                    <span id="val-accel">5</span>
                </div>
                <div class="stat-row">
                    <span>MANEJO</span>
                    <div class="stat-bar-bg">
                        <div id="bar-handling" class="stat-bar-fill"></div>
                    </div>
                    <span id="val-handling">5</span>
                </div>
            </div>

            <p class="upgrade-price"
                style="color: var(--accent-gold); font-size: 1.2rem; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px;">
                Costo de mejora: <span id="upgradeCost">100</span>
            </p>
            <p id="upgradeCardRequirement"
                style="color: var(--accent-cyan); font-size: 1rem; margin-bottom: 20px; text-align: center;">
                Tarjetas necesarias: <span id="upgradeCardsNeeded">0/10</span>
            </p>
            <button class="start-race-btn" id="upgradeBtn" onclick="applyUpgrade()">MEJORAR (LVL <span
                    id="nextLvl">2</span>)</button>
        </div>
    </div>

    <!-- TIENDA -->
    <div id="shopMenu">
        <button class="back-btn" onclick="showMainMenu()">VOLVER</button>
        <h1 class="select-title">TIENDA DEL MULTIVERSO</h1>
        <div class="shop-grid">
            <div class="shop-card" data-chest="electric">
                <canvas id="iconChestElectric" width="120" height="120"></canvas>
                <h3>COFRE ELÉCTRICO</h3>
                <p>Cartas: Común/Poco Común</p>
                <div class="shop-price"><canvas id="priceIcon1" width="25" height="25"></canvas> 500</div>
                <div class="shop-buy-controls" onclick="event.stopPropagation();">
                    <button class="shop-qty-btn" onclick="changeChestQuantity('electric', -1)">-</button>
                    <span id="qty-electric" class="shop-qty-value">1</span>
                    <button class="shop-qty-btn" onclick="changeChestQuantity('electric', 1)">+</button>
                    <button class="shop-buy-btn" onclick="buyChest('electric')">COMPRAR</button>
                </div>
            </div>
            <div class="shop-card" data-chest="fortune">
                <canvas id="iconChestFortune" width="120" height="120"></canvas>
                <h3>COFRE FORTUNA</h3>
                <p>Cartas: +Raro Chance</p>
                <div class="shop-price"><canvas id="priceIcon2" width="25" height="25"></canvas> 1200</div>
                <div class="shop-buy-controls" onclick="event.stopPropagation();">
                    <button class="shop-qty-btn" onclick="changeChestQuantity('fortune', -1)">-</button>
                    <span id="qty-fortune" class="shop-qty-value">1</span>
                    <button class="shop-qty-btn" onclick="changeChestQuantity('fortune', 1)">+</button>
                    <button class="shop-buy-btn" onclick="buyChest('fortune')">COMPRAR</button>
                </div>
            </div>
            <div class="shop-card" data-chest="iron">
                <canvas id="iconChestIron" width="120" height="120"></canvas>
                <h3>COFRE DE HIERRO</h3>
                <p>Alta Chance Poco Común</p>
                <div class="shop-price"><canvas id="priceIcon3" width="25" height="25"></canvas> 2000</div>
                <div class="shop-buy-controls" onclick="event.stopPropagation();">
                    <button class="shop-qty-btn" onclick="changeChestQuantity('iron', -1)">-</button>
                    <span id="qty-iron" class="shop-qty-value">1</span>
                    <button class="shop-qty-btn" onclick="changeChestQuantity('iron', 1)">+</button>
                    <button class="shop-buy-btn" onclick="buyChest('iron')">COMPRAR</button>
                </div>
            </div>
            <div class="shop-card" data-chest="gold">
                <canvas id="iconChestGold" width="120" height="120"></canvas>
                <h3>COFRE DE ORO</h3>
                <p>Alta Chance Epico</p>
                <div class="shop-price"><canvas id="priceIcon4" width="25" height="25"></canvas> 5000</div>
                <div class="shop-buy-controls" onclick="event.stopPropagation();">
                    <button class="shop-qty-btn" onclick="changeChestQuantity('gold', -1)">-</button>
                    <span id="qty-gold" class="shop-qty-value">1</span>
                    <button class="shop-qty-btn" onclick="changeChestQuantity('gold', 1)">+</button>
                    <button class="shop-buy-btn" onclick="buyChest('gold')">COMPRAR</button>
                </div>
            </div>
            <div class="shop-card" data-chest="diamond">
                <canvas id="iconChestDiamond" width="120" height="120"></canvas>
                <h3>COFRE DIAMANTE</h3>
                <p>Garantizado Legendario+</p>
                <div class="shop-price"><canvas id="priceIcon5" width="25" height="25"></canvas> 10000</div>
                <div class="shop-buy-controls" onclick="event.stopPropagation();">
                    <button class="shop-qty-btn" onclick="changeChestQuantity('diamond', -1)">-</button>
                    <span id="qty-diamond" class="shop-qty-value">1</span>
                    <button class="shop-qty-btn" onclick="changeChestQuantity('diamond', 1)">+</button>
                    <button class="shop-buy-btn" onclick="buyChest('diamond')">COMPRAR</button>
                </div>
            </div>
            <div class="shop-card" data-chest="cosmic">
                <canvas id="iconChestCosmic" width="120" height="120"></canvas>
                <h3>COFRE CÓSMICO</h3>
                <p>¡El Poder del Universo!</p>
                <div class="shop-price"><canvas id="priceIcon6" width="25" height="25"></canvas> 25000</div>
                <div class="shop-buy-controls" onclick="event.stopPropagation();">
                    <button class="shop-qty-btn" onclick="changeChestQuantity('cosmic', -1)">-</button>
                    <span id="qty-cosmic" class="shop-qty-value">1</span>
                    <button class="shop-qty-btn" onclick="changeChestQuantity('cosmic', 1)">+</button>
                    <button class="shop-buy-btn" onclick="buyChest('cosmic')">COMPRAR</button>
                </div>
            </div>
            <!-- Event Offers in Shop -->
            <div id="shopEventOffers" class="shop-offer-wrap" style="display:none;"></div>
        </div>
        <div id="shopChestStash" class="shop-chest-stash">
            <div class="shop-chest-stash-title">COFRES ALMACENADOS</div>
            <div id="shopChestStashGrid" class="shop-chest-stash-grid"></div>
        </div>
    </div>

    <!-- MODAL DE APERTURA DE COFRE -->
    <div id="chestModal" class="chest-modal">
        <div class="chest-modal-content">
            <h1 id="chestTitle" style="color: var(--accent-cyan);">¡COFRE OBTENIDO!</h1>
            <div id="chestContainer" class="chest-container" onclick="openChestAnimation()">
                <canvas id="chestCanvas" width="300" height="300"></canvas>
            </div>
            <p id="chestInstruction" style="margin-top: 20px; color: #888;">TOCA PARA ABRIR</p>
            <div id="chestReward" class="chest-rewards">
                <!-- Premio aquí -->
            </div>
            <button id="chestCloseBtn" class="menu-btn" style="display: none; margin-top: 40px;"
                onclick="closeChestModal()">CONTINUAR</button>
        </div>
    </div>

    <!-- PANTALLA DE EVENTOS (REDESIGN PREMIUM) -->
    <div id="eventsScreen"
        style="display:none; position:fixed; inset:0; z-index:2000; overflow-y:auto; background:linear-gradient(180deg,#0a0014 0%,#1a0a2e 40%,#0d0020 100%);">
        <button class="back-btn" onclick="showMainMenu()">← VOLVER</button>
        <div class="evt-layout">
            <!-- Hero Banner -->
            <div id="evtHero" class="evt-hero">
                <div style="position:relative;z-index:1;flex:1;">
                    <div id="evtBadge"
                        style="display:inline-block;padding:5px 15px;border-radius:8px;font-family:'Orbitron';font-size:0.7rem;font-weight:900;letter-spacing:2px;margin-bottom:15px;">
                    </div>
                    <h1 id="evtTitle"
                        style="font-family:'Orbitron';font-weight:900;font-size:2.2rem;margin-bottom:10px;"></h1>
                    <p id="evtDesc" style="font-size:1rem;color:rgba(255,255,255,0.7);line-height:1.6;"></p>
                </div>
                <div id="evtRacerBox" style="position:relative;z-index:1;text-align:center;">
                    <canvas id="evtRacerCvs" width="150" height="150"
                        style="filter:drop-shadow(0 0 25px rgba(255,255,255,0.4));"></canvas>
                    <div id="evtRacerName" style="font-family:'Orbitron';font-size:1rem;margin-top:8px;"></div>
                    <div id="evtRacerRarity"
                        style="font-size:0.7rem;padding:3px 12px;border-radius:20px;display:inline-block;margin-top:5px;font-weight:700;">
                    </div>
                </div>
            </div>
            <!-- Countdown -->
            <div id="evtCountdown" class="evt-panel evt-countdown">
                <span
                    style="font-family:'Orbitron';font-size:0.75rem;color:rgba(255,255,255,0.5);letter-spacing:2px;">⏱️
                    TERMINA EN</span>
                <div id="evtCdDigits" style="display:flex;gap:20px;"></div>
            </div>
            <!-- Timeline -->
            <div class="evt-panel">
                <h3
                    style="font-family:'Orbitron';font-size:0.8rem;color:var(--accent-cyan);letter-spacing:2px;margin-bottom:15px;">
                    📅 CALENDARIO DE EVENTOS</h3>
                <div id="evtTimeline"></div>
            </div>
            <!-- Offers -->
            <div id="evtOffersPanel" class="evt-panel" style="display:none;">
                <h3
                    style="font-family:'Orbitron';font-size:0.8rem;color:var(--accent-gold);letter-spacing:2px;margin-bottom:15px;">
                    🔥 OFERTAS DEL EVENTO</h3>
                <div id="evtOffersList"
                    style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:15px;"></div>
            </div>
            <!-- Missions -->
            <div class="evt-panel">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
                    <h3 style="font-family:'Orbitron';font-size:0.8rem;color:var(--accent-pink);letter-spacing:2px;">🎯
                        MISIONES DE EVENTO</h3>
                    <div style="text-align:right;">
                        <span id="eventTimer" style="color:#fff;font-size:0.85rem;"></span><br>
                        <button onclick="resetEventMissionsManual()" id="btnResetMissions"
                            style="background:rgba(255,215,0,0.15);border:1px solid var(--accent-gold);color:var(--accent-gold);border-radius:8px;padding:5px 12px;cursor:pointer;font-weight:700;margin-top:5px;font-size:0.8rem;">Resetear
                            (<span id="resetCostDisplay">100</span> VB)</button>
                    </div>
                </div>
                <div id="eventRacerSelector" class="event-racer-selector"></div>
                <div id="eventMissionList" style="display:flex;flex-direction:column;gap:8px;"></div>
            </div>
        </div>
    </div>

    <script>
        // ==================== DATOS DEL JUEGO ====================
        const GameColors = {
            cyan: '#00f7ff',
            purple: '#a855f7',
            pink: '#ff3e8d',
            gold: '#ffd700'
        };

        let GameData = {
            voltBits: 500,
            xp: 0,
            level: 1,
            unlockedCharacters: ['blaze'],
            characterLevels: { blaze: 1 },
            characterCards: {},
            selectedCharacter: 'blaze',
            selectedMode: 'CLASSIC',
            selectedMap: 'neon_city',
            selectedCup: 'cyber_cup',
            eventTargetRacer: 'elemental_aqua',
            completedMissions: [],
            lastMissionDate: null,
            lastMissionResetTime: 0,
            missionResetCost: 100, // Default price
            consecutiveWins: 0,
            chestInventory: {
                electric: 0,
                fortune: 0,
                iron: 0,
                gold: 0,
                diamond: 0,
                cosmic: 0
            }
        };

        // ==================== VARIABLES GLOBALES DE JUEGO ====================
        let canvas, ctx;
        let animationId;
        const LANE_COUNT = 4;
        let FINISH_DISTANCE = 5000;

        function saveGame() {
            localStorage.setItem('velocity_surge_save', JSON.stringify(GameData));
        }

        function loadGame() {
            const saved = localStorage.getItem('velocity_surge_save');
            if (saved) {
                const data = JSON.parse(saved);
                GameData = { ...GameData, ...data };
            }
        }

        // Cargar datos al iniciar
        loadGame();

        const CHARACTERS = {
            // COMÚN (10)
            blaze: { name: 'BLAZE', rarity: 'common', color: '#ff4500', secondaryColor: '#ff8a00', effect: 'Fuego - Velocidad pura', stats: { speed: 6.2, accel: 7.5, handling: 5, weight: 6 }, projectile: { name: 'Bola de Fuego', effect: 'blaze_fireball' }, turbo: { name: 'Post-combustión', boost: 1.9, effect: 'fire_trail' }, trap: { name: 'Mina Térmica', effect: 'blaze_mine', duration: 2.0 }, unlocked: true, price: 0 },
            frost: { name: 'FROST', rarity: 'common', color: '#00d4ff', secondaryColor: '#7fefff', effect: 'Hielo - Control absoluto', stats: { speed: 5, accel: 6, handling: 8, weight: 5 }, projectile: { name: 'Lanza Gélida', effect: 'freeze' }, turbo: { name: 'Túnel de Hielo', boost: 1.9, effect: 'ice_dash' }, trap: { name: 'Pincho de Escarcha', effect: 'stun' }, unlocked: false, price: 200 },
            cobra: { name: 'COBRA', rarity: 'common', color: '#4caf50', secondaryColor: '#ffeb3b', effect: 'Cobra - Picadura letal', stats: { speed: 6.5, accel: 7.5, handling: 8, weight: 4 }, projectile: { name: 'Dardo Venenoso', effect: 'slow' }, turbo: { name: 'Culebreo', boost: 1.9 }, trap: { name: 'Rastro de Veneno', effect: 'slow', duration: 3 }, unlocked: false, price: 150 },
            neutron: { name: 'NEUTRON', rarity: 'common', color: '#90a4ae', secondaryColor: '#cfd8dc', effect: 'Neutrón - Masa compacta', stats: { speed: 5, accel: 6, handling: 7, weight: 9 }, projectile: { name: 'Pulso Pesado', effect: 'knockback' }, turbo: { name: 'Inercia', boost: 1.5 }, trap: { name: 'Masa Crítica', effect: 'slow', duration: 2 }, unlocked: false, price: 300 },
            bone: { name: 'BONE', rarity: 'common', color: '#eeeeee', secondaryColor: '#9e9e9e', effect: 'Huesos - Resistencia', stats: { speed: 5, accel: 6, handling: 7, weight: 9 }, projectile: { name: 'Hueso Giratorio', effect: 'bone_swing' }, turbo: { name: 'Carrera Cadavérica', boost: 1.6 }, trap: { name: 'Pila de Huesos', effect: 'bone_pile_target' }, unlocked: false, price: 200 },
            mist: { name: 'MIST', rarity: 'common', color: '#cfd8dc', secondaryColor: '#546e7a', effect: 'Niebla - Misterio', stats: { speed: 6, accel: 7, handling: 9, weight: 3 }, projectile: { name: 'Estela de Aire', effect: 'mist_air_trail' }, turbo: { name: 'Camino de Nubes', boost: 1.8, effect: 'cloud_path_turbo' }, trap: { name: 'Mina de Aire', effect: 'tornado_trap_mine' }, unlocked: false, price: 250 },
            dust: { name: 'DUST', rarity: 'common', color: '#a1887f', secondaryColor: '#4e342e', effect: 'Polvo - Ceguera arena', stats: { speed: 6, accel: 6, handling: 6, weight: 5 }, projectile: { name: 'Explosión de Polvo', effect: 'dust_blind' }, turbo: { name: 'Ciclón Arena', boost: 1.8, effect: 'dust_cyclone' }, trap: { name: 'Tormenta de Polvo', effect: 'dust_storm', duration: 4 }, unlocked: false, price: 180 },
            leaf: { name: 'LEAF', rarity: 'common', color: '#8bc34a', secondaryColor: '#33691e', effect: 'Hoja - Agilidad selva', stats: { speed: 5, accel: 8, handling: 9, weight: 3 }, projectile: { name: 'Estela de Hoja', effect: 'leaf_trail_active' }, turbo: { name: 'Viento', boost: 1.7 }, trap: { name: 'Enredaderas', effect: 'vines_trap' }, unlocked: false, price: 220 },
            rust: { name: 'RUST', rarity: 'common', color: '#795548', secondaryColor: '#3e2723', effect: 'Óxido - Blindaje chatarra', stats: { speed: 5.5, accel: 6.5, handling: 5, weight: 14 }, projectile: { name: 'Tornillo Pesado', effect: 'knockback' }, turbo: { name: 'Empujón Hidráulico', boost: 2.0 }, trap: { name: 'Clavo Oxidado', effect: 'stun', duration: 2 }, unlocked: false, price: 150 },
            spark: { name: 'SPARK', rarity: 'common', color: '#fff176', secondaryColor: '#fbc02d', effect: 'Chispa - Pequeño impulso', stats: { speed: 7, accel: 8, handling: 7, weight: 2 }, projectile: { name: 'Chispazo', effect: 'stun' }, turbo: { name: 'Flash', boost: 1.8 }, trap: { name: 'Cortocircuito', effect: 'slow', duration: 1 }, unlocked: false, price: 300 },

            // POCO COMÚN (10)
            volt: { name: 'VOLT', rarity: 'uncommon', color: '#ffeb3b', secondaryColor: '#fff59d', effect: 'Voltaje - Rayo rápido', stats: { speed: 8, accel: 9, handling: 6, weight: 4 }, projectile: { name: 'Nube de Tormenta', effect: 'storm_cloud' }, turbo: { name: 'Impulso Relámpago', boost: 2.2, effect: 'electric_dash' }, trap: { name: 'Emboscada Eléctrica', effect: 'triple_storm' }, unlocked: false, price: 500 },
            terra: { name: 'TERRA', rarity: 'uncommon', color: '#8d6e63', secondaryColor: '#a1887f', effect: 'Tierra - Fuerza colosal', stats: { speed: 4, accel: 5, handling: 4, weight: 10 }, projectile: { name: 'Roca Colosal', effect: 'faint', damage: 300, duration: 3 }, turbo: { name: 'Embate Rocoso', boost: 1.4, effect: 'rock_collision' }, trap: { name: 'Camino Galopante', effect: 'rock_path', duration: 1.5 }, unlocked: false, price: 500 },
            gear: { name: 'GEAR', rarity: 'uncommon', color: '#9e9e9e', secondaryColor: '#424242', effect: 'Mecánico - Chatarra destructiva', stats: { speed: 6, accel: 6, handling: 5, weight: 10 }, projectile: { name: 'Sierra Industrial', effect: 'stun' }, turbo: { name: 'Sobrevelocidad', boost: 1.8 }, trap: { name: 'Mina de Chatarra', effect: 'rock_collision', duration: 1.2 }, unlocked: false, price: 800 },
            blade: { name: 'BLADE', rarity: 'uncommon', color: '#cfd8dc', secondaryColor: '#37474f', effect: 'Espada - Filo cortante', stats: { speed: 7, accel: 7, handling: 7, weight: 6 }, projectile: { name: 'Sierra Disco', effect: 'knockback' }, turbo: { name: 'Tajo Fugaz', boost: 2.0 }, trap: { name: 'Abrojos', effect: 'slow', duration: 1.5 }, unlocked: false, price: 600 },
            scarab: { name: 'SCARAB', rarity: 'uncommon', color: '#795548', secondaryColor: '#ffd600', effect: 'Escarabajo - Arena', stats: { speed: 6, accel: 7, handling: 8, weight: 7 }, projectile: { name: 'Dardo Solar', effect: 'burn' }, turbo: { name: 'Vuelo de Arena', boost: 1.8 }, trap: { name: 'Trampa de Arena', effect: 'sand_trap', duration: 3 }, unlocked: false, price: 750 },
            raider: { name: 'RAIDER', rarity: 'uncommon', color: '#ff5722', secondaryColor: '#bf360c', effect: 'Saqueador - Velocidad salvaje', stats: { speed: 7, accel: 7.5, handling: 6, weight: 7 }, projectile: { name: 'Arpón Chatarra', effect: 'knockback' }, turbo: { name: 'Turbo Óxido', boost: 1.9 }, trap: { name: 'Red de Cables', effect: 'slow', duration: 2.5 }, unlocked: false, price: 850 },
            sludge: { name: 'SLUDGE', rarity: 'uncommon', color: '#4e342e', secondaryColor: '#212121', effect: 'Lodo - Pantano tóxico', stats: { speed: 5, accel: 5, handling: 4, weight: 12 }, projectile: { name: 'Bola de Barro', effect: 'slow' }, turbo: { name: 'Deslizamiento', boost: 1.8 }, trap: { name: 'Pantano', effect: 'slow', duration: 3.5 }, unlocked: false, price: 650 },
            drift: { name: 'DRIFT', rarity: 'uncommon', color: '#ff1744', secondaryColor: '#880e4f', effect: 'Derrape - Velocidad pura', stats: { speed: 7, accel: 9, handling: 7, weight: 4 }, projectile: { name: 'Aceite', effect: 'slip' }, turbo: { name: 'Nitro', boost: 1.9 }, trap: { name: 'Neumático', effect: 'knockback', duration: 1 }, unlocked: false, price: 700 },
            steam: { name: 'STEAM', rarity: 'uncommon', color: '#b0bec5', secondaryColor: '#546e7a', effect: 'Vapor - Cortina humo', stats: { speed: 7, accel: 7, handling: 8, weight: 6 }, projectile: { name: 'Vapor Presión', effect: 'burn' }, turbo: { name: 'Válvula', boost: 1.9 }, trap: { name: 'Niebla', effect: 'blind', duration: 2 }, unlocked: false, price: 550 },
            shell: { name: 'SHELL', rarity: 'uncommon', color: '#81c784', secondaryColor: '#2e7d32', effect: 'Caparazón - Escudo', stats: { speed: 5, accel: 5, handling: 6, weight: 11 }, projectile: { name: 'Púas', effect: 'slow' }, turbo: { name: 'Arremetida', boost: 1.7 }, trap: { name: 'sand_trap', effect: 'slip', duration: 1 }, unlocked: false, price: 650 },

            // RARO (10)
            shadow: { name: 'SHADOW', rarity: 'rare', color: '#6a1b9a', secondaryColor: '#9c4dcc', effect: 'Sombra - Invisibilidad', stats: { speed: 7, accel: 8, handling: 9, weight: 3 }, projectile: { name: 'Orbe Oscuro', effect: 'blind', damage: 1 }, turbo: { name: 'Paso Sombrío', boost: 1.7 }, trap: { name: 'Portal Oscuro', effect: 'teleport', duration: 0 }, unlocked: false, price: 1000 },
            aqua: { name: 'AQUA', rarity: 'rare', color: '#00bcd4', secondaryColor: '#4dd0e1', effect: 'Agua - Tsunami', stats: { speed: 7.8, accel: 6.5, handling: 8, weight: 7 }, projectile: { name: 'Burbuja de Agua', effect: 'progressive_bubble' }, turbo: { name: 'Tornado Acuático', boost: 2.4, effect: 'water_tornado' }, trap: { name: 'Tsunami Devastador', effect: 'tsunami_trap', duration: 2 }, unlocked: false, price: 1200 },
            magma: { name: 'MAGMA', rarity: 'rare', color: '#bf360c', secondaryColor: '#212121', effect: 'Magma - Fusión', stats: { speed: 7, accel: 6, handling: 5, weight: 9 }, projectile: { name: 'Bomba de Lava', effect: 'burn' }, turbo: { name: 'Erupción', boost: 1.9 }, trap: { name: 'Charco de Magma', effect: 'slow', duration: 3 }, unlocked: false, price: 1100 },
            pulse: { name: 'PULSE', rarity: 'rare', color: '#00e5ff', secondaryColor: '#d500f9', effect: 'Pulso - Digital', stats: { speed: 8, accel: 8, handling: 9, weight: 4 }, projectile: { name: 'Rayo de Datos', effect: 'stun' }, turbo: { name: 'Sobre-impulso', boost: 2.1 }, trap: { name: 'Mina Glitch', effect: 'slip', duration: 1 }, unlocked: false, price: 1050 },
            ion: { name: 'ION', rarity: 'rare', color: '#26c6da', secondaryColor: '#80deea', effect: 'Ion - Rayos', stats: { speed: 7.5, accel: 8.5, handling: 7.5, weight: 5 }, projectile: { name: 'Cadena Eléctrica', effect: 'chain_lightning' }, turbo: { name: 'Sobrecarga Iónica', boost: 2.1 }, trap: { name: 'Mina Iónica', effect: 'stun', duration: 1 }, unlocked: false, price: 1350 },
            spirit: { name: 'SPIRIT', rarity: 'rare', color: '#e0f2f1', secondaryColor: '#80cbc4', effect: 'Espíritu - Esencia', stats: { speed: 7.8, accel: 8.2, handling: 8.5, weight: 4 }, projectile: { name: 'Llama Fátua', effect: 'burn' }, turbo: { name: 'Vuelo de Alma', boost: 2.2 }, trap: { name: 'Pozo de Almas', effect: 'star_sink', duration: 2.5 }, unlocked: false, price: 1450 },
            cyber: { name: 'CYBER', rarity: 'rare', color: '#00e676', secondaryColor: '#00c853', effect: 'Cíber - Datos', stats: { speed: 8, accel: 8.5, handling: 8.5, weight: 6 }, projectile: { name: 'Bit-fuego', effect: 'burn' }, turbo: { name: 'Overclock', boost: 2.3 }, trap: { name: 'Mina-Bug', effect: 'slip', duration: 1.2 }, unlocked: false, price: 1550 },
            bone_rare: { name: 'BONE RARE', rarity: 'rare', color: '#8d6e63', secondaryColor: '#d7ccc8', effect: 'Huesos - Estructura', stats: { speed: 8, accel: 8, handling: 9, weight: 6 }, projectile: { name: 'Bone Swing', effect: 'bone_swing' }, turbo: { name: 'Esqueleto Veloz', boost: 2.3, effect: 'bone_shield' }, trap: { name: 'Bone Pile', effect: 'bone_pile_target', duration: 3 }, unlocked: false, price: 1500 },
            leaf_rare: { name: 'LEAF RARE', rarity: 'rare', color: '#4caf50', secondaryColor: '#8bc34a', effect: 'Hoja - Naturaleza', stats: { speed: 8, accel: 9, handling: 8, weight: 5 }, projectile: { name: 'Leaf Trail', effect: 'leaf_trail' }, turbo: { name: 'Viento Hoja', boost: 2.3, effect: 'leaf_dash' }, trap: { name: 'Vines Trap', effect: 'vines_trap', duration: 4 }, unlocked: false, price: 1800 },
            mist_rare: { name: 'MIST RARE', rarity: 'rare', color: '#90a4ae', secondaryColor: '#cfd8dc', effect: 'Niebla - Oculto', stats: { speed: 8, accel: 8, handling: 10, weight: 4 }, projectile: { name: 'Air Trail', effect: 'mist_trail' }, turbo: { name: 'Cloud Path', boost: 2.2, effect: 'cloud_path' }, trap: { name: 'Air Mine', effect: 'tornado_trap_mine', duration: 3.5 }, unlocked: false, price: 2000 },

            // ÉPICO (10)
            storm: { name: 'STORM', rarity: 'epic', color: '#1e88e5', secondaryColor: '#002f6c', effect: 'Tormenta - Rugido', stats: { speed: 7, accel: 8, handling: 7, weight: 6 }, projectile: { name: 'Storm Seeker', effect: 'storm_seeker_new' }, turbo: { name: 'Ojo del Huracán', boost: 2.3, effect: 'storm_surge' }, trap: { name: 'Storm Block', effect: 'storm_block', duration: 3 }, unlocked: false, price: 2500 },
            neutron_legendary: { name: 'NEUTRON LEGENDARY', rarity: 'legendary', color: '#64ffda', secondaryColor: '#18ffff', effect: 'Neutrón - Partículas', stats: { speed: 7.5, accel: 8, handling: 8, weight: 7 }, projectile: { name: 'Neutron Blast', effect: 'neutron_blast' }, turbo: { name: 'Impulso Neutrónico', boost: 2.0, effect: 'neutron_propulsion' }, trap: { name: 'Órbita Neutrónica', effect: 'neutron_orbit', duration: 5 }, unlocked: false, price: 6000 },
            nebula: { name: 'NEBULA', rarity: 'epic', color: '#ff00ff', secondaryColor: '#4a148c', effect: 'Nebulosa - Vacío', stats: { speed: 8, accel: 8, handling: 7, weight: 5 }, projectile: { name: 'Cometa de Energía', effect: 'blind' }, turbo: { name: 'Pulso Galáctico', boost: 2.1 }, trap: { name: 'Velo de Polvo', effect: 'void_trap', duration: 2.5 }, unlocked: false, price: 4000 },
            resonance: { name: 'RESONANCE', rarity: 'epic', color: '#d1c4e9', secondaryColor: '#5e35b1', effect: 'Resonancia - Sónico', stats: { speed: 8, accel: 8, handling: 8, weight: 5 }, projectile: { name: 'Sonic Beam', effect: 'electric_beam_charge' }, turbo: { name: 'Sonic Overload', boost: 2.6, effect: 'sonic_overload' }, trap: { name: 'Electric Mines (3)', effect: 'electric_mines_triple' }, unlocked: false, price: 3500 },
            witch: { name: 'WITCH', rarity: 'epic', color: '#311b92', secondaryColor: '#ffd600', effect: 'Bruja - Caos', stats: { speed: 8, accel: 7, handling: 8, weight: 5 }, projectile: { name: 'Hechizo Oscuro', effect: 'faint' }, turbo: { name: 'Escoba Veloz', boost: 2.3 }, trap: { name: 'Pócima Lentitud', effect: 'slow', duration: 4 }, unlocked: false, price: 3800 },
            phantom: { name: 'PHANTOM', rarity: 'epic', color: '#7e57c2', secondaryColor: '#b39ddb', effect: 'Fantasma - Espectral', stats: { speed: 8, accel: 8, handling: 9, weight: 4 }, projectile: { name: 'Orbe Espectral', effect: 'blind' }, turbo: { name: 'Velo Espectral', boost: 2.4, effect: 'intangible' }, trap: { name: 'Clon Ilusión', effect: 'shadow_clone', duration: 2 }, unlocked: false, price: 4200 },

            // LEGENDARIO (6)
            crimson: { name: 'CRIMSON', rarity: 'legendary', color: '#b71c1c', secondaryColor: '#ff5252', effect: 'Crimson - Blood Fury', stats: { speed: 8.5, accel: 8, handling: 7, weight: 8 }, projectile: { name: 'Esfera de Sangre', effect: 'slow' }, turbo: { name: 'Vampirismo', boost: 2.5, effect: 'life_steal' }, trap: { name: 'Espinas Carmesí', effect: 'slow', duration: 4 }, unlocked: false, price: 4500 },
            omega: { name: 'OMEGA', rarity: 'legendary', color: '#00e5ff', secondaryColor: '#ffffff', effect: 'Omega - El Final', stats: { speed: 9, accel: 9, handling: 6, weight: 10 }, projectile: { name: 'Rayo Omega', effect: 'stun' }, turbo: { name: 'Singularidad', boost: 2.8, effect: 'invul' }, trap: { name: 'Agujero Negro', effect: 'stop', duration: 2 }, unlocked: false, price: 5000 },
            titan: { name: 'TITAN', rarity: 'legendary', color: '#ffffff', secondaryColor: '#90a4ae', effect: 'Titán - Blindaje pesado', stats: { speed: 5, accel: 4, handling: 3, weight: 20 }, projectile: { name: 'Muro de Piedra', effect: 'knockback' }, turbo: { name: 'Carga Sísmica', boost: 2.0, effect: 'repulsion' }, trap: { name: 'Pilar de Roca', effect: 'stun', duration: 2 }, unlocked: false, price: 5000 },
            juggernaut: { name: 'JUGGERNAUT', rarity: 'legendary', color: '#ffc107', secondaryColor: '#795548', effect: 'Juggernaut - Indomable', stats: { speed: 6, accel: 5, handling: 4, weight: 18 }, projectile: { name: 'Bola de Demolición', effect: 'knockback' }, turbo: { name: 'Embestida Brutal', boost: 2.1 }, trap: { name: 'Mina de Gravedad', effect: 'slow', duration: 3 }, unlocked: false, price: 5000 },
            monarch: { name: 'MONARCH', rarity: 'legendary', color: '#f06292', secondaryColor: '#f8bbd0', effect: 'Realeza - Corazón', stats: { speed: 8, accel: 9, handling: 8, weight: 5 }, projectile: { name: 'Flecha Cupido', effect: 'charm' }, turbo: { name: 'Vuelo Real', boost: 2.2 }, trap: { name: 'Campo de Rosas', effect: 'slow', duration: 3 }, unlocked: false, price: 5000 },
            phoenix: { name: 'PHOENIX', rarity: 'legendary', color: '#ff5722', secondaryColor: '#ffab91', effect: 'Fénix - Llamas', stats: { speed: 9, accel: 8, handling: 7, weight: 5 }, projectile: { name: 'Plumas de Fuego', effect: 'fire_fan' }, turbo: { name: 'Ignición Escarlata', boost: 2.2, effect: 'fire_trail' }, trap: { name: 'Nido de Cenizas', effect: 'ash_trap', duration: 4 }, unlocked: false, price: 5000 },

            // MITICO (1)
            glitch: { name: 'GLITCH', rarity: 'mythic', color: '#00ff41', secondaryColor: '#ffffff', effect: 'Glitch - Reality Warp', stats: { speed: 9.5, accel: 9.5, handling: 9.5, weight: 5 }, projectile: { name: 'Error Cube', effect: 'glitch' }, turbo: { name: 'Desync', boost: 3.0, effect: 'intangible' }, trap: { name: 'Zona Nula', effect: 'slip', duration: 1.5 }, unlocked: false, price: 10000 },
        };

        const CARD_REQUIREMENTS = {
            common: 10,
            uncommon: 20,
            rare: 50,
            epic: 100,
            legendary: 200,
            mythic: 500
        };

        const CHEST_TYPES = {
            electric: { name: 'COFRE ELÉCTRICO', price: 500, minBits: 100, maxBits: 200, cardChance: 0.1, cardAmount: [1, 3], rarityWeights: { common: 0.8, uncommon: 0.2 } },
            fortune: { name: 'COFRE DE LA FORTUNA', price: 1200, minBits: 200, maxBits: 350, cardChance: 0.3, cardAmount: [2, 5], rarityWeights: { common: 0.5, uncommon: 0.4, rare: 0.1 } },
            iron: { name: 'COFRE DE HIERRO', price: 2000, minBits: 300, maxBits: 500, cardChance: 0.5, cardAmount: [4, 8], rarityWeights: { uncommon: 0.6, rare: 0.3, epic: 0.1 } },
            gold: { name: 'COFRE DE ORO', price: 5000, minBits: 600, maxBits: 1000, cardChance: 0.8, cardAmount: [8, 15], rarityWeights: { rare: 0.6, epic: 0.3, legendary: 0.1 } },
            diamond: { name: 'COFRE DE DIAMANTE', price: 10000, minBits: 1500, maxBits: 3000, cardChance: 1.0, cardAmount: [15, 30], rarityWeights: { epic: 0.6, legendary: 0.35, mythic: 0.05 } },
            cosmic: { name: 'COFRE CÓSMICO', price: 25000, minBits: 4000, maxBits: 8000, cardChance: 1.0, cardAmount: [40, 80], rarityWeights: { legendary: 0.8, mythic: 0.2 } },
            battle_1: { name: 'COFRE DE VICTORIA', minBits: 800, maxBits: 1400, cardAmount: [8, 14], rarityWeights: { uncommon: 0.3, rare: 0.45, epic: 0.2, legendary: 0.05 } },
            battle_2: { name: 'COFRE DE BATALLA PLATA', minBits: 500, maxBits: 900, cardAmount: [6, 11], rarityWeights: { common: 0.2, uncommon: 0.4, rare: 0.3, epic: 0.1 } },
            battle_3: { name: 'COFRE DE BATALLA BRONCE', minBits: 300, maxBits: 650, cardAmount: [4, 8], rarityWeights: { common: 0.45, uncommon: 0.35, rare: 0.18, epic: 0.02 } },
            battle_4: { name: 'COFRE DE SUPERACIÓN', minBits: 180, maxBits: 420, cardAmount: [2, 5], rarityWeights: { common: 0.65, uncommon: 0.28, rare: 0.07 } }
        };

        const CUPS = {
            cyber_cup: { name: 'CYBER CUP', maps: ['neon_city', 'matrix_city', 'cyber_realm', 'industrial_block'] },
            elemental_cup: { name: 'ELEMENTAL CUP', maps: ['frozen_peaks', 'volcanic', 'jungle_temple', 'sky_kingdom'] },
            mystic_cup: { name: 'MYSTIC CUP', maps: ['crystal_caves', 'phantom_zone', 'olympus_ruins', 'bone_valley'], mode: 'KNOCKOUT' },
            cosmic_cup: { name: 'COPA CÓSMICA', maps: ['asteroid_belt', 'galaxy_core', 'void_rift'] },
            void_cup: { name: 'VOID CUP', maps: ['deep_sea', 'orbital_station', 'mecha_valley', 'void_dimension'] },
            chaos_cup: { name: 'CHAOS CUP', maps: ['nova_core', 'energy_nexus', 'crystal_abyss', 'obsidian_gate', 'chaos_highway', 'glitch_void'] }
        };

        const MODES = {
            CLASSIC: { name: 'CLÁSICO', desc: 'Carrera estándar de supervivencia.' },
            TIME_ATTACK: { name: 'TIME ATTACK', desc: 'Sin rivales. Solo tú y la velocidad absoluta.' },
            STRIKE: { name: 'STRIKE', desc: 'Gana puntos extra dañando a tus oponentes.' },
            KNOCKOUT: { name: 'KNOCKOUT', desc: '¡El último lugar es eliminado cada 25%!' },
            SANDBOX: { name: 'SANDBOX', desc: 'Prueba libre: desconecta/reconecta corredor y bots durante la carrera.' }
        };

        const MAPS = {
            neon_city: { name: 'Ciudad Neón', bgColor: '#1a0a2e', trackColor: '#2d1b4e', icon: 'map_neon', description: 'Luces brillantes y asfalto sintético', particles: 'neon', accentColor: '#ff00ff', distance: 16000, props: 'neon_sign' },
            matrix_city: { name: 'Matrix City', bgColor: '#001a00', trackColor: '#002200', icon: 'map_matrix', description: 'El mundo digital en código verde', particles: 'neon', accentColor: '#00ff00', distance: 22000, props: 'matrix_data' },
            cyber_realm: { name: 'Plano Cibernético', bgColor: '#000000', trackColor: '#003300', icon: 'map_cyber', description: 'Flujos de datos interconectados', particles: 'neon', accentColor: '#00ff00', distance: 25000, props: 'glitch_box' },
            industrial_block: { name: 'Puerto Industrial', bgColor: '#212121', trackColor: '#424242', icon: 'map_industrial', description: 'Grúas y chatarra en óxido', particles: 'smoke', accentColor: '#ffa000', distance: 17000, props: 'scrap' },
            frozen_peaks: { name: 'Picos Helados', bgColor: '#0a1a2e', trackColor: '#1b3a5e', icon: 'map_frozen', description: 'Pistas bajo cero y nieve eterna', particles: 'snow', accentColor: '#00d4ff', distance: 16000, props: 'ice_spike' },
            volcanic: { name: 'Volcán Activo', bgColor: '#2e0a0a', trackColor: '#4e1b1b', icon: 'map_volcanic', description: 'Lava ardiente y cenizas', particles: 'ember', accentColor: '#ff4500', distance: 18000, props: 'lava_lamp' },
            jungle_temple: { name: 'Templo de la Selva', bgColor: '#1b5e20', trackColor: '#33691e', icon: 'map_jungle', description: 'Ruinas cubiertas de vegetación', particles: 'leaf', accentColor: '#76ff03', distance: 21000, props: 'vine' },
            sky_kingdom: { name: 'Reino de las Nubes', bgColor: '#bbdefb', trackColor: '#e3f2fd', icon: 'map_sky', description: 'Carreras entre castillos flotantes', particles: 'snow', accentColor: '#ffffff', distance: 18000, props: 'cloud' },
            crystal_caves: { name: 'Cuevas de Cristal', bgColor: '#004d40', trackColor: '#00695c', icon: 'map_crystal', description: 'Túneles brillantes de gemas', particles: 'stars', accentColor: '#1de9b6', distance: 19000, props: 'crystal' },
            phantom_zone: { name: 'Zona Fantasma', bgColor: '#1a0033', trackColor: '#330066', icon: 'map_ghost', description: 'Circuitos embrujados invisibles', particles: 'snow', accentColor: '#b39ddb', distance: 26000, props: 'ghost_flame' },
            olympus_ruins: { name: 'Ruinas del Olimpo', bgColor: '#3e2723', trackColor: '#4e342e', icon: 'map_olympus', description: 'Templos griegos y rayos', particles: 'embers', accentColor: '#ffeb3b', distance: 23000, hazards: 'pillars', props: 'column' },
            bone_valley: { name: 'Valle de los Huesos', bgColor: '#37474f', trackColor: '#546e7a', icon: 'map_bone', description: 'Fosas ancestrales y restos', particles: 'ember', accentColor: '#cfd8dc', distance: 19000, props: 'skull' },
            deep_sea: { name: 'Fosa Abisal', bgColor: '#01579b', trackColor: '#0277bd', icon: 'map_deep', description: 'Bajo el mar con medusas', particles: 'bubble', accentColor: '#00e5ff', distance: 23000, props: 'bubble_vent' },
            orbital_station: { name: 'Estación Orbital', bgColor: '#000a12', trackColor: '#102027', icon: 'map_orbit', description: 'Gravedad cero sobre la Tierra', particles: 'stars', accentColor: '#4fc3f7', distance: 21000, hazards: 'lasers', props: 'satellite' },
            mecha_valley: { name: 'Valle de los Mecas', bgColor: '#263238', trackColor: '#37474f', icon: 'map_mecha', description: 'Chatarra de robots gigantes', particles: 'smoke', accentColor: '#ff5722', distance: 24000, hazards: 'arms', props: 'gear_prop' },
            void_dimension: { name: 'Dimensión Zero', bgColor: '#000000', trackColor: '#0a0a0a', icon: 'map_zero', description: 'El vacío absoluto y velocidad', particles: 'neon', accentColor: '#ffffff', distance: 40000, props: 'singularity' },
            glitch_void: { name: 'Vacío Glitch', bgColor: '#000000', trackColor: '#1a1a1a', icon: 'map_glitch', description: 'Realidad fragmentada', particles: 'glitch', accentColor: '#00ff41', distance: 18000, props: 'glitch_block', hazards: 'distorsión' },
            asteroid_belt: { name: 'Cinturón Asteroides', bgColor: '#0b0014', trackColor: '#1a0d26', icon: 'map_space', description: 'Esquiva rocas espaciales', particles: 'stars', accentColor: '#ffaa00', distance: 15000, props: 'rock', hazards: 'asteroides' },
            galaxy_core: { name: 'Núcleo Galáctico', bgColor: '#1a0033', trackColor: '#2d004d', icon: 'map_space', description: 'Cerca del agujero negro', particles: 'nova', accentColor: '#ff00ff', distance: 20000, props: 'energy_crystal', hazards: 'gravedad' },
            void_rift: { name: 'Grieta del Vacío', bgColor: '#050505', trackColor: '#0f0f0f', icon: 'map_space', description: 'El final del multiverso', particles: 'void', accentColor: '#4a00e0', distance: 25000, props: 'void_pillar', hazards: 'anomalías' },
            nova_core: { name: 'Núcleo Nova', bgColor: '#4a148c', trackColor: '#7b1fa2', icon: 'map_core', description: 'Dentro de un sol estallando', particles: 'embers', accentColor: '#ff6f00', distance: 19000, props: 'solar_flare' },
            energy_nexus: { name: 'Nexo Energético', bgColor: '#000000', trackColor: '#1a1a1a', icon: 'map_energy', description: 'Rayos de plasma en el cielo', particles: 'neon', accentColor: '#76ff03', distance: 23000, props: 'plasma_arc' },
            crystal_abyss: { name: 'Abismo de Cristal', bgColor: '#006064', trackColor: '#00838f', icon: 'map_abyss', description: 'Cavernas profundas y gemas', particles: 'stars', accentColor: '#00e5ff', distance: 28000, props: 'crystal_giant' },
            obsidian_gate: { name: 'Puerta de Obsidiana', bgColor: '#000000', trackColor: '#1a1a1a', icon: 'map_obsidian', description: 'El fin del mundo. Máximo reto.', particles: 'neon', accentColor: '#f44336', distance: 30000, hazards: 'debris', props: 'rune' },
            chaos_highway: { name: 'Circuito Caos', bgColor: '#000000', trackColor: '#111111', icon: 'map_chaos', description: '¡Doble de cajas! Máximo caos.', particles: 'neon', accentColor: '#ff0000', extraItems: true, distance: 20000, props: 'error_cube' }
        };

        // ==================== CALENDARIO DE EVENTOS ====================
        const EVENTS_CALENDAR = (() => {
            const now = new Date();
            const activeStart = new Date(now);
            activeStart.setDate(now.getDate() - 1);
            activeStart.setHours(0, 0, 0, 0);
            const activeEnd = new Date(now);
            activeEnd.setDate(now.getDate() + 6);
            activeEnd.setHours(23, 59, 59, 999);
            const futureStart = new Date(activeEnd);
            futureStart.setDate(activeEnd.getDate() + 2);
            futureStart.setHours(0, 0, 0, 0);
            const futureEnd = new Date(futureStart);
            futureEnd.setDate(futureStart.getDate() + 7);
            futureEnd.setHours(23, 59, 59, 999);
            return [
                {
                    id: 'elemental_convergence',
                    name: 'ELEMENTAL CONVERGENCE',
                    shortName: 'ELEMENTALES',
                    color: '#00f7ff',
                    bgGradient: 'linear-gradient(135deg,#0a1734 0%,#1a0f2d 45%,#1e1408 100%)',
                    startDate: activeStart,
                    endDate: activeEnd,
                    featuredRacer: 'elemental_plasma',
                    racers: ['elemental_aqua', 'elemental_pyre', 'elemental_gale', 'elemental_terra', 'elemental_plasma', 'elemental_crystal', 'elemental_thunder'],
                    description: 'Evento activo. Elige un corredor elemental y recibe cofres de ese corredor en misiones.',
                    mapOverride: 'energy_nexus'
                },
                {
                    id: 'velocity_classics',
                    name: 'GLITCH PROTOCOL REPLAY',
                    shortName: 'GLITCH REPLAY',
                    color: '#7dff8a',
                    bgGradient: 'linear-gradient(135deg,#071a0d 0%,#1a0f2d 100%)',
                    startDate: futureStart,
                    endDate: futureEnd,
                    featuredRacer: 'glitch',
                    racers: ['glitch', 'elemental_plasma', 'pulse'],
                    description: 'Evento de repetición: vuelve GLITCH con recompensas remix.',
                    mapOverride: 'glitch_void'
                }
            ];
        })();

        const EVENT_OFFERS = {
            elemental_convergence: [
                {
                    id: 'elemental_pack_1',
                    name: 'PACK ELEMENTAL INICIAL',
                    desc: 'Desbloquea un corredor elemental + 20 tarjetas.',
                    price: 6800,
                    type: 'early',
                    gives: { character: 'elemental_pyre', cards: 20, bits: 0 },
                    pool: ['elemental_aqua', 'elemental_pyre', 'elemental_gale', 'elemental_terra', 'elemental_plasma', 'elemental_crystal', 'elemental_thunder'],
                    badgeText: 'NUEVO',
                    badgeColor: '#00f7ff',
                    chestType: null
                },
                {
                    id: 'elemental_pack_2',
                    name: 'ULTIMA CORRIENTE',
                    desc: 'Cofre elemental premium + 45 tarjetas.',
                    price: 9800,
                    originalPrice: 12400,
                    type: 'lastchance',
                    lastChanceDays: 3,
                    gives: { character: 'elemental_aqua', cards: 45, bits: 300 },
                    badgeText: '-21%',
                    badgeColor: '#ffd166',
                    chestType: 'event_chest_elemental_aqua'
                }
            ],
            velocity_classics: [
                {
                    id: 'glitch_replay_pack_1',
                    name: 'REPLAY PROTOCOL',
                    desc: 'Pack de repetición para GLITCH/PLASMA.',
                    price: 5900,
                    type: 'early',
                    gives: { character: 'glitch', cards: 25, bits: 350 },
                    badgeText: 'REPLAY',
                    badgeColor: '#7dff8a',
                    chestType: null
                }
            ]
        };

        // SISTEMA DE EVENTOS POR TEMPORADA
        let activeEvent = null;

        function applySeasonalEvents() {
            const now = new Date();
            const evt = EVENTS_CALENDAR.find(e => now >= e.startDate && now <= e.endDate) || null;
            activeEvent = evt ? evt.id : null;

            if (evt && evt.id === 'velocity_classics' && MAPS.glitch_void) {
                MAPS.glitch_void.name = "⚠️ ERROR DE SISTEMA ⚠️";
                MAPS.glitch_void.description = "EVENTO REPLAY: la realidad vuelve a colapsar.";
                MAPS.glitch_void.accentColor = "#00ff88";
                MAPS.glitch_void.extraItems = true;
            }
        }
        applySeasonalEvents();

        // ==================== ESTADO DEL JUEGO ====================
        let gameState = {
            running: false,
            trailer: false,
            trailerStage: 0,
            trailerTimer: 0,
            mode: 'CLASSIC',
            player: null,
            bots: [],
            items: [],
            projectiles: [],
            traps: [],
            props: [], // Objetos decorativos
            inventory: {
                projectile: null,
                turbo: null,
                trap: null
            },
            raceProgress: 0,
            positions: [],
            tsunamis: [],
            hitLog: [],
            cameraShake: 0,
            cameraZoom: 1,
            cameraAngle: 0,
            hitFlash: 0,
            slowMo: 1.0,
            eliminationTimer: 15.0,
            destructionPoints: 0,
            pendingRewards: [], // Cola de recompensas para no interrumpir
            turbosUsed: 0
        };


        // ==================== FUNCIONES DE UI ====================
        // ==================== SISTEMA DE MISIONES = [NUEVO] ====================
        const MISSION_TYPES = [
            { id: 'win_race', text: 'Gana una carrera', reward: 500, goal: 1 },
            { id: 'top_3', text: 'Termina en el Top 3', reward: 200, goal: 1 },
            { id: 'hit_opponents', text: 'Golpea a 5 rivales', reward: 300, goal: 5 },
            { id: 'collect_items', text: 'Recoge 10 cajas', reward: 150, goal: 10 },
            { id: 'use_turbo', text: 'Usa 3 turbos', reward: 200, goal: 3 }
        ];

        function initMissions() {
            const today = new Date().toDateString();
            if (GameData.lastMissionDate !== today) {
                GameData.lastMissionDate = today;
                GameData.completedMissions = [];
                // Generar 3 misiones aleatorias
                const shuffled = [...MISSION_TYPES].sort(() => 0.5 - Math.random());
                GameData.activeMissions = shuffled.slice(0, 3).map(m => ({ ...m, progress: 0 }));
                saveGame();
            }
            renderMissions();
        }

        function renderMissions() {
            const list = document.getElementById('missionList');
            if (!list) return;
            list.innerHTML = '';

            GameData.activeMissions.forEach((m, idx) => {
                const isCompleted = GameData.completedMissions.includes(m.id);
                const item = document.createElement('div');
                item.className = `mission-item ${isCompleted ? 'completed' : ''}`;
                item.innerHTML = `
                    <div style="display:flex; justify-content:space-between">
                        <span>${m.text}</span>
                        <span>${m.progress}/${m.goal}</span>
                    </div>
                    <div style="font-size:0.7rem; color: var(--accent-gold); display: flex; align-items: center; gap: 5px;">
                        RECOMPENSA: ${m.reward} <canvas id="missionCoin_${idx}" width="16" height="16"></canvas>
                    </div>
                `;
                list.appendChild(item);

                // Dibujar icono
                setTimeout(() => {
                    const ctx = document.getElementById(`missionCoin_${idx}`).getContext('2d');
                    renderRacerModel(ctx, 'currency_voltbit', 8, 8, 0.6, { color: '#00e5ff' });
                }, 0);
            });
        }

        function updateMissionProgress(type, amount = 1, isSet = false) {
            // Sandbox es libre: no avanza ni otorga recompensas de misiones.
            if (gameState && gameState.mode === 'SANDBOX' && gameState.running) {
                return;
            }

            // 1. MISIONES DIARIAS
            if (GameData.activeMissions) {
                GameData.activeMissions.forEach(m => {
                    if (m.id === type && !GameData.completedMissions.includes(m.id)) {
                        if (isSet) m.progress = amount;
                        else m.progress += amount;

                        if (m.progress >= m.goal) {
                            m.progress = m.goal;
                            completeMission(m);
                        }
                    }
                });
            }

            // 2. MISIONES DE EVENTO
            if (GameData.eventMissions) {
                GameData.eventMissions.forEach(m => {
                    if (!m.completed && m.id === type) {
                        if (isSet) m.progress = amount;
                        else m.progress += amount;

                        if (m.progress >= m.goal) {
                            m.progress = m.goal;
                            m.completed = true;
                            awardEventReward(m);
                        }
                    }
                });
            }

            saveGame();
            renderMissions();
            renderEventMissions();
        }

        function completeMission(mission) {
            if (GameData.completedMissions.includes(mission.id)) return;
            GameData.completedMissions.push(mission.id);
            if (grantVoltBits(mission.reward, true, `Mision: ${mission.text || mission.id || 'Objetivo'}`)) {
                showNotification(`¡MISIÓN CUMPLIDA! +${mission.reward} VoltBits`);
            }
            updateVoltBitsDisplay();
        }

        function showNotification(text) {
            const notif = document.createElement('div');
            notif.className = 'item-notification';
            notif.style.display = 'flex';
            notif.style.alignItems = 'center';
            notif.style.gap = '10px';

            // Reemplazar emoji en texto si existe para consistencia (opcional)
            const cleanText = text.replace('💰', '');

            notif.innerHTML = `<span>${cleanText}</span> <canvas width="24" height="24" id="notifIcon"></canvas>`;
            document.body.appendChild(notif);

            const ctx = notif.querySelector('canvas').getContext('2d');
            renderRacerModel(ctx, 'currency_voltbit', 12, 12, 0.8, { color: '#00e5ff' });

            setTimeout(() => notif.remove(), 2500);
        }

        // Llamar al inicio
        initMissions();

        function showMainMenu() {
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('characterSelect').style.display = 'none';
            const modeScreen = document.getElementById('modeSelectScreen');
            if (modeScreen) modeScreen.style.display = 'none';
            document.getElementById('mapSelect').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('resultsScreen').style.display = 'none';
            document.getElementById('shopMenu').style.display = 'none';
            document.getElementById('eventsScreen').style.display = 'none';
            document.getElementById('countdownOverlay').classList.add('hidden');
            updateVoltBitsDisplay();
        }

        function renderShopChestIcons() {
            const ids = [
                ['iconChestElectric', 'electric'],
                ['iconChestFortune', 'fortune'],
                ['iconChestIron', 'iron'],
                ['iconChestGold', 'gold'],
                ['iconChestDiamond', 'diamond'],
                ['iconChestCosmic', 'cosmic']
            ];

            ids.forEach(([id, chestType]) => {
                const cvs = document.getElementById(id);
                if (!cvs) return;
                const cctx = cvs.getContext('2d');
                cctx.clearRect(0, 0, cvs.width, cvs.height);
                drawChestModel(cctx, chestType, 60, 60, 1.5);
            });

            for (let i = 1; i <= 6; i++) {
                const p = document.getElementById(`priceIcon${i}`);
                if (!p) continue;
                const pctx = p.getContext('2d');
                pctx.clearRect(0, 0, p.width, p.height);
                renderRacerModel(pctx, 'currency_voltbit', 12, 12, 0.8, { color: '#00e5ff' });
            }
        }

        function showShop() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('shopMenu').style.display = 'flex';
            updateVoltBitsDisplay();
            Object.keys(shopChestQuantities).forEach(updateChestQuantityUI);

            // Dibujar SIEMPRE los 6 cofres; reintentos por timing de layout/pintado
            renderShopChestIcons();
            setTimeout(renderShopChestIcons, 120);
            setTimeout(renderShopChestIcons, 320);
            renderShopEventOffers();
            renderShopChestStash();
        }

        let currentChestData = null;
        let chestOpenQueue = [];
        const SHOP_CHEST_TYPES = ['electric', 'fortune', 'iron', 'gold', 'diamond', 'cosmic'];
        const shopChestQuantities = {
            electric: 1,
            fortune: 1,
            iron: 1,
            gold: 1,
            diamond: 1,
            cosmic: 1
        };

        function ensureChestInventory() {
            if (!GameData.chestInventory || typeof GameData.chestInventory !== 'object') {
                GameData.chestInventory = {};
            }
            SHOP_CHEST_TYPES.forEach(type => {
                const raw = Math.floor(Number(GameData.chestInventory[type]) || 0);
                GameData.chestInventory[type] = Math.max(0, raw);
            });
        }

        function getChestQuantity(type) {
            const stored = Number(shopChestQuantities[type] || 1);
            return Math.max(1, Math.min(25, Math.floor(stored)));
        }

        function updateChestQuantityUI(type) {
            const el = document.getElementById(`qty-${type}`);
            if (el) el.textContent = String(getChestQuantity(type));
        }

        function changeChestQuantity(type, delta) {
            const current = getChestQuantity(type);
            const next = Math.max(1, Math.min(25, current + Number(delta || 0)));
            shopChestQuantities[type] = next;
            updateChestQuantityUI(type);
        }

        function addChestToInventory(type, amount = 1) {
            ensureChestInventory();
            const add = Math.max(1, Math.floor(Number(amount) || 1));
            GameData.chestInventory[type] = Math.max(0, Math.floor(Number(GameData.chestInventory[type] || 0)) + add);
        }

        function getChestInventoryCount(type) {
            ensureChestInventory();
            return Math.max(0, Math.floor(Number(GameData.chestInventory[type] || 0)));
        }

        function consumeChestFromInventory(type, amount = 1) {
            ensureChestInventory();
            const need = Math.max(1, Math.floor(Number(amount) || 1));
            const current = getChestInventoryCount(type);
            if (current < need) return false;
            GameData.chestInventory[type] = current - need;
            return true;
        }

        function renderShopChestStash() {
            const grid = document.getElementById('shopChestStashGrid');
            if (!grid) return;
            ensureChestInventory();
            grid.innerHTML = '';

            SHOP_CHEST_TYPES.forEach(type => {
                const chest = CHEST_TYPES[type];
                if (!chest) return;
                const count = getChestInventoryCount(type);
                const card = document.createElement('div');
                card.className = 'shop-stash-card';
                card.innerHTML = `
                    <canvas id="stashChest-${type}" width="90" height="90" style="margin:0 auto;display:block;"></canvas>
                    <div style="font-family:Orbitron;font-size:0.72rem;text-align:center;color:#fff;">${chest.name}</div>
                    <div class="shop-stash-count">Guardados: <span style="color:var(--accent-gold)">${count}</span></div>
                    <div class="shop-stash-actions">
                        <button class="shop-stash-btn" ${count < 1 ? 'disabled' : ''} onclick="openStoredChest('${type}',1)">ABRIR 1</button>
                        <button class="shop-stash-btn" ${count < 5 ? 'disabled' : ''} onclick="openStoredChest('${type}',5)">ABRIR 5</button>
                        <button class="shop-stash-btn" ${count < 10 ? 'disabled' : ''} onclick="openStoredChest('${type}',10)">ABRIR 10</button>
                    </div>
                `;
                grid.appendChild(card);
                setTimeout(() => {
                    const c = document.getElementById(`stashChest-${type}`);
                    if (!c) return;
                    const cctx = c.getContext('2d');
                    cctx.clearRect(0, 0, c.width, c.height);
                    drawChestModel(cctx, type, 45, 45, 1.15);
                }, 0);
            });
        }

        window.openStoredChest = function openStoredChest(type, amount = 1) {
            const available = getChestInventoryCount(type);
            const qty = Math.max(1, Math.min(available, Math.floor(Number(amount) || 1)));
            if (qty <= 0) return;

            for (let i = 0; i < qty; i++) {
                awardChest(type, false, null, 'storage');
            }
            saveGame();
            showNotification(`Preparados ${qty}x ${type.toUpperCase()} del almacen`);
        };

        function updateChestContinueLabel() {
            const btn = document.getElementById('chestCloseBtn');
            if (!btn) return;
            const pending = chestOpenQueue.length;
            btn.textContent = pending > 0 ? `CONTINUAR (${pending} restantes)` : 'CONTINUAR';
        }

        function showNextChestFromQueue() {
            if (currentChestData || chestOpenQueue.length === 0) return;
            const nextChest = chestOpenQueue.shift();
            if (!nextChest) return;
            currentChestData = { ...nextChest, opened: false };

            const type = currentChestData.type;
            const missionReward = currentChestData.missionReward;
            const isFromShop = !!currentChestData.isFromShop;
            const source = String(currentChestData.source || 'auto');

            // Definir tipos de cofre de evento al vuelo si no existen
            if (type === 'event_glitch' && !CHEST_TYPES.event_glitch) {
                CHEST_TYPES.event_glitch = { name: 'COFRE GLITCH', cardAmount: [5, 10] };
            }
            if (type === 'event_valentine' && !CHEST_TYPES.event_valentine) {
                CHEST_TYPES.event_valentine = { name: 'COFRE VALENTIN', cardAmount: [5, 10] };
            }

            const modal = document.getElementById('chestModal');
            modal.style.display = 'flex';

            const title = document.getElementById('chestTitle');
            if (missionReward) {
                title.textContent = "¡MISIÓN COMPLETADA!";
                document.getElementById('chestInstruction').innerHTML = `<span style="color:var(--accent-gold)">${missionReward.txt || missionReward.text}</span><br>Haz clic para abrir`;
            } else {
                title.textContent = source === 'storage'
                    ? "¡COFRE DE INVENTARIO!"
                    : isFromShop
                        ? "¡COFRE COMPRADO!"
                    : (type === 'battle_1' ? "¡COFRE DE VICTORIA!" : "¡COFRE DE BATALLA!");
                document.getElementById('chestInstruction').textContent = "Haz clic para abrir";
            }

            const container = document.getElementById('chestContainer');
            container.className = 'chest-container shake';
            container.style.display = 'block';
            container.style.opacity = '1';
            container.style.transform = '';

            const cvs = document.getElementById('chestCanvas');
            const ctx = cvs.getContext('2d');
            ctx.clearRect(0, 0, cvs.width, cvs.height);

            if (type === 'event_glitch') drawChestModel(ctx, 'glitch', 150, 150, 4);
            else if (type === 'event_valentine') drawChestModel(ctx, 'heart', 150, 150, 4);
            else drawChestModel(ctx, type, 150, 150, 4);

            const rewardEl = document.getElementById('chestReward');
            rewardEl.classList.remove('show');
            rewardEl.innerHTML = '';
            rewardEl.scrollTop = 0;
            document.getElementById('chestCloseBtn').style.display = 'none';
            document.getElementById('chestInstruction').style.display = 'block';
            updateChestContinueLabel();
        }

        function buyChest(type, forcedQuantity = null) {
            const chest = CHEST_TYPES[type];
            if (!chest) return;

            const quantity = forcedQuantity == null
                ? getChestQuantity(type)
                : Math.max(1, Math.min(25, Math.floor(Number(forcedQuantity) || 1)));

            const totalPrice = chest.price * quantity;
            if (GameData.voltBits < totalPrice) {
                alert(`¡No tienes suficientes VoltBits! Necesitas ${totalPrice}.`);
                return;
            }

            startOceanPayTransaction(totalPrice, `${quantity}x Cofre ${type.toUpperCase()}`, () => {
                GameData.voltBits -= totalPrice;
                updateVoltBitsDisplay();
                addChestToInventory(type, quantity);
                saveGame();
                renderShopChestStash();
                showNotification(`¡Compra exitosa! +${quantity} ${type.toUpperCase()} guardados (-${totalPrice} VoltBits)`);
            });
        }

        // --- EVENT SYSTEM (REDESIGNED) ---
        let _evtCountdownInterval = null;

        function showEvents() {
            const now = new Date();
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('eventsScreen').style.display = 'block';
            let currentEvt = null;
            EVENTS_CALENDAR.forEach(e => { if (now >= e.startDate && now <= e.endDate) currentEvt = e; });
            const nextEvt = EVENTS_CALENDAR
                .filter(e => e.startDate > now)
                .sort((a, b) => a.startDate - b.startDate)[0] || null;
            const fallbackEvt = currentEvt || nextEvt;
            const hero = document.getElementById('evtHero');
            const badge = document.getElementById('evtBadge');
            const title = document.getElementById('evtTitle');
            const desc = document.getElementById('evtDesc');
            if (fallbackEvt) {
                hero.style.background = fallbackEvt.bgGradient;
                badge.textContent = currentEvt ? 'EVENTO ACTIVO' : 'PRÓXIMO EVENTO';
                badge.style.background = fallbackEvt.color;
                badge.style.color = '#000';
                title.textContent = fallbackEvt.name;
                title.style.color = fallbackEvt.color;
                desc.textContent = currentEvt ? fallbackEvt.description : `Comienza ${fallbackEvt.startDate.toLocaleDateString()} y dura hasta ${fallbackEvt.endDate.toLocaleDateString()}.`;
                const racer = CHARACTERS[fallbackEvt.featuredRacer];
                if (racer) {
                    const cvs = document.getElementById('evtRacerCvs'); const rctx = cvs.getContext('2d');
                    rctx.clearRect(0, 0, 150, 150);
                    renderRacerModel(rctx, fallbackEvt.featuredRacer, 75, 75, 4, racer);
                    document.getElementById('evtRacerName').textContent = racer.name;
                    document.getElementById('evtRacerName').style.color = racer.color;
                    const rarEl = document.getElementById('evtRacerRarity');
                    rarEl.textContent = racer.rarity.toUpperCase();
                    rarEl.style.background = racer.rarity === 'mythic' ? 'linear-gradient(135deg,#ff3e8d,#00f7ff,#a855f7)' : `var(--${racer.rarity})`;
                    rarEl.style.color = ['common', 'uncommon', 'legendary'].includes(racer.rarity) ? '#000' : '#fff';
                }
                document.getElementById('evtRacerBox').style.display = 'block';
                document.getElementById('evtCountdown').style.display = 'flex';
                if (_evtCountdownInterval) clearInterval(_evtCountdownInterval);
                _updateEvtCountdown((currentEvt || fallbackEvt).endDate);
                _evtCountdownInterval = setInterval(() => _updateEvtCountdown((currentEvt || fallbackEvt).endDate), 1000);
                if (currentEvt) {
                    _renderEventOffers(currentEvt, now);
                    checkEventReset();
                    renderEventMissions();
                    if (typeof renderEventTargetSelector === 'function') renderEventTargetSelector(currentEvt);
                } else {
                    document.getElementById('evtOffersPanel').style.display = 'none';
                    const list = document.getElementById('eventMissionList');
                    if (list) {
                        list.innerHTML = '<div style="opacity:0.8;padding:10px;">El evento iniciará pronto. Mientras tanto, puedes revisar el calendario y ofertas anteriores.</div>';
                    }
                    if (typeof renderEventTargetSelector === 'function') renderEventTargetSelector(fallbackEvt);
                }
            } else {
                hero.style.background = 'linear-gradient(135deg, #1a1a3a, #0a0a1a)';
                badge.textContent = 'SIN EVENTO'; badge.style.background = 'rgba(255,255,255,0.2)'; badge.style.color = '#fff';
                title.textContent = 'Proximamente...'; title.style.color = '#888';
                desc.textContent = 'No hay eventos activos. Revisa el calendario para los proximos!';
                document.getElementById('evtRacerBox').style.display = 'none';
                document.getElementById('evtCountdown').style.display = 'none';
                document.getElementById('evtOffersPanel').style.display = 'none';
            }
            _renderEvtTimeline(now, currentEvt);
        }

        function _updateEvtCountdown(endDate) {
            const diff = endDate.getTime() - Date.now();
            if (diff <= 0) { document.getElementById('evtCdDigits').innerHTML = '<span style="font-family:Orbitron;color:#ff4444;">EVENTO FINALIZADO</span>'; return; }
            const d = Math.floor(diff / 86400000), h = Math.floor((diff % 86400000) / 3600000);
            const m = Math.floor((diff % 3600000) / 60000), s = Math.floor((diff % 60000) / 1000);
            document.getElementById('evtCdDigits').innerHTML =
                [{ n: d, l: 'DIAS' }, { n: h, l: 'HRS' }, { n: m, l: 'MIN' }, { n: s, l: 'SEG' }]
                    .map(u => '<div class="cd-unit"><span class="cd-num" style="color:var(--accent-cyan);">' + String(u.n).padStart(2, '0') + '</span><span class="cd-lbl">' + u.l + '</span></div>').join('');
        }

        function _renderEvtTimeline(now, currentEvt) {
            const list = document.getElementById('evtTimeline'); list.innerHTML = '';
            const months = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
            EVENTS_CALENDAR.forEach(evt => {
                const isPast = now > evt.endDate, isActive = currentEvt && evt.id === currentEvt.id;
                const item = document.createElement('div');
                item.className = 'tl-item ' + (isActive ? 'tl-active' : '') + ' ' + (isPast ? 'tl-past' : '');
                const sText = isActive ? 'ACTIVO' : (isPast ? 'FINALIZADO' : 'PROXIMO');
                const sBg = isActive ? evt.color : (isPast ? '#666' : '#888');
                item.innerHTML = '<div class="tl-dot" style="background:' + evt.color + ';box-shadow:0 0 8px ' + evt.color + ';"></div>' +
                    '<div style="flex:1;"><div style="font-family:Orbitron;font-size:0.75rem;color:white;margin-bottom:3px;">' + evt.shortName + '</div>' +
                    '<div style="font-size:0.7rem;color:rgba(255,255,255,0.5);">' + evt.startDate.getDate() + ' ' + months[evt.startDate.getMonth()] + ' - ' + evt.endDate.getDate() + ' ' + months[evt.endDate.getMonth()] + '</div>' +
                    '<span style="font-size:0.6rem;padding:2px 8px;border-radius:10px;background:' + sBg + ';color:#000;font-weight:700;display:inline-block;margin-top:4px;">' + sText + '</span></div>';
                list.appendChild(item);
            });
        }

        function _renderEventOffers(evt, now) {
            const panel = document.getElementById('evtOffersPanel');
            const list = document.getElementById('evtOffersList');
            const offers = EVENT_OFFERS[evt.id];
            if (!offers) { panel.style.display = 'none'; return; }
            panel.style.display = 'block'; list.innerHTML = '';
            const daysLeft = Math.ceil((evt.endDate.getTime() - now.getTime()) / 86400000);
            offers.forEach(offer => {
                if (offer.type === 'lastchance' && daysLeft > (offer.lastChanceDays || 3)) return;
                const bought = GameData.purchasedOffers && GameData.purchasedOffers.includes(offer.id);
                const poolChars = Array.isArray(offer.pool) ? offer.pool.filter(id => CHARACTERS[id]) : [];
                const card = document.createElement('div');
                card.className = 'evt-offer';
                card.innerHTML = '<div class="offer-ribbon" style="background:' + offer.badgeColor + ';color:#000;">' + offer.badgeText + '</div>' +
                    '<canvas width="100" height="100" style="margin:10px auto;display:block;"></canvas>' +
                    '<div style="font-family:Orbitron;font-size:1.05rem;margin:10px 0 6px;position:relative;z-index:1;">' + offer.name + '</div>' +
                    '<div style="font-size:0.85rem;color:rgba(255,255,255,0.6);margin-bottom:15px;position:relative;z-index:1;">' + offer.desc + '</div>' +
                    (poolChars.length ? '<div style="font-size:0.7rem;opacity:0.8;letter-spacing:1px;margin-bottom:6px;">PUEDE INCLUIR</div><div class="offer-pool" style="display:flex;justify-content:center;gap:6px;flex-wrap:wrap;margin:0 0 10px;">' + poolChars.map(id => '<canvas data-offer-char="' + id + '" width="42" height="42" style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;"></canvas>').join('') + '</div>' : '') +
                    (bought ? '<div style="font-family:Orbitron;color:#00ff88;font-size:1rem;">COMPRADO</div>' :
                        '<div style="font-family:Orbitron;font-size:1.3rem;font-weight:900;color:var(--accent-gold);position:relative;z-index:1;">' +
                        (offer.originalPrice ? '<span style="text-decoration:line-through;opacity:0.5;font-size:0.9rem;">' + offer.originalPrice + '</span> ' : '') + offer.price + ' VB</div>');
                if (!bought) card.onclick = () => purchaseEventOffer(offer);
                list.appendChild(card);
                setTimeout(() => {
                    const cvs = card.querySelector('canvas');
                    if (cvs && offer.chestType) drawOfferChestModel(cvs.getContext('2d'), offer, 50, 50, 1.2);
                    else if (cvs) { const r = CHARACTERS[offer.gives.character]; if (r) renderRacerModel(cvs.getContext('2d'), offer.gives.character, 50, 50, 2.5, r); }
                    card.querySelectorAll('canvas[data-offer-char]').forEach(pc => {
                        const cid = pc.dataset.offerChar;
                        const char = CHARACTERS[cid];
                        if (!char) return;
                        renderRacerModel(pc.getContext('2d'), cid, 21, 21, 0.52, char);
                    });
                }, 50);
            });
        }

        function purchaseEventOffer(offer) {
            if (GameData.voltBits < offer.price) { alert('No tienes suficientes VoltBits!'); return; }
            if (!GameData.purchasedOffers) GameData.purchasedOffers = [];
            if (GameData.purchasedOffers.includes(offer.id)) { alert('Ya compraste esta oferta.'); return; }

            startOceanPayTransaction(offer.price, `Oferta: ${offer.name}`, () => {
                let selectedCharId = offer.gives.character;
                if (Array.isArray(offer.pool) && offer.pool.length > 0) {
                    const validPool = offer.pool.filter(id => CHARACTERS[id]);
                    if (validPool.length > 0) {
                        const preferred = validPool.includes(GameData.eventTargetRacer) ? GameData.eventTargetRacer : null;
                        selectedCharId = preferred || validPool[Math.floor(Math.random() * validPool.length)];
                    }
                }

                GameData.voltBits -= offer.price;
                GameData.purchasedOffers.push(offer.id);
                if (selectedCharId && !GameData.unlockedCharacters.includes(selectedCharId)) GameData.unlockedCharacters.push(selectedCharId);
                if (offer.gives.cards && selectedCharId) GameData.characterCards[selectedCharId] = (GameData.characterCards[selectedCharId] || 0) + offer.gives.cards;
                if (offer.gives.bits) grantVoltBits(offer.gives.bits, false, `Oferta: ${offer.name}`);
                updateVoltBitsDisplay(); saveGame();
                if (offer.chestType) {
                    awardChest(offer.chestType, false, { txt: offer.name, rewardCards: offer.gives.cards, rarity: 'legendary' });
                } else {
                    showNotification((CHARACTERS[selectedCharId]?.name || 'CORREDOR') + ' DESBLOQUEADO! +' + (offer.gives.cards || 0) + ' tarjetas');
                }
                const curEvt = EVENTS_CALENDAR.find(e => { const n = new Date(); return n >= e.startDate && n <= e.endDate; });
                if (curEvt) _renderEventOffers(curEvt, new Date());
                renderShopEventOffers();
            });
        }

        function drawOfferChestModel(ctx, offer, x, y, scale) {
            ctx.save(); ctx.translate(x, y); ctx.scale(scale, scale);
            ctx.fillStyle = '#1a0a2e'; ctx.fillRect(-22, -12, 44, 34);
            const grd = ctx.createLinearGradient(-22, -12, 22, 22);
            grd.addColorStop(0, offer.badgeColor === '#ffd700' ? '#ffd700' : '#ff4081');
            grd.addColorStop(1, '#a855f7');
            ctx.strokeStyle = grd; ctx.lineWidth = 2.5; ctx.strokeRect(-22, -12, 44, 34);
            ctx.fillStyle = '#0d0520';
            ctx.beginPath(); ctx.moveTo(-24, -12); ctx.lineTo(24, -12); ctx.lineTo(20, -28); ctx.lineTo(-20, -28); ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.fillStyle = offer.badgeColor; ctx.beginPath(); ctx.arc(0, -6, 5, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(-1, -8, 2, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1;
            ctx.fillStyle = offer.badgeColor; ctx.globalAlpha = 0.7;
            [[-15, -22], [15, -22], [0, -32]].forEach(function (p) { ctx.beginPath(); ctx.arc(p[0], p[1], 2, 0, Math.PI * 2); ctx.fill(); });
            ctx.globalAlpha = 1; ctx.restore();
        }

        function renderShopEventOffers() {
            const container = document.getElementById('shopEventOffers');
            if (!container) return;
            const now = new Date();
            const curEvt = EVENTS_CALENDAR.find(e => now >= e.startDate && now <= e.endDate);
            if (!curEvt || !EVENT_OFFERS[curEvt.id]) { container.style.display = 'none'; return; }
            container.style.display = 'block';
            container.innerHTML = '<h3 style="font-family:Orbitron;font-size:1rem;color:var(--accent-pink);letter-spacing:3px;text-align:center;margin-bottom:15px;">OFERTAS DE EVENTO: ' + curEvt.shortName + '</h3>';
            const grid = document.createElement('div');
            grid.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:15px;';
            const daysLeft = Math.ceil((curEvt.endDate.getTime() - now.getTime()) / 86400000);
            EVENT_OFFERS[curEvt.id].forEach(function (offer) {
                if (offer.type === 'lastchance' && daysLeft > (offer.lastChanceDays || 3)) return;
                const bought = GameData.purchasedOffers && GameData.purchasedOffers.includes(offer.id);
                const poolChars = Array.isArray(offer.pool) ? offer.pool.filter(id => CHARACTERS[id]) : [];
                const card = document.createElement('div');
                card.className = 'shop-offer-card';
                card.innerHTML = '<div style="position:absolute;top:12px;right:-25px;background:' + offer.badgeColor + ';color:#000;padding:3px 35px;font-size:0.6rem;font-family:Orbitron;font-weight:900;transform:rotate(45deg);">' + offer.badgeText + '</div>' +
                    '<canvas width="120" height="120" style="margin:0 auto;display:block;"></canvas>' +
                    '<h3>' + offer.name + '</h3><p>' + offer.desc + '</p>' +
                    (poolChars.length ? '<div style="font-size:0.68rem;opacity:0.8;letter-spacing:1px;margin:2px 0 8px;">PUEDE INCLUIR</div><div class="offer-pool" style="display:flex;justify-content:center;gap:6px;flex-wrap:wrap;margin:0 0 10px;">' + poolChars.map(id => '<canvas data-offer-char="' + id + '" width="40" height="40" style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:8px;"></canvas>').join('') + '</div>' : '') +
                    (bought ? '<div style="font-family:Orbitron;color:#00ff88;font-size:1.2rem;">COMPRADO</div>' :
                        '<div class="shop-price" style="color:var(--accent-gold);">' + (offer.originalPrice ? '<span style="text-decoration:line-through;opacity:0.5;">' + offer.originalPrice + '</span> ' : '') + offer.price + ' VB</div>');
                if (!bought) card.onclick = function () { purchaseEventOffer(offer); };
                grid.appendChild(card);
                setTimeout(function () {
                    const cvs = card.querySelector('canvas');
                    if (cvs && offer.chestType) drawOfferChestModel(cvs.getContext('2d'), offer, 60, 60, 1.5);
                    else if (cvs) { const r = CHARACTERS[offer.gives.character]; if (r) renderRacerModel(cvs.getContext('2d'), offer.gives.character, 60, 60, 3, r); }
                    card.querySelectorAll('canvas[data-offer-char]').forEach(pc => {
                        const cid = pc.dataset.offerChar;
                        const char = CHARACTERS[cid];
                        if (!char) return;
                        renderRacerModel(pc.getContext('2d'), cid, 20, 20, 0.5, char);
                    });
                }, 100);
            });
            container.appendChild(grid);
        }

        function checkEventReset() {
            const now = Date.now();
            const oneHour = 3600 * 1000;
            if (now - GameData.lastMissionResetTime > oneHour) {
                resetEventMissions(false);
            }

            // Update Timer UI
            const timeLeft = oneHour - (now - GameData.lastMissionResetTime);
            const mins = Math.max(0, Math.floor(timeLeft / 60000));
            const secs = Math.max(0, Math.floor((timeLeft % 60000) / 1000));
            document.getElementById('eventTimer').textContent = `Reset en: ${mins}:${secs.toString().padStart(2, '0')}`;

            if (document.getElementById('eventsScreen').style.display === 'block') {
                requestAnimationFrame(checkEventReset); // Keep updating
            }
        }

        function resetEventMissionsManual() {
            if (GameData.voltBits >= GameData.missionResetCost) {
                startOceanPayTransaction(GameData.missionResetCost, "Reset de Misiones", () => {
                    GameData.voltBits -= GameData.missionResetCost;
                    GameData.missionResetCost = Math.floor(GameData.missionResetCost * 1.5); // Accrue cost
                    updateVoltBitsDisplay();
                    resetEventMissions(true);
                });
            } else {
                alert("No tienes suficientes VoltBits");
            }
        }

        function resetEventMissions(isPaid) {
            if (!isPaid) {
                GameData.missionResetCost = 100; // Reset price on natural reset
            }
            GameData.lastMissionResetTime = Date.now();

            // Generate New Missions
            // Pool de Misiones
            let pool = [];

            if (activeEvent === 'glitch') {
                pool = [
                    { txt: "Gana en ERROR DE SISTEMA sin usar Turbos", goal: 1, id: 'win_no_turbo_glitch', rewardCards: 30, rarity: 'mythic' },
                    { txt: "Golpea a 15 rivales en una carrera", goal: 15, id: 'hit_15_one_race', rewardCards: 25, rarity: 'legendary' },
                    { txt: "Sobrevive al Modo KNOCKOUT hasta el final", goal: 1, id: 'win_knockout', rewardCards: 20, rarity: 'epic' },
                    { txt: "Recoge 30 Cajas Glitch", goal: 30, id: 'collect_items', rewardCards: 15, rarity: 'rare' },
                    { txt: "Gana 3 carreras seguidas", goal: 3, id: 'win_streak_3', rewardCards: 40, rarity: 'mythic' }
                ];
            } else if (activeEvent === 'valentine') {
                pool = [
                    { txt: "Termina una carrera en JARDÍN DEL AMOR", goal: 1, id: 'race_jungle', rewardCards: 5, rarity: 'epic' },
                    { txt: "Gana 1er Lugar en cualquier mapa", goal: 1, id: 'win_race', rewardCards: 3, rarity: 'rare' },
                    { txt: "Golpea a 10 rivales (¡Con Amor!)", goal: 10, id: 'hit_opponents', rewardCards: 4, rarity: 'rare' },
                    { txt: "Recoge 15 Cajas de Regalo", goal: 15, id: 'collect_items', rewardCards: 3, rarity: 'uncommon' },
                    { txt: "Usa 5 Turbos", goal: 5, id: 'use_turbo', rewardCards: 2, rarity: 'common' }
                ];
            }

            const currentEvt = (window.__VS_GET_CURRENT_EVENT && window.__VS_GET_CURRENT_EVENT()) || null;
            const rewardRacer = GameData.eventTargetRacer || (currentEvt ? currentEvt.featuredRacer : null) || 'blaze';
            if (pool.length === 0) {
                pool = [
                    { txt: "Gana 1 carrera", goal: 1, id: 'win_race', rewardCards: 8, rarity: 'rare' },
                    { txt: "Termina 2 veces en Top 2", goal: 2, id: 'top_2_ko', rewardCards: 10, rarity: 'rare' },
                    { txt: "Golpea a 12 rivales", goal: 12, id: 'hit_opponents', rewardCards: 9, rarity: 'epic' },
                    { txt: "Recoge 20 cajas", goal: 20, id: 'collect_items', rewardCards: 7, rarity: 'rare' },
                    { txt: "Usa 6 turbos", goal: 6, id: 'use_turbo', rewardCards: 8, rarity: 'rare' },
                    { txt: "Juega una carrera en el mapa del evento", goal: 1, id: 'race_event_map', rewardCards: 11, rarity: 'epic' }
                ];
            }

            // Seleccionar 3 aleatorias
            const missions = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
            GameData.eventMissions = missions.map(m => ({ ...m, progress: 0, completed: false, rewardRacer }));
            saveGame();
            renderEventMissions();
            document.getElementById('resetCostDisplay').textContent = GameData.missionResetCost;
        }

        function renderEventMissions() {
            const list = document.getElementById('eventMissionList');
            if (!list) return;
            list.innerHTML = '';

            if (!GameData.eventMissions) resetEventMissions(false);

            GameData.eventMissions.forEach((m, idx) => {
                const div = document.createElement('div');
                div.style.background = 'rgba(0,0,0,0.3)';
                div.style.padding = '10px';
                div.style.borderRadius = '5px';
                div.style.display = 'flex';
                div.style.justifyContent = 'space-between';

                div.innerHTML = `
                       <span>${m.txt}<br><small style="opacity:0.72;">Cofre objetivo: ${CHARACTERS[m.rewardRacer]?.name || 'Corredor'}</small></span>
                       <span style="color:${m.completed ? '#0f0' : '#fff'}">${m.progress}/${m.goal} ${m.completed ? '✔' : ''}</span>
                  `;
                // Click eliminado - Las misiones ahora son reales
                // div.onclick = ...
                list.appendChild(div);
            });
            document.getElementById('resetCostDisplay').textContent = GameData.missionResetCost || 100;
        }

        function awardEventReward(mission) {
            // Siempre encolar si estamos en el flujo de carrera o resultados
            const isInRaceFlow = gameState.running || document.getElementById('resultsScreen').style.display === 'flex';

            if (isInRaceFlow) {
                // Evitar duplicados si por algún motivo se llama dos veces
                if (!gameState.pendingRewards.find(m => m.id === mission.id && m.text === mission.text)) {
                    gameState.pendingRewards.push(mission);
                    if (gameState.running) showNotification("🎁 ¡Misión de Evento Completada!");
                }
                return;
            }

            // Si se llama fuera de carrera (raro en este juego pero por seguridad)
            openEventRewardModal(mission);
        }

        function openEventRewardModal(mission) {
            currentEventMissionReward = mission; // Mantener para compatibilidad si es necesario, pero awardChest lo usará
            const rewardRacer = mission.rewardRacer || GameData.eventTargetRacer;
            if (rewardRacer && CHARACTERS[rewardRacer]) {
                awardChest(`event_chest_${rewardRacer}`, false, mission);
                return;
            }
            if (activeEvent === 'glitch') awardChest('event_glitch', false, mission);
            else awardChest('event_valentine', false, mission);
        }

        function awardChest(type, isFromShop = false, missionReward = null, source = 'auto') {
            chestOpenQueue.push({ type, isFromShop, missionReward, source, opened: false });
            showNextChestFromQueue();
        }

        function openChestAnimation() {
            if (!currentChestData || currentChestData.opened) return;

            if (currentChestData.source === 'storage') {
                if (!consumeChestFromInventory(currentChestData.type, 1)) {
                    showNotification('No quedan cofres de ese tipo en almacen.');
                    currentChestData = null;
                    renderShopChestStash();
                    if (chestOpenQueue.length > 0) {
                        setTimeout(showNextChestFromQueue, 100);
                    } else {
                        document.getElementById('chestModal').style.display = 'none';
                    }
                    return;
                }
                saveGame();
                renderShopChestStash();
            }

            currentChestData.opened = true;

            const container = document.getElementById('chestContainer');
            container.className = 'chest-container open';
            document.getElementById('chestInstruction').style.display = 'none';

            setTimeout(() => {
                processChestReward();
                // Liberar espacio visual del cofre para que la recompensa no quede comprimida.
                container.style.display = 'none';
            }, 800);
        }

        let __vsAudioCtx = null;
        let __vsCardTickLastMs = 0;

        function getVsAudioContext() {
            try {
                const Ctx = window.AudioContext || window.webkitAudioContext;
                if (!Ctx) return null;
                if (!__vsAudioCtx) __vsAudioCtx = new Ctx();
                if (__vsAudioCtx.state === 'suspended') {
                    __vsAudioCtx.resume().catch(() => { });
                }
                return __vsAudioCtx;
            } catch (_) {
                return null;
            }
        }

        function playCardTickSfx(stepIndex = 1, totalSteps = 1) {
            const nowMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
            if (nowMs - __vsCardTickLastMs < 20) return;
            __vsCardTickLastMs = nowMs;

            const ctx = getVsAudioContext();
            if (!ctx) return;

            try {
                const t = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const ratio = Math.max(0, Math.min(1, Number(stepIndex || 1) / Math.max(1, Number(totalSteps || 1))));
                const baseFreq = 680 + (ratio * 260);

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(baseFreq, t);
                osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.12, t + 0.035);

                gain.gain.setValueAtTime(0.0001, t);
                gain.gain.exponentialRampToValueAtTime(0.035, t + 0.006);
                gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.055);

                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(t);
                osc.stop(t + 0.06);
            } catch (_) { }
        }

        function playCardRowCompleteSfx(rarity = 'common') {
            const ctx = getVsAudioContext();
            if (!ctx) return;
            try {
                const t = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const rarityBoost = {
                    common: 0,
                    uncommon: 18,
                    rare: 36,
                    epic: 56,
                    legendary: 82,
                    mythic: 110
                };
                const base = 760 + (rarityBoost[rarity] || 0);

                osc.type = 'sine';
                osc.frequency.setValueAtTime(base, t);
                osc.frequency.exponentialRampToValueAtTime(base * 1.22, t + 0.09);

                gain.gain.setValueAtTime(0.0001, t);
                gain.gain.exponentialRampToValueAtTime(0.045, t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);

                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(t);
                osc.stop(t + 0.13);
            } catch (_) { }
        }

        function playChestCardsCompleteSfx() {
            const ctx = getVsAudioContext();
            if (!ctx) return;
            try {
                const t = ctx.currentTime;
                const notes = [620, 780, 980];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const start = t + (i * 0.045);
                    const end = start + 0.11;

                    osc.type = i === 2 ? 'triangle' : 'sine';
                    osc.frequency.setValueAtTime(freq, start);
                    osc.frequency.exponentialRampToValueAtTime(freq * 1.06, end);

                    gain.gain.setValueAtTime(0.0001, start);
                    gain.gain.exponentialRampToValueAtTime(0.04, start + 0.012);
                    gain.gain.exponentialRampToValueAtTime(0.0001, end);

                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(end + 0.005);
                });
            } catch (_) { }
        }

        function playChestUnlockRunnerSfx() {
            const ctx = getVsAudioContext();
            if (!ctx) return;
            try {
                const t = ctx.currentTime;
                const notes = [520, 680, 860, 1120];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const start = t + (i * 0.055);
                    const end = start + 0.14;

                    osc.type = i < 2 ? 'triangle' : 'sine';
                    osc.frequency.setValueAtTime(freq, start);
                    osc.frequency.exponentialRampToValueAtTime(freq * 1.18, end);

                    gain.gain.setValueAtTime(0.0001, start);
                    gain.gain.exponentialRampToValueAtTime(0.06, start + 0.014);
                    gain.gain.exponentialRampToValueAtTime(0.0001, end);

                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(end + 0.01);
                });
            } catch (_) { }
        }

        function playRunnerUpgradeSfx(rarity = 'common', nextLevel = 1) {
            const ctx = getVsAudioContext();
            if (!ctx) return;
            try {
                const t = ctx.currentTime;
                const boostByRarity = {
                    common: 0,
                    uncommon: 20,
                    rare: 42,
                    epic: 66,
                    legendary: 94,
                    mythic: 130
                };
                const rarityBoost = boostByRarity[rarity] || 0;
                const lvlBoost = Math.max(0, Math.min(180, (Number(nextLevel) || 1) * 10));
                const base = 520 + rarityBoost + lvlBoost;
                const notes = [base, base * 1.2, base * 1.47, base * 1.78];

                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const start = t + (i * 0.05);
                    const end = start + 0.16;

                    osc.type = i < 2 ? 'triangle' : 'sine';
                    osc.frequency.setValueAtTime(freq, start);
                    osc.frequency.exponentialRampToValueAtTime(freq * 1.06, end);

                    gain.gain.setValueAtTime(0.0001, start);
                    gain.gain.exponentialRampToValueAtTime(0.055, start + 0.014);
                    gain.gain.exponentialRampToValueAtTime(0.0001, end);

                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(end + 0.01);
                });

                const burst = ctx.createOscillator();
                const burstGain = ctx.createGain();
                const burstStart = t + 0.09;
                const burstEnd = burstStart + 0.2;
                burst.type = 'sawtooth';
                burst.frequency.setValueAtTime(base * 0.74, burstStart);
                burst.frequency.exponentialRampToValueAtTime(base * 1.9, burstEnd);
                burstGain.gain.setValueAtTime(0.0001, burstStart);
                burstGain.gain.exponentialRampToValueAtTime(0.02, burstStart + 0.025);
                burstGain.gain.exponentialRampToValueAtTime(0.0001, burstEnd);
                burst.connect(burstGain);
                burstGain.connect(ctx.destination);
                burst.start(burstStart);
                burst.stop(burstEnd + 0.01);

                const impact = ctx.createOscillator();
                const impactGain = ctx.createGain();
                const impactStart = t + 0.018;
                const impactEnd = impactStart + 0.23;
                impact.type = 'square';
                impact.frequency.setValueAtTime(Math.max(90, base * 0.34), impactStart);
                impact.frequency.exponentialRampToValueAtTime(Math.max(40, base * 0.13), impactEnd);
                impactGain.gain.setValueAtTime(0.0001, impactStart);
                impactGain.gain.exponentialRampToValueAtTime(0.028, impactStart + 0.02);
                impactGain.gain.exponentialRampToValueAtTime(0.0001, impactEnd);
                impact.connect(impactGain);
                impactGain.connect(ctx.destination);
                impact.start(impactStart);
                impact.stop(impactEnd + 0.01);

                const sparkle = [base * 2.1, base * 2.45, base * 2.85];
                sparkle.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const start = t + 0.18 + (i * 0.04);
                    const end = start + 0.11;
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(freq, start);
                    osc.frequency.exponentialRampToValueAtTime(freq * 1.1, end);
                    gain.gain.setValueAtTime(0.0001, start);
                    gain.gain.exponentialRampToValueAtTime(0.02, start + 0.012);
                    gain.gain.exponentialRampToValueAtTime(0.0001, end);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(end + 0.01);
                });
            } catch (_) { }
        }

        function showRunnerUpgradeFx(charId, nextLevel) {
            const char = CHARACTERS[charId];
            const host = document.querySelector('#upgradeModal .modal-content');
            if (!host || !char) return;

            host.querySelectorAll('.upgrade-levelup-fx').forEach(el => el.remove());
            host.classList.remove('upgrade-celebrate');
            void host.offsetWidth;
            host.classList.add('upgrade-celebrate');
            setTimeout(() => host.classList.remove('upgrade-celebrate'), 520);

            const preview = document.getElementById('upgradeCharacterPreview');
            if (preview) {
                preview.classList.remove('upgrade-flare');
                void preview.offsetWidth;
                preview.classList.add('upgrade-flare');
                setTimeout(() => preview.classList.remove('upgrade-flare'), 960);
            }

            document.querySelectorAll('.upgrade-stats .stat-bar-fill').forEach((bar, idx) => {
                const delay = idx * 70;
                setTimeout(() => {
                    bar.classList.remove('upgrade-pop');
                    void bar.offsetWidth;
                    bar.classList.add('upgrade-pop');
                }, delay);
                setTimeout(() => bar.classList.remove('upgrade-pop'), delay + 720);
            });

            const fx = document.createElement('div');
            fx.className = 'upgrade-levelup-fx';
            fx.innerHTML = `
                <div class="upgrade-levelup-flash"></div>
                <div class="upgrade-levelup-ring"></div>
                <div class="upgrade-levelup-explosion"></div>
                <div class="upgrade-levelup-streaks"></div>
                <div class="upgrade-levelup-sparks"></div>
                <div class="upgrade-levelup-card">
                    <canvas width="70" height="70"></canvas>
                    <div class="upgrade-levelup-text">
                        <div class="kicker">POWER UPGRADE</div>
                        <div class="name" style="color:${char.color};">${char.name}</div>
                        <div class="lvl">Nivel ${Math.max(1, Number(nextLevel) || 1)}</div>
                    </div>
                </div>
            `;
            host.appendChild(fx);

            const streaks = fx.querySelector('.upgrade-levelup-streaks');
            if (streaks) {
                const streakCount = 16;
                for (let i = 0; i < streakCount; i++) {
                    const s = document.createElement('span');
                    s.className = 'upgrade-levelup-streak';
                    const rot = (360 / streakCount) * i + ((Math.random() * 16) - 8);
                    s.style.setProperty('--rot', `${rot}deg`);
                    s.style.setProperty('--delay', `${(Math.random() * 0.12).toFixed(3)}s`);
                    s.style.setProperty('--dur', `${(0.56 + Math.random() * 0.38).toFixed(3)}s`);
                    s.style.setProperty('--len', `${90 + Math.floor(Math.random() * 80)}px`);
                    streaks.appendChild(s);
                }
            }

            const sparks = fx.querySelector('.upgrade-levelup-sparks');
            if (sparks) {
                const palette = [char.color || '#00f7ff', char.secondaryColor || '#8ef3ff', '#ffffff', '#ffb347', '#00f7ff'];
                const sparkCount = 22;
                for (let i = 0; i < sparkCount; i++) {
                    const p = document.createElement('span');
                    p.className = 'upgrade-levelup-spark';
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 72 + Math.random() * 160;
                    p.style.setProperty('--tx', `${Math.cos(angle) * dist}px`);
                    p.style.setProperty('--ty', `${Math.sin(angle) * dist}px`);
                    p.style.setProperty('--size', `${3 + Math.random() * 5}px`);
                    p.style.setProperty('--delay', `${(Math.random() * 0.16).toFixed(3)}s`);
                    p.style.setProperty('--dur', `${(0.72 + Math.random() * 0.55).toFixed(3)}s`);
                    p.style.setProperty('--spark', palette[i % palette.length]);
                    sparks.appendChild(p);
                }
            }

            const c = fx.querySelector('canvas');
            if (c) {
                try {
                    renderRacerModel(c.getContext('2d'), charId, 35, 35, 1.05, char, true);
                } catch (_) { }
            }

            setTimeout(() => fx.classList.add('out'), 960);
            setTimeout(() => fx.remove(), 1500);
        }

        function triggerRunnerUpgradeCelebration(charId, nextLevel) {
            const char = CHARACTERS[charId];
            showRunnerUpgradeFx(charId, nextLevel);
            playRunnerUpgradeSfx(char?.rarity || 'common', nextLevel);
        }

        function showChestUnlockCelebration(charId) {
            const char = CHARACTERS[charId];
            const host = document.querySelector('#chestModal .chest-modal-content');
            if (!char || !host) return;

            const fx = document.createElement('div');
            fx.className = 'chest-unlock-fx';
            fx.innerHTML = `
                <div class="chest-unlock-flash"></div>
                <div class="chest-unlock-ring"></div>
                <div class="chest-unlock-card">
                    <canvas width="86" height="86" id="chestUnlockAvatar-${charId}-${Date.now()}"></canvas>
                    <div class="chest-unlock-title">NUEVO CORREDOR</div>
                    <div class="chest-unlock-name" style="color:${char.color};">${char.name}</div>
                </div>
            `;
            host.appendChild(fx);
            const c = fx.querySelector('canvas');
            if (c) {
                try {
                    renderRacerModel(c.getContext('2d'), charId, 43, 43, 1.1, char);
                } catch (_) { }
            }
            setTimeout(() => fx.classList.add('out'), 1180);
            setTimeout(() => fx.remove(), 1700);
        }

        function unlockCharacterFromChest(charId) {
            const char = CHARACTERS[charId];
            if (!char) return false;
            if (!Array.isArray(GameData.unlockedCharacters)) GameData.unlockedCharacters = [];
            if (GameData.unlockedCharacters.includes(charId)) return false;

            GameData.unlockedCharacters.push(charId);
            if (!GameData.characterLevels[charId]) GameData.characterLevels[charId] = 1;
            if (!Array.isArray(window.__VS_UNLOCK_QUEUE)) window.__VS_UNLOCK_QUEUE = [];
            window.__VS_UNLOCK_QUEUE.push({ id: charId, ts: Date.now(), source: 'chest' });

            playChestUnlockRunnerSfx();
            showChestUnlockCelebration(charId);
            showNotification(`¡NUEVO CORREDOR DESBLOQUEADO! ${char.name}`);
            saveGame();
            return true;
        }

        function animateCardRewardProgress(cardsGiven, rewardEl) {
            if (!rewardEl || !Array.isArray(cardsGiven) || cardsGiven.length === 0) {
                return Promise.resolve();
            }

            rewardEl.classList.add('chest-single-large');
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const valid = cardsGiven
                .filter(c => c && c.id && CHARACTERS[c.id] && Number(c.count) > 0)
                .map(c => ({
                    id: c.id,
                    gain: Math.max(0, Math.floor(Number(c.count) || 0)),
                    char: CHARACTERS[c.id]
                }));

            if (valid.length === 0) return Promise.resolve();
            const rarityOrder = { mythic: 0, legendary: 1, epic: 2, rare: 3, uncommon: 4, common: 5 };
            const useGroupedLayout = true;
            const queue = valid.slice().sort((a, b) => {
                const aw = rarityOrder[a.char.rarity] ?? 99;
                const bw = rarityOrder[b.char.rarity] ?? 99;
                if (aw !== bw) return aw - bw;
                if (b.gain !== a.gain) return b.gain - a.gain;
                return String(a.char.name || '').localeCompare(String(b.char.name || ''));
            });
            const rarityVisuals = {
                common: {
                    cardBg: 'linear-gradient(145deg, rgba(38,45,60,0.78), rgba(20,24,34,0.9))',
                    border: 'rgba(190, 202, 220, 0.3)',
                    glow: '0 0 18px rgba(190, 202, 220, 0.12)',
                    badgeBg: 'rgba(190,202,220,0.14)'
                },
                uncommon: {
                    cardBg: 'linear-gradient(145deg, rgba(20,56,34,0.82), rgba(10,22,15,0.92))',
                    border: 'rgba(82, 240, 142, 0.42)',
                    glow: '0 0 22px rgba(82, 240, 142, 0.18)',
                    badgeBg: 'rgba(82,240,142,0.16)'
                },
                rare: {
                    cardBg: 'linear-gradient(145deg, rgba(18,48,90,0.84), rgba(10,20,42,0.94))',
                    border: 'rgba(101, 173, 255, 0.5)',
                    glow: '0 0 24px rgba(101, 173, 255, 0.22)',
                    badgeBg: 'rgba(101,173,255,0.2)'
                },
                epic: {
                    cardBg: 'linear-gradient(145deg, rgba(56,24,92,0.84), rgba(24,12,42,0.94))',
                    border: 'rgba(196, 123, 255, 0.52)',
                    glow: '0 0 26px rgba(196, 123, 255, 0.24)',
                    badgeBg: 'rgba(196,123,255,0.2)'
                },
                legendary: {
                    cardBg: 'linear-gradient(145deg, rgba(92,56,10,0.86), rgba(38,24,8,0.95))',
                    border: 'rgba(255, 201, 88, 0.6)',
                    glow: '0 0 30px rgba(255, 201, 88, 0.28)',
                    badgeBg: 'rgba(255,201,88,0.22)'
                },
                mythic: {
                    cardBg: 'linear-gradient(145deg, rgba(56,20,76,0.9), rgba(10,34,56,0.92), rgba(58,14,40,0.9))',
                    border: 'rgba(247, 112, 255, 0.65)',
                    glow: '0 0 34px rgba(163, 94, 255, 0.34)',
                    badgeBg: 'linear-gradient(135deg, rgba(255,62,141,0.24), rgba(0,247,255,0.18), rgba(168,85,247,0.22))'
                }
            };

            const wrapper = document.createElement('div');
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.gap = '11px';
            wrapper.style.margin = '10px auto 0';
            wrapper.style.width = 'min(660px, 100%)';
            wrapper.style.textAlign = 'left';
            wrapper.style.paddingRight = '0';

            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.alignItems = 'center';
            header.style.justifyContent = 'space-between';
            header.style.gap = '12px';

            const rarityBadge = document.createElement('div');
            rarityBadge.style.fontFamily = 'Orbitron';
            rarityBadge.style.fontSize = '0.84rem';
            rarityBadge.style.letterSpacing = '1.2px';
            rarityBadge.style.opacity = '0.95';
            rarityBadge.style.padding = '7px 11px';
            rarityBadge.style.borderRadius = '999px';
            rarityBadge.style.border = '1px solid rgba(255,255,255,0.2)';
            rarityBadge.style.background = 'rgba(255,255,255,0.05)';
            rarityBadge.style.textTransform = 'uppercase';

            const sequenceHint = document.createElement('div');
            sequenceHint.style.fontFamily = 'Orbitron';
            sequenceHint.style.fontSize = '0.82rem';
            sequenceHint.style.opacity = '0.88';
            sequenceHint.style.color = '#f9e27d';
            sequenceHint.style.padding = '5px 10px';
            sequenceHint.style.borderRadius = '999px';
            sequenceHint.style.background = 'rgba(255,215,0,0.08)';
            sequenceHint.style.border = '1px solid rgba(255,215,0,0.25)';

            header.appendChild(rarityBadge);
            header.appendChild(sequenceHint);
            wrapper.appendChild(header);

            const slot = document.createElement('div');
            slot.style.minHeight = '176px';
            slot.style.display = 'flex';
            slot.style.alignItems = 'center';
            slot.style.justifyContent = 'center';
            slot.style.position = 'relative';
            slot.style.overflow = 'hidden';
            wrapper.appendChild(slot);

            rewardEl.appendChild(wrapper);

            const rarityShiftColors = {
                common: '#c2cad8',
                uncommon: '#52f08e',
                rare: '#65adff',
                epic: '#c47bff',
                legendary: '#ffc958',
                mythic: '#ff62d5'
            };

            const runRarityWipe = (fromRarity, toRarity) => new Promise(resolve => {
                if (!fromRarity || !toRarity || fromRarity === toRarity) {
                    resolve();
                    return;
                }
                const fromColor = rarityShiftColors[fromRarity] || '#8aa4d6';
                const toColor = rarityShiftColors[toRarity] || '#8aa4d6';
                const wipe = document.createElement('div');
                wipe.style.position = 'absolute';
                wipe.style.inset = '0';
                wipe.style.pointerEvents = 'none';
                wipe.style.zIndex = '3';
                wipe.style.background = `linear-gradient(100deg, transparent 5%, ${fromColor}26 30%, ${toColor}45 52%, ${toColor}10 72%, transparent 95%)`;
                wipe.style.transform = 'translateX(-120%) skewX(-10deg)';
                wipe.style.opacity = '0.95';
                wipe.style.transition = 'transform 0.5s cubic-bezier(.2,.72,.25,1), opacity 0.5s ease';
                slot.appendChild(wipe);

                requestAnimationFrame(() => {
                    wipe.style.transform = 'translateX(120%) skewX(-10deg)';
                    wipe.style.opacity = '0.2';
                });

                setTimeout(() => {
                    wipe.remove();
                    resolve();
                }, 520);
            });

            const runSequential = async () => {
                let previousRarity = null;
                for (let qIndex = 0; qIndex < queue.length; qIndex++) {
                    const item = queue[qIndex];
                    if (qIndex > 0 && previousRarity !== item.char.rarity) {
                        await runRarityWipe(previousRarity, item.char.rarity);
                    }
                    const skin = rarityVisuals[item.char.rarity] || rarityVisuals.common;
                    sequenceHint.textContent = `${qIndex + 1}/${queue.length}`;
                    rarityBadge.textContent = `${getRarityName(item.char.rarity).toUpperCase()} · ${item.char.rarity.toUpperCase()}`;
                    rarityBadge.style.color = item.char.color || '#fff';
                    rarityBadge.style.borderColor = skin.border;
                    rarityBadge.style.background = skin.badgeBg;
                    rarityBadge.style.boxShadow = `0 0 16px ${(item.char.color || '#fff')}33`;

                    const startOwned = Math.max(0, Math.floor(Number(GameData.characterCards[item.id] || 0)));

                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.gap = '14px';
                    row.style.padding = '16px 18px';
                    row.style.width = '100%';
                    row.style.minHeight = '138px';
                    row.style.border = `1px solid ${skin.border}`;
                    row.style.borderRadius = '14px';
                    row.style.background = skin.cardBg;
                    row.style.boxShadow = `0 10px 26px rgba(0,0,0,0.3), inset 0 0 18px rgba(255,255,255,0.02), ${skin.glow}`;
                    row.style.opacity = '0';
                    row.style.transform = 'translateY(8px)';
                    row.style.transition = 'opacity 0.22s ease, transform 0.22s ease';

                    const icon = document.createElement('canvas');
                    const iconSize = useGroupedLayout ? 76 : 84;
                    icon.width = iconSize;
                    icon.height = iconSize;
                    row.appendChild(icon);
                    try {
                        renderRacerModel(icon.getContext('2d'), item.id, iconSize / 2, iconSize / 2, useGroupedLayout ? 1.03 : 1.12, item.char);
                    } catch (_) { }

                    const info = document.createElement('div');
                    info.style.flex = '1';
                    info.style.minWidth = '0';
                    info.innerHTML = `
                        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px;">
                            <span style="font-weight:900;color:${item.char.color};font-size:1.24rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-family:Orbitron;letter-spacing:0.4px;">${item.char.name}</span>
                            <span style="color:var(--accent-gold);font-size:1rem;font-family:Orbitron;">+${item.gain} tarjetas</span>
                        </div>
                    `;

                    const bar = document.createElement('div');
                    bar.style.position = 'relative';
                    bar.style.height = '24px';
                    bar.style.borderRadius = '999px';
                    bar.style.overflow = 'hidden';
                    bar.style.border = `1px solid ${skin.border}`;
                    bar.style.background = 'rgba(5,10,20,0.5)';

                    const fill = document.createElement('div');
                    fill.style.position = 'absolute';
                    fill.style.left = '0';
                    fill.style.top = '0';
                    fill.style.bottom = '0';
                    fill.style.width = '0%';
                    fill.style.background = `linear-gradient(90deg, ${item.char.color}, ${item.char.secondaryColor || '#b9e8ff'})`;
                    fill.style.transition = 'width 70ms linear';

                    const label = document.createElement('div');
                    label.style.position = 'absolute';
                    label.style.inset = '0';
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.justifyContent = 'center';
                    label.style.fontSize = '0.9rem';
                    label.style.fontFamily = 'Orbitron';
                    label.style.color = '#eaf9ff';
                    label.style.textShadow = '0 1px 3px rgba(0,0,0,0.9)';

                    bar.appendChild(fill);
                    bar.appendChild(label);
                    info.appendChild(bar);

                    const statusLine = document.createElement('div');
                    statusLine.style.marginTop = '7px';
                    statusLine.style.fontSize = '0.78rem';
                    statusLine.style.opacity = '0.92';
                    statusLine.style.color = '#bfe7ff';
                    statusLine.style.fontFamily = 'Orbitron';
                    info.appendChild(statusLine);

                    row.appendChild(info);
                    slot.innerHTML = '';
                    slot.appendChild(row);

                    requestAnimationFrame(() => {
                        row.style.opacity = '1';
                        row.style.transform = 'translateY(0)';
                    });

                    let current = startOwned;
                    let unlockTriggered = false;
                    let progressMode = 'unlock';
                    let req = CARD_REQUIREMENTS[item.char.rarity] || 10;
                    let currentLevel = GameData.characterLevels[item.id] || 1;

                    const resolveProgressTarget = () => {
                        const isUnlocked = GameData.unlockedCharacters.includes(item.id);
                        currentLevel = GameData.characterLevels[item.id] || 1;
                        if (!isUnlocked) {
                            progressMode = 'unlock';
                            req = CARD_REQUIREMENTS[item.char.rarity] || 10;
                            return;
                        }
                        if (currentLevel >= 10) {
                            progressMode = 'max';
                            req = Math.max(1, current);
                            return;
                        }
                        progressMode = 'upgrade';
                        req = Math.max(1, getUpgradeCardCost(item.id, currentLevel));
                    };

                    const computeUpgradeOverflowView = () => {
                        let overflow = Math.max(0, current - req);
                        let targetLevel = Math.min(10, currentLevel + 1);
                        if (targetLevel >= 10) {
                            return { overflow, targetLevel: 10, targetReq: Math.max(1, overflow || 1) };
                        }
                        let targetReq = Math.max(1, getUpgradeCardCost(item.id, targetLevel));
                        // Si hay tarjetas de sobra para más de un nivel, avanzar visualmente al siguiente pendiente.
                        while (targetLevel < 10 && overflow > targetReq) {
                            overflow -= targetReq;
                            targetLevel += 1;
                            if (targetLevel >= 10) {
                                return { overflow, targetLevel: 10, targetReq: Math.max(1, overflow || 1) };
                            }
                            targetReq = Math.max(1, getUpgradeCardCost(item.id, targetLevel));
                        }
                        return { overflow, targetLevel, targetReq };
                    };

                    const update = () => {
                        let displayCurrent = current;
                        let displayReq = req;

                        if (progressMode === 'upgrade' && current > req) {
                            const ov = computeUpgradeOverflowView();
                            displayCurrent = ov.overflow;
                            displayReq = ov.targetReq;
                        }

                        const pct = Math.max(0, Math.min(100, (displayCurrent / Math.max(1, displayReq)) * 100));
                        fill.style.width = `${pct}%`;
                        label.textContent = `${displayCurrent}/${displayReq} tarjetas`;
                        if (progressMode === 'unlock') {
                            const remain = Math.max(0, req - current);
                            statusLine.textContent = remain > 0
                                ? `Faltan ${remain} para desbloquear`
                                : `Listo para desbloquear`;
                            statusLine.style.color = remain > 0 ? '#bfe7ff' : '#7dffb2';
                        } else if (progressMode === 'upgrade') {
                            const overflow = Math.max(0, current - req);
                            if (overflow > 0) {
                                const ov = computeUpgradeOverflowView();
                                statusLine.textContent = ov.targetLevel >= 10
                                    ? `Excedente: ${ov.overflow}. Preparado para nivel máximo`
                                    : `Excedente: ${overflow}. Siguiente nivel (NVL ${ov.targetLevel}): ${ov.overflow}/${ov.targetReq}`;
                                statusLine.style.color = '#ffe37e';
                            } else {
                                const remain = Math.max(0, req - current);
                                statusLine.textContent = `Mejora NVL ${currentLevel + 1}: faltan ${remain}`;
                                statusLine.style.color = '#9fd3ff';
                            }
                        } else {
                            statusLine.textContent = 'Nivel máximo alcanzado';
                            statusLine.style.color = '#7dffb2';
                        }
                    };
                    resolveProgressTarget();
                    update();

                    const perStepDelay = Math.max(22, Math.min(180, 190 - (item.gain * 7)));
                    if (item.gain > 0) {
                        for (let i = 0; i < item.gain; i++) {
                            current += 1;
                            GameData.characterCards[item.id] = current;
                            update();
                            playCardTickSfx(i + 1, item.gain);
                            if (!unlockTriggered && progressMode === 'unlock' && current >= req && !GameData.unlockedCharacters.includes(item.id)) {
                                unlockTriggered = unlockCharacterFromChest(item.id);
                                if (unlockTriggered) {
                                    const unlockCost = CARD_REQUIREMENTS[item.char.rarity] || 10;
                                    const overflowAfterUnlock = Math.max(0, current - unlockCost);
                                    // Consumir tarjetas de desbloqueo y preservar solo excedente.
                                    current = overflowAfterUnlock;
                                    GameData.characterCards[item.id] = overflowAfterUnlock;
                                    resolveProgressTarget();
                                    update();
                                    if (overflowAfterUnlock > 0) {
                                        showNotification(`Excedente de ${item.char.name}: ${overflowAfterUnlock} tarjetas hacia mejora`);
                                    }
                                }
                            }
                            await sleep(perStepDelay);
                        }
                        playCardRowCompleteSfx(item.char.rarity);
                    }
                    rewardEl.scrollTop = 0;
                    await sleep(220);
                    previousRarity = item.char.rarity;
                }
            };

            return runSequential().then(() => {
                playChestCardsCompleteSfx();
                saveGame();
                if (typeof renderCharacters === 'function') {
                    renderCharacters();
                }
            });
        }

        function processChestReward() {
            const rewardEl = document.getElementById('chestReward');
            let rewardText = "";
            let bits = 0;
            let cardsGiven = [];

            // Lógica especial para Eventos
            const mReward = currentChestData.missionReward;

            if (currentChestData.type === 'event_glitch' && mReward) {
                // Dar cartas de Glitch directamente
                const amount = mReward.rewardCards || 10;
                cardsGiven.push({ id: 'glitch', count: amount });
                rewardText += `<div style="margin-bottom:10px;">+${amount} FRAGMENTOS GLITCH</div>`;
                bits = 100; // Bonus bits
            } else if (currentChestData.type === 'event_valentine' && mReward) {
                // Dar cartas de Monarch o aleatorias
                const amount = mReward.rewardCards || 5;
                cardsGiven.push({ id: 'monarch', count: amount });
                rewardText += `<div style="margin-bottom:10px;">+${amount} CARTAS MONARCH</div>`;
                bits = 100;
            } else {
                // Lógica de Cofres Normales
                const chest = CHEST_TYPES[currentChestData.type];
                if (chest) {
                    // (Lógica existente simplificada para no reescribir todo el bloque grande si no es necesario,
                    // pero aquí necesito conectar con el flujo normal)
                    // ... Para simplificar la edición, usaremos el bloque original si es posible o lo reescribimos si es corto.
                    // Al ser un replace, debo proveer toda la lógica.

                    bits = Math.floor(chest.minBits + Math.random() * (chest.maxBits - chest.minBits));

                    // Cartas
                    const numCards = Math.floor(chest.cardAmount[0] + Math.random() * (chest.cardAmount[1] - chest.cardAmount[0]));
                    for (let i = 0; i < numCards; i++) {
                        let rarity = 'common';
                        const r = Math.random();
                        let acc = 0;
                        for (const [rar, chance] of Object.entries(chest.rarityWeights)) {
                            acc += chance;
                            if (r <= acc) { rarity = rar; break; }
                        }

                        // Pick char
                        const pool = Object.entries(CHARACTERS).filter(([_, c]) => c.rarity === rarity);
                        if (pool.length > 0) {
                            const charId = pool[Math.floor(Math.random() * pool.length)][0];
                            // Add to list
                            const existing = cardsGiven.find(c => c.id === charId);
                            if (existing) existing.count++;
                            else cardsGiven.push({ id: charId, count: 1 });
                        }
                    }
                }
            }

            // Aplicar recompensas
            const bitsGranted = grantVoltBits(bits, true, `Cofre: ${currentChestData.type || 'normal'}`) ? bits : 0;
            // Build UI
            if (bitsGranted > 0) {
                rewardText += `<div>+${bitsGranted} <canvas id="rewardCoin" width="20" height="20"></canvas></div>`;
            } else if (bits > 0) {
                rewardText += `<div style="font-size:0.8rem;opacity:0.85;">Vincula Ocean Pay para reclamar +${bits} VoltBits</div>`;
            }

            rewardEl.innerHTML = rewardText;

            if (bitsGranted > 0) {
                setTimeout(() => {
                    const icon = document.getElementById('rewardCoin');
                    if (icon) renderRacerModel(icon.getContext('2d'), 'currency_voltbit', 10, 10, 0.8, { color: '#00e5ff' });
                }, 0);
            }

            updateVoltBitsDisplay();
            saveGame();

            rewardEl.classList.add('show');
            const closeBtn = document.getElementById('chestCloseBtn');
            closeBtn.style.display = 'none';
            animateCardRewardProgress(cardsGiven, rewardEl).finally(() => {
                closeBtn.style.display = 'inline-block';
                updateChestContinueLabel();
            });
        }


        function closeChestModal() {
            document.getElementById('chestModal').style.display = 'none';
            currentChestData = null;
            if (chestOpenQueue.length > 0) {
                setTimeout(showNextChestFromQueue, 120);
            }
        }

        function drawChestModel(ctx, type, x, y, scale = 1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            const colors = {
                electric: '#00e5ff',
                fortune: '#ffeb3b',
                battle_1: '#ffeb3b',
                battle_2: '#c0c0c0',
                battle_3: '#cd7f32',
                battle_4: '#607d8b',
                event_valentine: '#d500f9' // Pink/Purple base
            };
            const color = colors[type] || '#fff';

            // Base del cofre
            ctx.fillStyle = '#222';
            ctx.fillRect(-20, -10, 40, 30);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(-20, -10, 40, 30);

            // Tapa
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(-22, -10); ctx.lineTo(22, -10); ctx.lineTo(18, -25); ctx.lineTo(-18, -25);
            ctx.closePath(); ctx.fill();
            ctx.stroke();

            // Cerradura
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.arc(0, -5, 4, 0, Math.PI * 2); ctx.fill();

            // Efectos según tipo
            // Efectos según tipo
            if (type === 'electric') {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(-25, -30); ctx.lineTo(-15, -15); ctx.moveTo(25, -30); ctx.lineTo(15, -15); ctx.stroke();
            }

            if (type === 'event_valentine') {
                // Heart Pattern Texture
                ctx.fillStyle = '#ff80ab';
                ctx.globalAlpha = 0.5;
                ctx.beginPath(); ctx.arc(-10, 0, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(10, 0, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(0, 10, 5, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            if (type === 'glitch') {
                // Visual Glitch Chest
                ctx.fillStyle = '#111';
                ctx.fillRect(-20, -10, 40, 30);

                // Random Glitch Lines
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#00ff00' : '#fff';
                    const h = Math.random() * 20 + 2;
                    ctx.fillRect(-22, -12 + Math.random() * 30, 44, 2);
                }

                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                // Jitter effect
                const jitterX = (Math.random() - 0.5) * 4;
                ctx.strokeRect(-20 + jitterX, -10, 40, 30);
                ctx.setLineDash([]);

                // Binary
                ctx.fillStyle = '#0f0';
                ctx.font = '10px monospace';
                ctx.fillText('0101', -15, 5);
            }

            ctx.restore();
        }


        function showCharacterSelect() {
            document.getElementById('mainMenu').style.display = 'none';
            const modeScreen = document.getElementById('modeSelectScreen');
            if (modeScreen) modeScreen.style.display = 'none';
            document.getElementById('mapSelect').style.display = 'none';
            document.getElementById('characterSelect').style.display = 'flex';
            renderCharacters();
        }

        function showGarage() {
            showCharacterSelect();
        }

        function showMaps() {
            showModeSelect();
        }

        function showModeSelect() {
            if (!GameData.selectedCharacter) {
                alert('¡Selecciona un personaje primero!');
                return;
            }
            document.getElementById('characterSelect').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'none';
            const modeScreen = document.getElementById('modeSelectScreen');
            if (modeScreen) modeScreen.style.display = 'block';
            renderModeCardsBase();
        }

        function renderModeCardsBase() {
            const grid = document.getElementById('modeGrid');
            if (!grid) return;
            grid.innerHTML = '';
            Object.entries(MODES).forEach(([modeId, mode]) => {
                const card = document.createElement('div');
                card.className = `mode-card ${((GameData.selectedMode || 'CLASSIC') === modeId) ? 'active' : ''}`;
                card.onclick = () => {
                    GameData.selectedMode = modeId;
                    saveGame();
                    renderModeCardsBase();
                };
                card.innerHTML = `
                    <div style="font-family:Orbitron;color:var(--accent-cyan);font-size:1rem;">${mode.name}</div>
                    <div style="font-size:0.86rem;opacity:0.8;margin-top:8px;">${mode.desc}</div>
                `;
                grid.appendChild(card);
            });
        }

        function continueToMapSelection() {
            const modeScreen = document.getElementById('modeSelectScreen');
            if (modeScreen) modeScreen.style.display = 'none';
            showMapSelect();
        }

        function showMapsLegacyRandom() {
            let selectedCupId = null;
            let selectedMapId = null;

            // Mapas destacados por evento
            const eventFeaturedMaps = {
                'glitch': 'glitch_void',
                'valentine': 'jungle_temple'
            };

            const featuredMapId = activeEvent ? eventFeaturedMaps[activeEvent] : null;

            // 60% de probabilidad de elegir el mapa del evento si existe uno activo
            if (featuredMapId && Math.random() < 0.6) {
                selectedMapId = featuredMapId;
                // Encontrar a qué copa pertenece este mapa
                for (const [cupId, cup] of Object.entries(CUPS)) {
                    if (cup.maps.includes(selectedMapId)) {
                        selectedCupId = cupId;
                        break;
                    }
                }
            }

            // Si no se eligió mapa de evento (o no hay evento), elegir uno al azar
            if (!selectedMapId) {
                const cupKeys = Object.keys(CUPS);
                selectedCupId = cupKeys[Math.floor(Math.random() * cupKeys.length)];
                const cup = CUPS[selectedCupId];
                selectedMapId = cup.maps[Math.floor(Math.random() * cup.maps.length)];
            }

            GameData.selectedMap = selectedMapId;
            GameData.selectedCup = selectedCupId;
            saveGame();

            startRaceWithCountdown();
        }

        function showMapSelect() {
            if (!GameData.selectedCharacter) {
                alert('¡Selecciona un personaje primero!');
                return;
            }
            document.getElementById('characterSelect').style.display = 'none';
            const modeScreen = document.getElementById('modeSelectScreen');
            if (modeScreen) modeScreen.style.display = 'none';
            document.getElementById('mapSelect').style.display = 'flex';
            renderMaps();
        }

        function renderMaps() {
            const grid = document.getElementById('mapsGrid');
            grid.innerHTML = '';

            for (const [cupId, cup] of Object.entries(CUPS)) {
                const cupTitle = document.createElement('h3');
                cupTitle.style.gridColumn = '1 / -1';
                cupTitle.style.color = 'var(--accent-cyan)';
                cupTitle.style.marginTop = '20px';
                cupTitle.style.borderBottom = '1px solid rgba(0,247,255,0.3)';
                cupTitle.textContent = cup.name;
                grid.appendChild(cupTitle);

                cup.maps.forEach(mapId => {
                    const map = MAPS[mapId];
                    if (!map) return;
                    const isSelected = GameData.selectedMap === mapId;

                    const card = document.createElement('div');
                    card.className = `map-card ${isSelected ? 'selected' : ''}`;
                    card.style.borderColor = isSelected ? map.accentColor : 'transparent';
                    card.onclick = () => selectMap(mapId);

                    card.innerHTML = `
                        <div class="map-icon" id="map-icon-${mapId}"></div>
                        <div class="map-name" style="color: ${map.accentColor}">${map.name}</div>
                        <p class="map-desc">${map.description}</p>
                        <p style="font-size: 0.7rem; opacity: 0.7; margin-top: 5px;">DISTANCIA: ${map.distance}m</p>
                        ${map.hazards ? `<span style="color: #f44336; font-size: 0.7rem;">⚠️ PELIGRO: ${map.hazards.toUpperCase()}</span>` : ''}
                    `;

                    grid.appendChild(card);
                    setTimeout(() => drawMapIcon(mapId, map), 50);
                });
            }
        }

        function drawMapPreview(id, map) {
            const container = document.getElementById(`mapPreview-${id}`);
            if (!container) return;

            const canvas = document.createElement('canvas');
            canvas.width = 280;
            canvas.height = 120;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            container.appendChild(canvas);

            const ctx = canvas.getContext('2d');

            // Fondo
            ctx.fillStyle = map.bgColor;
            ctx.fillRect(0, 0, 280, 120);

            // Pista
            for (let i = 0; i < 4; i++) {
                const y = 20 + i * 25;
                ctx.fillStyle = map.trackColor;
                ctx.fillRect(0, y, 280, 20);

                // Línea de carril
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.setLineDash([10, 8]);
                ctx.beginPath();
                ctx.moveTo(0, y + 10);
                ctx.lineTo(280, y + 10);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Partículas decorativas según el mapa
            ctx.fillStyle = map.accentColor;
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * 280;
                const y = Math.random() * 120;
                const size = Math.random() * 3 + 1;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Borde decorativo
            ctx.strokeStyle = map.accentColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, 278, 118);
        }

        // Nueva función para iconos pequeños del grid
        function drawMapIcon(id, map) {
            const container = document.getElementById(`map-icon-${id}`);
            if (!container) return;

            // Limpiar previo
            container.innerHTML = '';

            const canvas = document.createElement('canvas');
            canvas.width = 60;
            canvas.height = 60;
            canvas.style.borderRadius = '8px';
            container.appendChild(canvas);

            const ctx = canvas.getContext('2d');

            // Fondo oscuro
            ctx.fillStyle = map.bgColor;
            ctx.fillRect(0, 0, 60, 60);

            // Icono simple generado proceduralmente
            ctx.fillStyle = map.accentColor;
            ctx.beginPath();
            ctx.arc(30, 30, 15, 0, Math.PI * 2);
            ctx.fill();

            // Detalles
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(10, 30);
            ctx.lineTo(50, 30);
            ctx.stroke();
        }

        function selectMap(id) {
            GameData.selectedMap = id;
            saveGame();
            renderMaps();
        }

        // Función de cuenta regresiva
        async function startRaceWithCountdown() {
            if (!GameData.selectedCharacter) {
                alert('¡Selecciona un personaje primero!');
                return;
            }

            // Cerrar cualquier pantalla previa para evitar solapamientos visuales
            ['mainMenu', 'characterSelect', 'modeSelectScreen', 'mapSelect', 'shopMenu', 'eventsScreen', 'resultsScreen']
                .forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });

            // Si llegamos aqui sin mapa (ej. desde el trailer), asignar uno por defecto
            if (!GameData.selectedMap) {
                GameData.selectedMap = 'neon_city';
                GameData.selectedCup = 'cyber_cup';
            }

            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Leer modo seleccionado desde la pantalla dedicada de modos
            if (!gameState.trailer) {
                gameState.mode = GameData.selectedMode || 'CLASSIC';
            }

            initRace();

            // --- PANTALLA VERSUS ---
            const versusScreen = document.getElementById('versusScreen');
            const vsCupName = document.getElementById('vsCupName');
            const vsMapInfo = document.getElementById('vsMapInfo');
            const vsGrid = document.getElementById('vsRacerGrid');

            const map = MAPS[GameData.selectedMap];
            const cup = CUPS[GameData.selectedCup] || { name: 'SURGE CHALLENGE' };

            vsCupName.textContent = cup.name;
            vsMapInfo.textContent = `${map.name.toUpperCase()} - ${map.distance.toLocaleString()} M`.replace('⚠️ ', '').replace(' ⚠️', '');

            vsGrid.innerHTML = '';

            const allParticipants = [gameState.player, ...gameState.bots];

            allParticipants.forEach((r, idx) => {
                const card = document.createElement('div');
                card.className = `versus-card ${r.isPlayer ? 'is-player' : ''}`;
                card.style.animationDelay = `${idx * 0.1}s`;

                const cvs = document.createElement('canvas');
                cvs.width = 120; cvs.height = 120;
                card.appendChild(cvs);

                const info = document.createElement('div');
                info.style.textAlign = 'center';
                info.innerHTML = `
                    <div class="name">${r.name}</div>
                    <div class="char-name">${r.character.name}</div>
                `;
                card.appendChild(info);

                vsGrid.appendChild(card);

                // VS Badge between player and first bot
                if (idx === 0 && allParticipants.length > 1) {
                    const vsBadge = document.createElement('div');
                    vsBadge.style.display = 'flex';
                    vsBadge.style.alignItems = 'center';
                    vsBadge.style.justifyContent = 'center';
                    vsBadge.style.fontSize = '2rem';
                    vsBadge.style.fontWeight = 'bold';
                    vsBadge.style.color = 'var(--accent-pink)';
                    vsBadge.style.textShadow = '0 0 10px rgba(255,62,141,0.5)';
                    vsBadge.textContent = 'VS';
                    vsGrid.appendChild(vsBadge);
                }

                setTimeout(() => {
                    const ctxR = cvs.getContext('2d');
                    const char = r.character;

                    // Fondo circular similar a characterSelect
                    const gradient = ctxR.createRadialGradient(60, 60, 0, 60, 60, 60);
                    gradient.addColorStop(0, char.secondaryColor + '44');
                    gradient.addColorStop(1, char.color + '22');

                    ctxR.beginPath();
                    ctxR.arc(60, 60, 58, 0, Math.PI * 2);
                    ctxR.fillStyle = gradient;
                    ctxR.fill();
                    ctxR.strokeStyle = char.color;
                    ctxR.lineWidth = 1;
                    ctxR.stroke();

                    if (char.rarity === 'mythic' || char.rarity === 'legendary') {
                        ctxR.shadowColor = char.color;
                        ctxR.shadowBlur = 15;
                    }

                    renderRacerModel(ctxR, r.characterId, 60, 60, 1.8, r.character);
                }, 100);
            });

            versusScreen.style.display = 'flex';
            await new Promise(r => setTimeout(r, 4000)); // 4 segundos total de faneo

            versusScreen.style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';

            // Si es trailer, saltar countdown
            if (gameState.trailer) {
                gameLoop();
                return;
            }

            // Mostrar countdown
            const overlay = document.getElementById('countdownOverlay');
            const countdownText = document.getElementById('countdownText');
            overlay.classList.remove('hidden');

            for (let i = 3; i >= 1; i--) {
                countdownText.className = 'countdown-number';
                countdownText.textContent = i;
                countdownText.style.animation = 'none';
                countdownText.offsetHeight; // Trigger reflow
                countdownText.style.animation = 'countdownPulse 1s ease-in-out';
                await new Promise(r => setTimeout(r, 1000));
            }

            countdownText.className = 'countdown-go';
            countdownText.textContent = '¡GO!';
            countdownText.style.animation = 'none';
            countdownText.offsetHeight;
            countdownText.style.animation = 'goAnimation 0.8s ease-out forwards';
            await new Promise(r => setTimeout(r, 800));

            overlay.classList.add('hidden');
            gameLoop();
        }

        let _voltBitsLoginNoticeTs = 0;

        function isOceanPayLinkedForVoltBits() {
            return typeof oceanPayState !== 'undefined'
                && !!oceanPayState
                && !!oceanPayState.token
                && oceanPayState.linked === true;
        }

        function canUseVoltBits(showNotice = false) {
            const linked = isOceanPayLinkedForVoltBits();
            if (!linked && showNotice) {
                const now = Date.now();
                if (now - _voltBitsLoginNoticeTs > 2500) {
                    _voltBitsLoginNoticeTs = now;
                    if (typeof showNotification === 'function') {
                        showNotification('Inicia sesion con Ocean Pay para ver y obtener VoltBits.');
                    }
                }
            }
            return linked;
        }

        function grantVoltBits(amount, showNotice = true) {
            const safeAmount = Math.max(0, Math.floor(Number(amount) || 0));
            if (!safeAmount) return false;
            if (!canUseVoltBits(showNotice)) return false;
            GameData.voltBits += safeAmount;
            return true;
        }

        function updateVoltBitsDisplay() {
            const amountEl = document.getElementById('voltBitsAmount');
            const iconEl = document.getElementById('voltBitIcon');
            const linked = isOceanPayLinkedForVoltBits();

            if (amountEl) {
                if (linked) {
                    amountEl.textContent = Math.floor(GameData.voltBits || 0);
                    amountEl.style.fontSize = '';
                    amountEl.style.letterSpacing = '';
                    amountEl.style.opacity = '1';
                    amountEl.title = '';
                    amountEl.style.cursor = 'default';
                    amountEl.style.textDecoration = 'none';
                    amountEl.onclick = null;
                } else {
                    amountEl.textContent = 'Inicia sesion en Ocean Pay';
                    amountEl.style.fontSize = '0.68rem';
                    amountEl.style.letterSpacing = '0.4px';
                    amountEl.style.opacity = '0.9';
                    amountEl.title = 'Para ver y obtener VoltBits debes iniciar sesion con tu cuenta de Ocean Pay.';
                    amountEl.style.cursor = 'pointer';
                    amountEl.style.textDecoration = 'underline';
                    amountEl.onclick = () => openOceanPayLinkFromBalance();
                }
            }

            if (iconEl) {
                iconEl.style.opacity = linked ? '1' : '0.55';
            }

            // Redibujar icono si existe
            const canvas = document.getElementById('voltBitIcon');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                renderRacerModel(ctx, 'currency_voltbit', 15, 15, 1, { color: '#00e5ff' });
            }
        }

        function openOceanPayLinkFromBalance() {
            if (typeof oceanPayState === 'undefined' || !oceanPayState) return;
            oceanPayState.amount = 0;
            oceanPayState.concept = 'Vincular cuenta Ocean Pay';
            oceanPayState.onSuccess = null;
            if (typeof updateOceanPayUI === 'function') updateOceanPayUI();
            const modal = document.getElementById('oceanPayIntegratedModal');
            if (modal) modal.style.display = 'flex';
        }

        function renderCharacters() {
            const grid = document.getElementById('charactersGrid');
            grid.innerHTML = '';

            const rarityWeight = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4, mythic: 5 };
            const sortedChars = Object.entries(CHARACTERS).sort((a, b) => {
                const weightA = rarityWeight[a[1].rarity] || 0;
                const weightB = rarityWeight[b[1].rarity] || 0;
                if (weightA !== weightB) return weightA - weightB;
                return a[1].price - b[1].price;
            });

            for (const [id, char] of sortedChars) {
                const isUnlocked = GameData.unlockedCharacters.includes(id);
                const isSelected = GameData.selectedCharacter === id;
                const charLevel = GameData.characterLevels[id] || 1;

                const card = document.createElement('div');
                card.className = `char-card ${isUnlocked ? '' : 'locked'} ${isSelected ? 'selected' : ''}`;
                card.style.borderColor = isSelected ? char.color : 'transparent';

                card.innerHTML = `
                    ${isUnlocked ? `<div class="char-level-badge">LVL ${charLevel}</div>` : ''}
                    <div class="char-avatar" id="avatar-${id}"></div>
                    <div class="char-name" style="color: ${char.color}">${char.name}</div>
                    <span class="char-rarity rarity-${char.rarity}">${getRarityName(char.rarity)}</span>
                    <div class="char-stats" style="margin: 10px 0; font-size: 0.7rem; color: #aaa;">
                        ${char.stats ? `
                        S: ${char.stats.speed} | A: ${char.stats.accel} | H: ${char.stats.handling}
                        ` : ''}
                    </div>
                    ${isUnlocked ? `<button class="menu-btn" onclick="event.stopPropagation(); openUpgradeModal('${id}')" style="padding: 5px 10px; min-width: 100px; font-size: 0.8rem; margin-bottom: 5px;">🔧 MEJORAR</button>` : ''}
                    <p class="char-effect">${char.effect}</p>
`;
                card.onclick = () => {
                    if (isUnlocked) {
                        selectCharacter(id);
                    } else {
                        const req = CARD_REQUIREMENTS[char.rarity] || 10;
                        const owned = GameData.characterCards[id] || 0;
                        if (owned >= req) {
                            unlockCharacter(id);
                        } else {
                            showNotification(`¡Reúne ${req - owned} tarjetas más de ${char.name}!`);
                        }
                    }
                };

                grid.appendChild(card);

                const req = CARD_REQUIREMENTS[char.rarity] || 10;
                const owned = GameData.characterCards[id] || 0;

                if (isUnlocked) {
                    // Show Level
                    // ...
                } else {
                    // Show Progress Bar
                    const progress = Math.min(100, (owned / req) * 100);
                    card.innerHTML += `
                         <div style="position:absolute; bottom:10px; width:80%; height:5px; background:#333; border-radius:3px; overflow:hidden;">
                              <div style="width:${progress}%; height:100%; background:${char.color};"></div>
                         </div>
                         <div style="position:absolute; bottom:20px; font-size:0.7rem; color:#fff;">${owned}/${req} CARTAS</div>
                     `;

                    if (owned >= req) {
                        card.style.border = '2px solid #0f0';
                        card.onclick = () => { unlockCharacter(id); };
                        card.innerHTML += `<div style="position:absolute; inset:0; background:rgba(0,255,0,0.2); display:flex; align-items:center; justify-content:center; color:#fff; font-weight:bold;">¡DESBLOQUEAR!</div>`;
                    }
                }

                // Dibujar avatar
                setTimeout(() => {
                    drawCharacterAvatar(id, char);
                }, 50);
            }
        }

        function unlockCharacter(id) {
            const char = CHARACTERS[id];
            const req = CARD_REQUIREMENTS[char.rarity] || 10;
            const owned = GameData.characterCards[id] || 0;

            if (owned >= req) {
                GameData.characterCards[id] -= req; // Consumir cartas? Or keep them for levels? 
                // "Unlock requires cards", usually consumes.
                // If cards are also for leveling, maybe dont consume?
                // User said "rarity makes quantity vary", implies collecting to unlock.
                // Let's CONSUME them for Unlock.
                GameData.unlockedCharacters.push(id);
                saveGame();
                renderCharacters();
                alert(`¡${char.name} DESBLOQUEADO!`);
            }
        }

        function getUpgradeCardCost(charId, level) {
            const char = CHARACTERS[charId];
            const base = { common: 5, uncommon: 10, rare: 25, epic: 50, legendary: 100, mythic: 250 };
            return (base[char.rarity] || 10) * level;
        }

        let upgradeCharId = null;
        function openUpgradeModal(id) {
            upgradeCharId = id;
            const char = CHARACTERS[id];
            const level = GameData.characterLevels[id] || 1;
            const nextLevel = level + 1;
            const cost = level * 200;
            const cardCost = getUpgradeCardCost(id, level);
            const ownedCards = GameData.characterCards[id] || 0;

            const titleEl = document.getElementById('upgradeTitle');
            if (titleEl) titleEl.textContent = `MEJORAR ${char.name}`;
            const costEl = document.getElementById('upgradeCost');
            if (costEl) costEl.textContent = cost;

            const cardReqEl = document.getElementById('upgradeCardsNeeded');
            if (cardReqEl) {
                cardReqEl.textContent = `${ownedCards}/${cardCost}`;
                cardReqEl.style.color = ownedCards >= cardCost ? '#0f0' : '#f00';
            }

            // Icono de costo en modal
            const costIconCvs = document.createElement('canvas');
            costIconCvs.width = 30; costIconCvs.height = 30;
            const costArea = document.querySelector('.upgrade-price');
            if (costArea) {
                const existing = costArea.querySelector('canvas');
                if (existing) existing.remove();
                costArea.prepend(costIconCvs);
                renderRacerModel(costIconCvs.getContext('2d'), 'currency_voltbit', 15, 15, 1, { color: '#00e5ff' });
            }

            const nextLvlEl = document.getElementById('nextLvl');
            if (nextLvlEl) nextLvlEl.textContent = nextLevel;

            // Preview
            const preview = document.getElementById('upgradeCharacterPreview');
            if (preview) {
                preview.innerHTML = '';
                const canvas = document.createElement('canvas');
                canvas.width = 100; canvas.height = 100;
                preview.appendChild(canvas);
                renderRacerModel(canvas.getContext('2d'), id, 50, 50, 1.2, char);
            }

            // Bars
            const stats = char.stats || { speed: 5, accel: 5, handling: 5 };
            const bonus = 1 + (level - 1) * 0.05; // 5% por nivel

            const speedBar = document.getElementById('bar-speed');
            if (speedBar) speedBar.style.width = Math.min(100, (stats.speed * bonus * 10)) + '%';
            const speedVal = document.getElementById('val-speed');
            if (speedVal) speedVal.textContent = (stats.speed * bonus).toFixed(1);

            const accelBar = document.getElementById('bar-accel');
            if (accelBar) accelBar.style.width = Math.min(100, (stats.accel * bonus * 10)) + '%';
            const accelVal = document.getElementById('val-accel');
            if (accelVal) accelVal.textContent = (stats.accel * bonus).toFixed(1);

            const handBar = document.getElementById('bar-handling');
            if (handBar) handBar.style.width = Math.min(100, (stats.handling * bonus * 10)) + '%';
            const handVal = document.getElementById('val-handling');
            if (handVal) handVal.textContent = (stats.handling * bonus).toFixed(1);

            const btn = document.getElementById('upgradeBtn');
            if (!btn) return;
            const upgradeStatsEl = document.querySelector('.upgrade-stats');
            const upListId = 'upgradeBoostList';
            const renderUpgradeBoostLayout = () => {
                if (!upgradeStatsEl) return;
                let list = document.getElementById(upListId);
                if (!list) {
                    list = document.createElement('div');
                    list.id = upListId;
                    list.style.display = 'flex';
                    list.style.flexDirection = 'column';
                    list.style.gap = '10px';
                    list.style.marginTop = '10px';
                    upgradeStatsEl.after(list);
                }

                const levelForPreview = Math.min(nextLevel, 10);
                const affectsTurbo = [2, 5, 8].includes(levelForPreview);
                const affectsProjectile = [3, 6, 9].includes(levelForPreview);
                const affectsTrap = [4, 7, 10].includes(levelForPreview);
                const rows = [];

                rows.push({
                    title: 'ESTADÍSTICAS BASE',
                    detail: 'VELOCIDAD/ACELERACIÓN/MANEJO AUMENTADO',
                    color: 'var(--accent-cyan)',
                    iconEffect: 'knockback'
                });
                if (affectsProjectile || level >= 10) {
                    rows.push({
                        title: char.projectile?.name || 'ATAQUE',
                        detail: 'DAÑO/VELOCIDAD AUMENTADO',
                        color: char.color || '#ff9800',
                        iconEffect: char.projectile?.effect || 'knockback'
                    });
                }
                if (affectsTurbo || level >= 10) {
                    rows.push({
                        title: char.turbo?.name || 'TURBO',
                        detail: 'VELOCIDAD/IMPACTO AUMENTADO',
                        color: char.secondaryColor || '#00e5ff',
                        iconEffect: char.turbo?.effect || 'fire_trail'
                    });
                }
                if (affectsTrap || level >= 10) {
                    rows.push({
                        title: char.trap?.name || 'TRAMPA',
                        detail: 'EFECTO/DURACIÓN AUMENTADO',
                        color: '#ff6d6d',
                        iconEffect: char.trap?.effect || 'slow'
                    });
                }

                list.innerHTML = '';
                rows.forEach((row) => {
                    const card = document.createElement('div');
                    card.style.display = 'flex';
                    card.style.alignItems = 'center';
                    card.style.gap = '10px';
                    card.style.padding = '9px 10px';
                    card.style.border = `1px solid ${row.color}55`;
                    card.style.borderRadius = '10px';
                    card.style.background = 'rgba(6, 10, 24, 0.78)';
                    card.style.textAlign = 'left';

                    const icon = document.createElement('canvas');
                    icon.width = 44;
                    icon.height = 44;
                    card.appendChild(icon);
                    try {
                        renderAbilityIcon(icon.getContext('2d'), row.iconEffect, row.color, 44);
                    } catch (_) { }

                    const txt = document.createElement('div');
                    txt.style.flex = '1';
                    txt.innerHTML = `
                        <div style="font-family:Orbitron;font-size:0.76rem;color:${row.color};letter-spacing:0.4px;">${row.title}</div>
                        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.16);margin:4px 0 5px 0;">
                        <div style="font-size:0.73rem;color:#d8f8ff;opacity:0.94;">${row.detail}</div>
                    `;
                    card.appendChild(txt);
                    list.appendChild(card);
                });
            };

            if (level >= 10) {
                btn.textContent = 'NIVEL MÁXIMO';
                btn.disabled = true;
                btn.style.opacity = '0.5';
            } else {
                btn.textContent = `MEJORAR (LVL ${nextLevel})`;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
            renderUpgradeBoostLayout();

            const modal = document.getElementById('upgradeModal');
            if (modal) modal.style.display = 'flex';
        }

        function closeUpgradeModal() {
            document.getElementById('upgradeModal').style.display = 'none';
        }

        function applyUpgrade() {
            const charId = upgradeCharId;
            const char = CHARACTERS[charId];
            const level = GameData.characterLevels[charId] || 1;
            const cost = level * 200;
            const cardCost = getUpgradeCardCost(charId, level);
            const ownedCards = GameData.characterCards[charId] || 0;

            if (GameData.voltBits >= cost && ownedCards >= cardCost && level < 10) {
                startOceanPayTransaction(cost, `Mejora de ${char.name} (NVL ${level + 1})`, () => {
                    GameData.voltBits -= cost;
                    GameData.characterCards[charId] -= cardCost;
                    GameData.characterLevels[charId] = level + 1;
                    saveGame();
                    updateVoltBitsDisplay();
                    renderCharacters();
                    openUpgradeModal(charId); // Refrescar modal
                    setTimeout(() => triggerRunnerUpgradeCelebration(charId, level + 1), 30);

                    showNotification(`¡${char.name} MEJORADO AL NIVEL ${level + 1}!`);
                });
            } else if (ownedCards < cardCost) {
                alert(`¡Necesitas ${cardCost - ownedCards} tarjetas más de ${char.name}!`);
            } else if (level >= 10) {
                alert('¡Nivel máximo alcanzado!');
            } else {
                alert('¡Faltan VoltBits!');
            }
        }

        function getRarityName(rarity) {
            const names = {
                common: 'Común',
                uncommon: 'Poco Común',
                rare: 'Raro',
                epic: 'Épico',
                legendary: 'Legendario',
                mythic: 'Mítico'
            };
            return names[rarity] || rarity;
        }

        function renderRacerModel(ctx, id, x, y, scale = 1, char, isTurbo = false) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            const color = (char && char.color) ? char.color : '#00e5ff';
            const secColor = (char && char.secondaryColor) ? char.secondaryColor : '#b3f5ff';

            switch (id) {
                case 'blaze': // Triángulo aerodinámico tipo jet
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(30, 0); ctx.lineTo(-25, -20); ctx.lineTo(-15, 0); ctx.lineTo(-25, 20); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, -8); ctx.lineTo(-5, 0); ctx.lineTo(-10, 8); ctx.closePath(); ctx.fill();
                    if (isTurbo) {
                        ctx.fillStyle = '#ff9800';
                        ctx.beginPath(); ctx.moveTo(-20, -10); ctx.lineTo(-45, 0); ctx.lineTo(-20, 10); ctx.fill();
                    }
                    break;
                case 'prop_neon_sign':
                    ctx.strokeStyle = char.color; ctx.lineWidth = 2;
                    ctx.strokeRect(-15, -25, 30, 50);
                    ctx.fillStyle = char.color; ctx.font = 'bold 10px Orbitron';
                    ctx.fillText('NEON', -12, 0);
                    break;
                case 'prop_crystal':
                    ctx.fillStyle = char.color + 'aa';
                    ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(15, 0); ctx.lineTo(0, 30); ctx.lineTo(-15, 0); ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.stroke();
                    break;
                case 'prop_rock':
                    ctx.fillStyle = '#555';
                    ctx.beginPath(); ctx.moveTo(-20, 10); ctx.lineTo(0, -20); ctx.lineTo(25, 15); ctx.closePath(); ctx.fill();
                    break;
                case 'prop_cloud':
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.arc(15, -5, 15, 0, Math.PI * 2); ctx.arc(-15, -5, 15, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'prop_gear':
                    ctx.fillStyle = '#333';
                    ctx.save(); ctx.rotate(Date.now() / 1000);
                    for (let i = 0; i < 8; i++) {
                        ctx.rotate(Math.PI / 4);
                        ctx.fillRect(15, -5, 10, 10);
                    }
                    ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                    break;
                case 'frost': // Hexágono cristalino
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (Math.PI * 2 / 6) * i;
                        ctx.lineTo(Math.cos(a) * 25, Math.sin(a) * 25);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'volt': // Forma de rayo / NAVE Z
                    ctx.strokeStyle = color; ctx.lineWidth = 5;
                    ctx.beginPath(); ctx.moveTo(25, -15); ctx.lineTo(0, 5); ctx.lineTo(15, 5); ctx.lineTo(-20, 25); ctx.stroke();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'terra': // Bloque pesado
                    ctx.fillStyle = color;
                    ctx.fillRect(-25, -18, 50, 36);
                    ctx.strokeStyle = secColor; ctx.lineWidth = 3;
                    ctx.strokeRect(-20, -14, 40, 28);
                    ctx.fillStyle = secColor;
                    ctx.fillRect(15, -10, 10, 20); // Frente reforzado
                    break;
                case 'shadow': // Cápsula fantasmal
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.ellipse(0, 0, 30, 15, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(-20, 0, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                    break;
                case 'storm': // Disco rotatorio
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = secColor; ctx.lineWidth = 4;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI * 2); ctx.stroke();
                    ctx.setLineDash([]);
                    break;
                case 'phoenix': // Forma de ala delta orgánica
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(35, 0); ctx.quadraticCurveTo(0, -30, -30, -10); ctx.lineTo(-20, 0); ctx.lineTo(-30, 10); ctx.quadraticCurveTo(0, 30, 35, 0);
                    ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.ellipse(5, 0, 15, 5, 0, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'cosmos': // Esfera con anillo
                    ctx.strokeStyle = secColor; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.ellipse(0, 0, 40, 10, Math.PI / 4, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'aqua': // Gota de agua horizontal
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(30, 0); ctx.bezierCurveTo(10, -25, -40, -15, -40, 0); ctx.bezierCurveTo(-40, 15, 10, 25, 30, 0);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath(); ctx.ellipse(10, -5, 8, 4, -0.4, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'venom': // Nave orgánica espinosa
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(30, 0); ctx.lineTo(-10, -20); ctx.lineTo(0, 0); ctx.lineTo(-10, 20); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath(); ctx.arc(-15, -10 + i * 10, 4, 0, Math.PI * 2); ctx.fill();
                    }
                    break;
                case 'nova': // Estrella de 4 puntas
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const a = (Math.PI * 2 / 4) * i;
                        const r = i % 2 === 0 ? 30 : 10;
                        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'cyber': // Nave rectangular con líneas de datos
                    ctx.fillStyle = color;
                    ctx.fillRect(-20, -15, 40, 30);
                    ctx.strokeStyle = secColor; ctx.lineWidth = 2;
                    ctx.strokeRect(-22, -17, 44, 34);
                    ctx.fillStyle = secColor;
                    ctx.fillRect(10, -5, 15, 10); // Cabina
                    // Líneas de circuito
                    ctx.beginPath();
                    ctx.moveTo(-10, -10); ctx.lineTo(-10, 10); ctx.moveTo(-5, -10); ctx.lineTo(-5, 10);
                    ctx.stroke();
                    break;
                case 'aether': // Forma de rombo vacío con aura
                    ctx.shadowBlur = 10; ctx.shadowColor = color;
                    ctx.strokeStyle = color; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(25, 0); ctx.lineTo(0, 30); ctx.lineTo(-25, 0); ctx.closePath(); ctx.stroke();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                    break;
                case 'titan': // Tanque pesado
                    ctx.fillStyle = color;
                    ctx.fillRect(-30, -20, 50, 40);
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.moveTo(20, -25); ctx.lineTo(35, 0); ctx.lineTo(20, 25); ctx.fill();
                    ctx.fillRect(-35, -10, 10, 20);
                    break;
                case 'nebula': // Forma de nebulosa gaseosa
                    ctx.fillStyle = color;
                    for (let i = 0; i < 5; i++) {
                        const ox = Math.cos(i) * 15;
                        const oy = Math.sin(i) * 10;
                        ctx.beginPath(); ctx.arc(ox, oy, 15, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'gear': // Engranaje
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    for (let i = 0; i < 16; i++) {
                        const a = (Math.PI * 2 / 16) * i;
                        const r = i % 2 === 0 ? 28 : 20;
                        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'solar': // Sol radiante
                    ctx.fillStyle = color;
                    ctx.shadowBlur = 15; ctx.shadowColor = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = secColor; ctx.lineWidth = 3;
                    for (let i = 0; i < 8; i++) {
                        const a = (Math.PI * 2 / 8) * i;
                        ctx.beginPath(); ctx.moveTo(Math.cos(a) * 22, Math.sin(a) * 22); ctx.lineTo(Math.cos(a) * 32, Math.sin(a) * 32); ctx.stroke();
                    }
                    break;
                case 'magma': // Taladro pesado volcánico
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(35, 0); ctx.lineTo(-15, -25); ctx.lineTo(-15, 25); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.fillRect(-25, -15, 10, 30);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath(); ctx.moveTo(10 + i * 8, -5); ctx.lineTo(10 + i * 8, 5); ctx.stroke();
                    }
                    break;
                case 'resonance': // Diapasón vibratorio
                    ctx.strokeStyle = color; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(-20, -15); ctx.lineTo(10, -15); ctx.arc(10, 0, 15, -Math.PI / 2, Math.PI / 2); ctx.lineTo(-20, 15); ctx.stroke();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(-10, 0, 10, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'bone': // Nave esquelética
                    ctx.strokeStyle = color; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(-20, -20); ctx.lineTo(20, 20); ctx.moveTo(20, -20); ctx.lineTo(-20, 20); ctx.stroke();
                    ctx.fillStyle = secColor; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'plasma': // Núcleo circular inestable
                    ctx.fillStyle = color; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = secColor; ctx.lineWidth = 5;
                    ctx.beginPath(); ctx.arc(0, 0, 28, Date.now() / 100, Date.now() / 100 + 2); ctx.stroke();
                    break;
                case 'drift': // Coche de carreras estilizado
                    ctx.fillStyle = color; ctx.fillRect(-30, -15, 60, 30);
                    ctx.fillStyle = secColor; ctx.fillRect(-35, -18, 15, 36); // Spoiler
                    ctx.fillStyle = '#000'; ctx.fillRect(10, -10, 15, 20); // Luna
                    break;
                case 'jade': // Gema tallada
                    ctx.fillStyle = color; ctx.beginPath();
                    ctx.moveTo(0, -30); ctx.lineTo(25, 0); ctx.lineTo(0, 30); ctx.lineTo(-25, 0); ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = secColor; ctx.lineWidth = 2; ctx.stroke();
                    break;
                case 'crimson': // Cuchilla de sangre
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(-40, 0); ctx.bezierCurveTo(20, -20, 40, 0, 20, 20); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'mist': // Nube compacta
                    ctx.fillStyle = color;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath(); ctx.arc(Math.cos(i) * 15, Math.sin(i) * 10, 15, 0, Math.PI * 2); ctx.fill();
                    }
                    break;
                case 'geometry': // Cubos superpuestos
                    ctx.fillStyle = color; ctx.fillRect(-20, -20, 30, 30);
                    ctx.fillStyle = secColor; ctx.save(); ctx.rotate(Math.PI / 4); ctx.fillRect(-15, -15, 30, 30); ctx.restore();
                    break;
                case 'oracle': // Ojo místico
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(0, 0, 30, 18, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = color; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = secColor; ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'sludge': // Masa informe
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(-30, 0); ctx.bezierCurveTo(-20, -30, 20, -30, 30, 0); ctx.bezierCurveTo(20, 30, -20, 30, -30, 0); ctx.fill();
                    ctx.fillStyle = secColor; ctx.beginPath(); ctx.arc(5, 5, 8, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'zenith': // Nave alada de luz
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(40, 0); ctx.lineTo(-20, -30); ctx.lineTo(-10, 0); ctx.lineTo(-20, 30); ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = secColor; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(-10, -15); ctx.lineTo(20, -15); ctx.moveTo(-10, 15); ctx.lineTo(20, 15); ctx.stroke();
                    break;
                case 'valkyrie': // Escudo con alas
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(35, 0); ctx.lineTo(-10, -35); ctx.lineTo(-10, 35); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(-15, 0, 15, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'neutron': // Esfera de alta densidad
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = secColor; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI * 2); ctx.stroke();
                    break;
                case 'currency_voltbit':
                    const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                    glow.addColorStop(0, '#fff');
                    glow.addColorStop(0.5, '#00e5ff');
                    glow.addColorStop(1, 'transparent');
                    ctx.fillStyle = glow;
                    ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill();

                    ctx.fillStyle = '#00e5ff';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (Math.PI * 2 / 6) * i;
                        ctx.lineTo(Math.cos(a) * 10, Math.sin(a) * 10);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
                    // Rayo central
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(0, -6); ctx.lineTo(-3, 1); ctx.lineTo(1, 1); ctx.lineTo(-1, 6); ctx.lineTo(3, -1); ctx.lineTo(-1, -1);
                    ctx.closePath(); ctx.fill();
                    break;
                case 'scarab': // Escarabajo blindado egipcio
                    // Cuerpo (Caparazón)
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.ellipse(-5, 0, 35, 25, 0, 0, Math.PI * 2); ctx.fill();
                    // División del caparazón
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-40, 0); ctx.lineTo(15, 0); ctx.stroke();
                    // Cuernos/Pinzas frontales
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.moveTo(10, -10); ctx.quadraticCurveTo(45, -25, 40, 0); ctx.quadraticCurveTo(45, 25, 10, 10); ctx.lineTo(10, -10); ctx.fill();
                    // Patas laterales
                    ctx.strokeStyle = color; ctx.lineWidth = 4;
                    for (let i = 0; i < 3; i++) {
                        const yOff = -20 + i * 20;
                        ctx.beginPath(); ctx.moveTo(-10, yOff); ctx.lineTo(-25, yOff * 1.5); ctx.stroke();
                    }
                    break;
                case 'phantom': // Nave traslúcida
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(30, 0); ctx.lineTo(-30, -15); ctx.lineTo(-30, 15); ctx.closePath(); ctx.fill();
                    ctx.globalAlpha = 1;
                    break;
                case 'ion': // Núcleo con satélites
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill();
                    for (let i = 0; i < 3; i++) {
                        const a = Date.now() / 200 + i * Math.PI * 2 / 3;
                        ctx.fillStyle = secColor;
                        ctx.beginPath(); ctx.arc(Math.cos(a) * 25, Math.sin(a) * 25, 5, 0, Math.PI * 2); ctx.fill();
                    }
                    break;
                case 'pulsar': // Estrella pulsante
                    const pulseS = 0.8 + Math.sin(Date.now() / 100) * 0.2;
                    ctx.scale(pulseS, pulseS);
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'mecha': // Caminante pesado
                    ctx.fillStyle = color;
                    ctx.fillRect(-20, -20, 40, 40);
                    ctx.fillStyle = secColor;
                    ctx.fillRect(10, -25, 10, 50);
                    break;
                case 'glitch': // Cubos desencajados
                    ctx.fillStyle = color;
                    const rOff = Math.sin(Date.now() / 50) * 10;
                    ctx.fillRect(-20 + rOff, -20, 20, 20);
                    ctx.fillStyle = secColor;
                    ctx.fillRect(0, 0 + rOff, 20, 20);
                    break;
                case 'seraph': // Alas de cristal múltiples
                    ctx.fillStyle = color;
                    for (let i = 0; i < 3; i++) {
                        ctx.save(); ctx.rotate(i * 0.5);
                        ctx.beginPath(); ctx.ellipse(-10, 0, 40, 8, 0, 0, Math.PI * 2); ctx.fill();
                        ctx.restore();
                    }
                    break;
                case 'raider': // Nave oxidada punta de flecha
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(40, 0); ctx.lineTo(-20, -20); ctx.lineTo(-10, 0); ctx.lineTo(-20, 20); ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = secColor; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(10, 0); ctx.stroke();
                    break;
                case 'monarch': // Mariposa majestuosa
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.ellipse(-10, -20, 25, 15, -0.5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(-10, 20, 25, 15, 0.5, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.ellipse(10, 0, 20, 8, 0, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'juggernaut': // Pared móvil
                    ctx.fillStyle = color;
                    ctx.fillRect(-15, -40, 30, 80);
                    ctx.fillStyle = secColor;
                    ctx.fillRect(-20, -10, 40, 20);
                    break;
                case 'spirit': // Flama flotante
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(30, 0); ctx.quadraticCurveTo(0, -30, -30, 0); ctx.quadraticCurveTo(0, 30, 30, 0); ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'echo': // Nave satélite radar
                    ctx.strokeStyle = color; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.arc(0, 0, 20, -1, 1); ctx.stroke();
                    ctx.beginPath(); ctx.arc(-10, 0, 30, -0.8, 0.8); ctx.stroke();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(10, 0, 10, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'cyber': // Chip integrado
                    ctx.fillStyle = color;
                    ctx.fillRect(-25, -25, 50, 50);
                    ctx.fillStyle = secColor;
                    for (let i = 0; i < 4; i++) {
                        ctx.fillRect(-35 + (i * 10), -35, 5, 10);
                    }
                    break;
                case 'vortex': // Molino de viento aerodinámico
                    ctx.fillStyle = color;
                    for (let i = 0; i < 3; i++) {
                        ctx.save(); ctx.rotate((Math.PI * 2 / 3) * i + Date.now() / 200);
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(20, -10, 30, 0); ctx.quadraticCurveTo(20, 10, 0, 0); ctx.fill();
                        ctx.restore();
                    }
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'reaper': // Cuchilla curva sombría
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(-30, 0); ctx.bezierCurveTo(-10, -40, 40, -10, 30, 0); ctx.bezierCurveTo(40, 10, -10, 40, -30, 0); ctx.fill();
                    ctx.strokeStyle = secColor; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(0, 20); ctx.stroke();
                    break;
                case 'cobra': // Nave cobra estilizada con capucha
                    // Cuerpo principal
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(-10, -5); ctx.quadraticCurveTo(30, -5, 40, 0); ctx.quadraticCurveTo(30, 5, -10, 5); ctx.fill();
                    // Capucha de cobra
                    const flare = 15 + Math.sin(Date.now() / 200) * 3;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(10, -5); ctx.quadraticCurveTo(0, -flare, -25, -5); ctx.lineTo(-25, 5); ctx.quadraticCurveTo(0, flare, 10, 5); ctx.closePath(); ctx.fill();
                    // Detalles de la capucha
                    ctx.strokeStyle = secColor; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(0, -flare + 5); ctx.lineTo(0, flare - 5); ctx.stroke();
                    // Ojos brillantes
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath(); ctx.arc(35, -3, 2, 0, Math.PI * 2); ctx.arc(35, 3, 2, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'rust': // Nave de chatarra pesada y oxidada
                    ctx.fillStyle = color;
                    ctx.fillRect(-30, -20, 50, 40);
                    ctx.fillStyle = '#5d4037'; // Tonos óxido extra
                    ctx.fillRect(-35, -25, 15, 15);
                    ctx.fillRect(-35, 10, 15, 15);
                    ctx.strokeStyle = secColor; ctx.lineWidth = 3;
                    ctx.strokeRect(-25, -15, 40, 30);
                    // Tubos de escape
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-45, -10, 15, 5); ctx.fillRect(-45, 5, 15, 5);
                    if (isTurbo) {
                        ctx.fillStyle = '#ff5722';
                        ctx.beginPath(); ctx.moveTo(-45, -10); ctx.lineTo(-65, -15); ctx.lineTo(-60, -7); ctx.fill();
                    }
                    break;
                case 'dust': // Nave todoterreno de dunas
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(35, 0); ctx.lineTo(-20, -22); ctx.lineTo(-10, 0); ctx.lineTo(-20, 22); ctx.closePath(); ctx.fill();
                    // Ruedas/Orugas laterales
                    ctx.fillStyle = '#3e2723';
                    ctx.fillRect(-15, -25, 30, 8); ctx.fillRect(-15, 17, 30, 8);
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.ellipse(5, 0, 15, 8, 0, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'blade': // Puñal de plata
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(40, 0); ctx.lineTo(-20, -12); ctx.lineTo(-10, 0); ctx.lineTo(-20, 12); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.fillRect(-30, -5, 15, 10);
                    break;
                case 'pulse': // Voxel ship bit
                    ctx.fillStyle = color;
                    ctx.fillRect(-20, -20, 40, 40);
                    ctx.fillStyle = secColor;
                    ctx.fillRect(-10, -10, 20, 20);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                    ctx.strokeRect(-15, -15, 30, 30);
                    break;
                case 'witch': // Sombrero mágico de combate
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(-25, 10); ctx.lineTo(25, 10); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(0, 10, 35, 10, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, -10, 5, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'omega': // Platillo avanzado
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.ellipse(0, 0, 35, 20, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, -5, 15, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath(); ctx.arc(Math.cos(i * Math.PI / 2) * 20, 10, 3, 0, Math.PI * 2); ctx.stroke();
                    }
                    break;
                case 'aether': // Entidad de energía abstracta
                    ctx.globalAlpha = 0.7;
                    const gradA = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                    gradA.addColorStop(0, '#fff'); gradA.addColorStop(1, color);
                    ctx.fillStyle = gradA;
                    for (let i = 0; i < 8; i++) {
                        ctx.save(); ctx.rotate(i * Math.PI / 4 + Date.now() / 500);
                        ctx.beginPath(); ctx.ellipse(15, 0, 20, 5, 0, 0, Math.PI * 2); ctx.fill();
                        ctx.restore();
                    }
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'elemental_aqua': { // Núcleo acuático + burbujas y aura líquida
                    const t = Date.now() / 280;
                    const g = ctx.createRadialGradient(0, 0, 2, 0, 0, 42);
                    g.addColorStop(0, 'rgba(255,255,255,0.95)');
                    g.addColorStop(0.45, 'rgba(32,208,255,0.65)');
                    g.addColorStop(1, 'rgba(32,208,255,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI * 2); ctx.fill();

                    ctx.strokeStyle = 'rgba(190,245,255,0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, 24 + Math.sin(t) * 2.2, 0, Math.PI * 2); ctx.stroke();

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(20, 0);
                    ctx.quadraticCurveTo(0, -30, -18, 0);
                    ctx.quadraticCurveTo(0, 28, 20, 0);
                    ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.ellipse(3, -3, 7, 12, 0.2, 0, Math.PI * 2); ctx.fill();

                    ctx.fillStyle = 'rgba(220,255,255,0.8)';
                    for (let i = 0; i < 3; i++) {
                        const a = t + i * 2.1;
                        ctx.beginPath(); ctx.arc(Math.cos(a) * (18 + i * 4), Math.sin(a) * (14 + i * 3), 2 + i * 0.8, 0, Math.PI * 2); ctx.fill();
                    }
                    break;
                }
                case 'elemental_pyre': { // Corazón ígneo con corona de llamas
                    const t = Date.now() / 230;
                    const g = ctx.createRadialGradient(0, 0, 3, 0, 0, 44);
                    g.addColorStop(0, 'rgba(255,245,210,0.95)');
                    g.addColorStop(0.35, 'rgba(255,120,40,0.8)');
                    g.addColorStop(1, 'rgba(255,70,30,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.fill();

                    for (let i = 0; i < 6; i++) {
                        ctx.save();
                        ctx.rotate((Math.PI * 2 / 6) * i + Math.sin(t + i) * 0.08);
                        ctx.fillStyle = i % 2 === 0 ? '#ff7a2f' : '#ffd180';
                        ctx.beginPath();
                        ctx.moveTo(8, 0);
                        ctx.quadraticCurveTo(24, -6, 30, 0);
                        ctx.quadraticCurveTo(24, 6, 8, 0);
                        ctx.fill();
                        ctx.restore();
                    }

                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(18, 0); ctx.lineTo(0, -18); ctx.lineTo(-12, 0); ctx.lineTo(0, 18); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI * 2); ctx.fill();
                    break;
                }
                case 'elemental_gale': { // Hélices de viento translúcidas
                    const t = Date.now() / 260;
                    ctx.strokeStyle = 'rgba(225,248,255,0.8)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        ctx.arc(0, 0, 18 + i * 8, t + i * 0.8, t + i * 0.8 + Math.PI * 1.3);
                        ctx.stroke();
                    }

                    for (let i = 0; i < 3; i++) {
                        ctx.save();
                        ctx.rotate((Math.PI * 2 / 3) * i + t * 0.7);
                        ctx.fillStyle = i === 0 ? color : secColor;
                        ctx.globalAlpha = 0.75;
                        ctx.beginPath();
                        ctx.moveTo(6, 0);
                        ctx.quadraticCurveTo(22, -8, 30, 0);
                        ctx.quadraticCurveTo(22, 8, 6, 0);
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#f6fdff';
                    ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI * 2); ctx.fill();
                    break;
                }
                case 'elemental_terra': { // Núcleo pétreo con fragmentos orbitales
                    const t = Date.now() / 300;
                    ctx.fillStyle = 'rgba(120,86,54,0.35)';
                    ctx.beginPath(); ctx.arc(0, 0, 36, 0, Math.PI * 2); ctx.fill();

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (Math.PI * 2 / 6) * i;
                        ctx.lineTo(Math.cos(a) * 20, Math.sin(a) * 20);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = secColor; ctx.lineWidth = 2; ctx.stroke();

                    ctx.fillStyle = secColor;
                    for (let i = 0; i < 4; i++) {
                        const a = t + i * (Math.PI / 2);
                        const ox = Math.cos(a) * (24 + (i % 2) * 4);
                        const oy = Math.sin(a) * (18 + ((i + 1) % 2) * 5);
                        ctx.save();
                        ctx.translate(ox, oy);
                        ctx.rotate(a);
                        ctx.fillRect(-4, -4, 8, 8);
                        ctx.restore();
                    }
                    break;
                }
                case 'elemental_plasma': { // Plasma con arco eléctrico y halo reactivo
                    const t = Date.now() / 180;
                    const pulse = 0.65 + (Math.sin(t * 1.2) + 1) * 0.2;
                    const g = ctx.createRadialGradient(0, 0, 2, 0, 0, 44);
                    g.addColorStop(0, 'rgba(255,255,255,0.9)');
                    g.addColorStop(0.35, 'rgba(255,234,0,0.75)');
                    g.addColorStop(0.65, 'rgba(255,79,242,0.5)');
                    g.addColorStop(1, 'rgba(255,79,242,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(0, 0, 38 * pulse, 0, Math.PI * 2); ctx.fill();

                    ctx.strokeStyle = '#ffe95c';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath(); ctx.arc(0, 0, 24 + Math.sin(t) * 3, 0, Math.PI * 2); ctx.stroke();

                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(12, -4); ctx.lineTo(2, -4); ctx.lineTo(16, 16); ctx.lineTo(-10, 2); ctx.lineTo(0, 2); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = secColor;
                    ctx.fillRect(-6, -6, 12, 12);
                    break;
                }
                case 'elemental_crystal': { // Prisma facetado con destellos
                    const t = Date.now() / 260;
                    ctx.strokeStyle = 'rgba(185,250,255,0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, 25 + Math.sin(t) * 2.5, 0, Math.PI * 2); ctx.stroke();

                    const rg = ctx.createLinearGradient(-20, -20, 20, 20);
                    rg.addColorStop(0, color);
                    rg.addColorStop(1, secColor);
                    ctx.fillStyle = rg;
                    ctx.beginPath();
                    ctx.moveTo(0, -24); ctx.lineTo(18, -6); ctx.lineTo(10, 20); ctx.lineTo(-10, 20); ctx.lineTo(-18, -6);
                    ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = '#e8ffff'; ctx.lineWidth = 1.5; ctx.stroke();

                    ctx.strokeStyle = '#f7ffff';
                    for (let i = 0; i < 3; i++) {
                        const a = t + i * 2.2;
                        const px = Math.cos(a) * 30;
                        const py = Math.sin(a) * 18;
                        ctx.beginPath(); ctx.moveTo(px - 3, py); ctx.lineTo(px + 3, py); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(px, py - 3); ctx.lineTo(px, py + 3); ctx.stroke();
                    }
                    break;
                }
                case 'elemental_thunder': { // Rayo central con anillo tormenta
                    const t = Date.now() / 170;
                    ctx.strokeStyle = 'rgba(255,233,92,0.9)';
                    ctx.lineWidth = 2.2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 22 + Math.sin(t) * 2, t * 0.6, t * 0.6 + Math.PI * 1.7);
                    ctx.stroke();

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(-3, -20); ctx.lineTo(10, -6); ctx.lineTo(1, -6); ctx.lineTo(12, 16); ctx.lineTo(-8, 2); ctx.lineTo(0, 2);
                    ctx.closePath(); ctx.fill();

                    ctx.fillStyle = secColor;
                    for (let i = 0; i < 4; i++) {
                        const a = t + i * (Math.PI / 2);
                        ctx.beginPath(); ctx.arc(Math.cos(a) * 26, Math.sin(a) * 14, 2.2, 0, Math.PI * 2); ctx.fill();
                    }
                    break;
                }
                default: // Modelo genérico aerodinámico
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(30, 0); ctx.quadraticCurveTo(-10, -25, -30, -15); ctx.lineTo(-30, 15); ctx.quadraticCurveTo(-10, 25, 30, 0);
                    ctx.fill();
            }

            ctx.restore();
        }

        function drawCharacterAvatar(id, char) {
            const container = document.getElementById(`avatar-${id}`);
            if (!container) return;

            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            container.appendChild(canvas);

            const ctx = canvas.getContext('2d');

            // Fondo circular con gradiente
            const gradient = ctx.createRadialGradient(50, 50, 0, 50, 50, 50);
            gradient.addColorStop(0, char.secondaryColor + '44');
            gradient.addColorStop(1, char.color + '22');

            ctx.beginPath();
            ctx.arc(50, 50, 48, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = char.color;
            ctx.lineWidth = 1;
            ctx.stroke();

            // Dibujar el modelo real de la nave
            renderRacerModel(ctx, id, 50, 50, 1.2, char);

            // Efecto de aura para míticos/legendarios
            if (char.rarity === 'mythic' || char.rarity === 'legendary') {
                ctx.shadowColor = char.color;
                ctx.shadowBlur = 20;
                ctx.strokeStyle = char.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(50, 50, 45, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function renderAbilityIcon(ctx, type, color, size = 60) {
            // Eliminar clearRect para evitar borrar fondo de Attack Log
            ctx.save();
            ctx.translate(size / 2, size / 2);
            const s = size / 60; // Scale factor

            ctx.shadowBlur = 10 * s;
            ctx.shadowColor = color;

            switch (type) {
                case 'blaze_fireball':
                    const gBlaze = ctx.createRadialGradient(0, 0, 0, 0, 0, 25 * s);
                    gBlaze.addColorStop(0, '#fff'); gBlaze.addColorStop(0.3, '#ff9800'); gBlaze.addColorStop(1, 'transparent');
                    ctx.fillStyle = gBlaze;
                    ctx.beginPath(); ctx.arc(0, 0, 20 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = 3 * s;
                    ctx.beginPath(); ctx.moveTo(20 * s, 0); ctx.lineTo(-10 * s, -15 * s); ctx.lineTo(-10 * s, 15 * s); ctx.closePath(); ctx.stroke();
                    break;
                case 'blaze_mine':
                    ctx.fillStyle = '#ff5722';
                    ctx.beginPath(); ctx.arc(0, 0, 22 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2 * s; ctx.stroke();
                    ctx.fillStyle = '#ffeb3b';
                    for (let i = 0; i < 4; i++) {
                        ctx.save(); ctx.rotate(i * Math.PI / 2);
                        ctx.fillRect(15 * s, -2 * s, 10 * s, 4 * s);
                        ctx.restore();
                    }
                    break;
                case 'dust_blind':
                case 'dust_storm':
                    ctx.fillStyle = '#a1887f';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        ctx.arc(Math.cos(i) * 15 * s, Math.sin(i) * 10 * s, 10 * s, 0, Math.PI * 2);
                    }
                    ctx.fill();
                    break;
                case 'dust_cyclone':
                    ctx.strokeStyle = '#d7ccc8'; ctx.lineWidth = 3 * s;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath(); ctx.arc(0, 0, (10 + i * 5) * s, Date.now() / 100 + i, Date.now() / 100 + i + 2); ctx.stroke();
                    }
                    break;
                case 'rust_traps':
                    ctx.fillStyle = '#795548';
                    ctx.beginPath(); ctx.moveTo(-15 * s, 0); ctx.lineTo(15 * s, 0); ctx.lineTo(0, 20 * s); ctx.closePath(); ctx.fill();
                    break;
                case 'sand_trap':
                    ctx.fillStyle = '#dcb35c';
                    ctx.beginPath(); ctx.ellipse(0, 0, 25 * s, 15 * s, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#a67c00';
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath(); ctx.arc((Math.random() - 0.5) * 30 * s, (Math.random() - 0.5) * 20 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
                    }
                    break;
                case 'burn':
                case 'fire_trail':
                case 'heat_pulse':
                    const g1 = ctx.createRadialGradient(0, 0, 5 * s, 0, 0, 20 * s);
                    g1.addColorStop(0, '#fff'); g1.addColorStop(0.5, '#ffeb3b'); g1.addColorStop(1, '#ff5722');
                    ctx.fillStyle = g1;
                    ctx.beginPath(); ctx.arc(0, 0, 18 * s, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'freeze':
                case 'ice_dash':
                    ctx.fillStyle = '#00d4ff';
                    ctx.beginPath();
                    ctx.moveTo(15 * s, 0); ctx.lineTo(-10 * s, -12 * s); ctx.lineTo(-10 * s, 12 * s);
                    ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2 * s; ctx.stroke();
                    break;
                case 'storm_cloud':
                case 'triple_storm':
                case 'storm_hit':
                case 'storm_seeker': // Optimized name
                    ctx.fillStyle = '#444'; // Darker cloud
                    ctx.beginPath();
                    ctx.arc(-12 * s, 0, 15 * s, 0, Math.PI * 2);
                    ctx.arc(12 * s, 0, 15 * s, 0, Math.PI * 2);
                    ctx.arc(0, -12 * s, 15 * s, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 3 * s; // Electric cyan
                    ctx.beginPath(); ctx.moveTo(0, -5 * s); ctx.lineTo(-8 * s, 12 * s); ctx.lineTo(8 * s, 5 * s); ctx.lineTo(0, 20 * s); ctx.stroke();
                    break;
                case 'chain_lightning':
                case 'electric_dash':
                    ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = 4 * s;
                    ctx.beginPath(); ctx.moveTo(-15 * s, -15 * s); ctx.lineTo(0, 0); ctx.lineTo(-5 * s, 5 * s); ctx.lineTo(15 * s, 15 * s); ctx.stroke();
                    break;
                case 'faint':
                case 'rock_path':
                case 'rock_collision':
                    ctx.fillStyle = '#8d6e63';
                    ctx.beginPath();
                    ctx.moveTo(-15 * s, 10 * s); ctx.lineTo(0, -15 * s); ctx.lineTo(15 * s, 10 * s);
                    ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.arc(0, 0, 5 * s, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'blind':
                case 'teleport':
                case 'clone_hit':
                    ctx.fillStyle = '#6a1b9a';
                    ctx.beginPath(); ctx.arc(0, 0, 15 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.setLineDash([2, 2]); ctx.stroke();
                    break;
                case 'black_hole_shot':
                case 'void_trap':
                case 'warp_drive':
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(0, 0, 18 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#e040fb'; ctx.lineWidth = 3 * s; ctx.stroke();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1 * s; ctx.beginPath(); ctx.arc(0, 0, 12 * s, 0, Math.PI * 2); ctx.stroke();
                    break;
                case 'progressive_bubble':
                case 'water_tornado':
                case 'tsunami_trap':
                case '🌊':
                    ctx.fillStyle = 'rgba(0, 188, 212, 0.5)';
                    ctx.beginPath(); ctx.arc(0, 0, 18 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2 * s; ctx.stroke();
                    break;
                case 'toxin_drain':
                case 'acid_trap':
                case 'venom_trail':
                    ctx.fillStyle = '#4caf50';
                    ctx.beginPath(); ctx.ellipse(0, 0, 20 * s, 10 * s, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-5 * s, -2 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'nova_burst':
                case 'star_sink':
                case 'warp_jump':
                    const g2 = ctx.createRadialGradient(0, 0, 2 * s, 0, 0, 18 * s);
                    g2.addColorStop(0, '#fff'); g2.addColorStop(1, '#ffc107');
                    ctx.fillStyle = g2;
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const a = (Math.PI * 2 / 8) * i;
                        const r = i % 2 === 0 ? 18 * s : 8 * s;
                        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath(); ctx.fill();
                    break;
                case 'titan_lunge':
                case 'bull_charge':
                case 'repulsion_aura':
                    ctx.fillStyle = '#795548';
                    ctx.beginPath(); ctx.roundRect(-15 * s, -15 * s, 30 * s, 30 * s, 5 * s); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.stroke();
                    break;
                case 'shield':
                    ctx.strokeStyle = '#00f7ff'; ctx.lineWidth = 4 * s;
                    ctx.beginPath(); ctx.arc(0, 0, 18 * s, 0.2, Math.PI - 0.2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(0, 0, 18 * s, Math.PI + 0.2, -0.2); ctx.stroke();
                    break;
                case 'knockback':
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 3 * s;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath(); ctx.arc(0, 0, (10 + i * 10) * s, -0.5, 0.5); ctx.stroke();
                    }
                    break;
                case 'slip':
                    ctx.strokeStyle = '#4dd0e1'; ctx.lineWidth = 2 * s;
                    ctx.beginPath(); ctx.moveTo(-20 * s, 0); ctx.bezierCurveTo(-10 * s, -20 * s, 10 * s, 20 * s, 20 * s, 0); ctx.stroke();
                    break;
                default:
                    // Genérico Turbo
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(-15 * s, -10 * s); ctx.lineTo(15 * s, 0); ctx.lineTo(-15 * s, 10 * s); ctx.fill();
            }

            ctx.restore();
        }

        function selectCharacter(id) {
            GameData.selectedCharacter = id;
            saveGame();
            renderCharacters();
        }

        function tryUnlockCharacter(id) {
            const char = CHARACTERS[id];
            if (GameData.voltBits >= char.price) {
                startOceanPayTransaction(char.price, `Desbloqueo de ${char.name}`, () => {
                    GameData.voltBits -= char.price;
                    GameData.unlockedCharacters.push(id);
                    saveGame();
                    updateVoltBitsDisplay();
                    renderCharacters();
                    showNotification(`¡${char.name} DESBLOQUEADO!`);
                });
            } else {
                alert('¡Faltan VoltBits!');
            }
        }

        // ==================== LÓGICA DE CARRERA ====================
        class Racer {
            constructor(name, lane, isPlayer, characterId) {
                this.name = name;
                this.lane = lane;
                this.isPlayer = isPlayer;
                this.characterId = characterId;
                this.character = CHARACTERS[characterId];
                this.level = GameData.characterLevels[characterId] || 1;
                this.x = 100;
                this.y = 0;
                this.speed = 0;

                // Apply Level Bonuses (1% per level)
                const levelBonus = 1 + (this.level - 1) * 0.02;
                const stats = this.character.stats || { speed: 5, accel: 5, handling: 5, weight: 5 };

                this.baseSpeed = (isPlayer ? 4.5 : 3.8 + Math.random() * 0.4) * levelBonus;
                this.maxSpeed = (4.5 + (stats.speed / 5)) * levelBonus;
                this.accelRate = (stats.accel / 10) * levelBonus;

                this.progress = 0;
                this.item = null;
                this.effects = [];
                this.turboActive = false;
                this.shieldActive = false;
                this.finished = false;
                this.eliminated = false;
                this.finalPosition = null;
                this.trapEmissionTimer = 0;
                this.rockArmorActive = false;
                this.electrifiedTimer = 0;
                this.rockDebuffTimer = 0;
                this.rockExplosionTimer = 0;
                this.repulsionAuraTimer = 0;
                this.lungeTimer = 0;
                this.bubbleEffectTimer = 0;
                this.tornadoContactTimer = 0;
                this.laneChangeTimer = Math.random() * 2;
                this.warpTimer = 0;
                this.starSinkTimer = 0;
                this.intangibleTimer = 0;
                this.toxinTimer = 0;
                this.knockbackForce = 0;
                this.isInvulnerable = false;
                this.vSpeed = 0;
                this.trail = [];

                // Item Leveling (Calculated from racer level)
                this.turboLevel = Math.floor((this.level + 1) / 3) + (this.level >= 2 ? 1 : 0);
                if (this.level < 2) this.turboLevel = 1; else if (this.level < 5) this.turboLevel = 2; else this.turboLevel = 3;

                this.projectileLevel = (this.level >= 6) ? 3 : (this.level >= 3 ? 2 : 1);
                this.trapLevel = (this.level >= 7) ? 3 : (this.level >= 4 ? 2 : 1);

                // If level is 7, enable Reset-to-Start chance on hits
                // FIX: Ensure this doesn't trigger on self-inflicted traps or too easily
                this.hasResetSkill = (this.level === 7);
                this.stormSurgeTime = 0;
                this.neutronOrbitTimer = 0;
                this.neutronAmmo = 0;
            }

            update(dt) {
                // Actualizar estela
                this.trail.unshift({ x: this.x, y: this.y, alpha: 1 });
                if (this.trail.length > 15) this.trail.pop();
                this.trail.forEach(t => t.alpha -= 0.05);

                // Efectos activos
                let speedMod = 1;
                const stats = this.character.stats || { speed: 5, accel: 5, handling: 5, weight: 5 };
                // Buff de Estela de Hoja
                if (this.leafTurboTimer > 0) {
                    this.leafTurboTimer -= dt;
                    speedMod *= 1.4;
                }

                // Trampa Enredadera (Leaf) & Proyectil Hit Logic
                if (this.vinesTimer > 0) {
                    this.vinesTimer -= dt;
                    // Slow effect during vines
                    speedMod *= 0.5;
                    if (this.vinesTimer <= 0) {
                        // Final damage after slow ends
                        this.progress -= 300;
                        particles.emit(this.x, this.y, 25, '#4caf50', 6);
                        addHitToLog(null, this, 'vines_snap');
                    }
                }

                if (this.tornadoTimer > 0) {
                    this.tornadoTimer -= dt;
                    speedMod = 0;
                    this.vSpeed = 0;
                    this.y += Math.sin(Date.now() / 50) * 5; // Sacudida tornado
                    if (this.tornadoTimer <= 0) {
                        this.progress -= 150; // Daño final ligero
                    }
                }

                // Cloud Path Turbo Logic (Mist)
                if (this.cloudPathTimer > 0) {
                    this.cloudPathTimer -= dt;
                    // Leave particles
                    if (Math.random() > 0.5) particles.emit(this.x - 30, this.y, 2, '#cfd8dc', 1);
                    // Slow others passing through (simple range check for "path")
                    [gameState.player, ...gameState.bots].forEach(r => {
                        if (r !== this && r.lane === this.lane && Math.abs(r.x - this.x) < 200) {
                            r.speed *= 0.8; // Slowed by cloud path
                        }
                    });
                }

                // Actualizar item activo del jugador
                if (this.isPlayer && this.itemActiveTimer > 0) {
                    this.itemActiveTimer -= dt;
                    if (this.itemActiveTimer <= 0) {
                        this.activeItemType = null;
                        updateItemDisplay(); // Limpiar display
                    }
                }

                this.effects = this.effects.filter(e => {
                    e.duration -= dt;
                    if (e.type === 'freeze') speedMod = 0;
                    if (e.type === 'slow') speedMod *= 0.5;
                    if (e.type === 'stun') speedMod = 0;
                    return e.duration > 0;
                });

                // Turbo
                if (this.turboActive) {
                    speedMod *= this.character.turbo.boost;
                    // Partículas de nitro
                    if (Math.random() > 0.5) particles.emit(this.x - 20, this.y, 5, this.character.color, 2);
                }

                // Aplicar aceleración basada en stats
                const targetBase = this.isPlayer ? 4.5 + (stats.speed / 5) : 3.8 + (stats.speed / 6) + Math.random() * 0.4;
                const accelRate = (stats.accel / 10) * dt;

                if (this.speed < targetBase) this.speed += accelRate;
                else this.speed = targetBase;

                // Aplicar Knockback (Fisica realista influenciada por Weight)
                if (this.knockbackForce > 0) {
                    const weightFactor = Math.min(1.5, stats.weight / 5);
                    const weightPenalty = Math.max(0.3, 1 - (stats.weight / 15));
                    this.progress -= this.knockbackForce * dt * 60 * weightPenalty;

                    // Recuperación: Los pesados (como Rust) se estabilizan más rápido
                    const recovery = 0.90 - (stats.weight / 150);
                    this.knockbackForce *= Math.max(0.7, recovery);

                    if (this.knockbackForce < 1) this.knockbackForce = 0;
                }

                this.vSpeed = this.speed * speedMod;
                this.progress += this.vSpeed * dt * 60;

                // Verificar colisión con Hazards del mapa (Mejorado: Basado en Carril y Señalizado)
                const map = MAPS[GameData.selectedMap];
                if (map.hazards && !this.isInvulnerable && !this.finished) {
                    const hazardCycle = (Date.now() / 1500) % 2; // Ciclo más lento
                    // Solo activar en carriles específicos (alternando)
                    const targetLane = Math.floor((Date.now() / 3000) % LANE_COUNT);

                    if (hazardCycle > 1.4 && Math.abs((this.progress % 1200) - 600) < 60 && this.lane === targetLane) {
                        this.knockbackForce = 25;
                        this.effects.push({ type: 'stun', duration: 0.8 });
                        if (this.isPlayer) {
                            gameState.cameraShake = 25;
                            gameState.hitFlash = 0.6;
                            showNotification("⚠ ¡PELIGRO EN CARRIL! ⚠");
                        }
                    }
                }

                if (this.finished) {
                    this.speed = 0;
                    return;
                }

                // Efectos de estado (Mejorado)
                if (this.electrifiedTimer > 0) this.electrifiedTimer -= dt;
                if (this.rockDebuffTimer > 0) {
                    this.rockDebuffTimer -= dt;
                    speedMod *= 0.65; // Ralentización por rocas
                    if (this.rockDebuffTimer <= 0) {
                        this.rockExplosionTimer = 0.5; // Breve delay antes de daño masivo
                        this.progress -= 500; // Daño masivo
                        particles.emit(this.x, this.y, 30, '#8d6e63', 6);
                    }
                }
                if (this.rockExplosionTimer > 0) this.rockExplosionTimer -= dt;

                // Titan Aura
                if (this.repulsionAuraTimer > 0) this.repulsionAuraTimer -= dt;

                // Titan Lunge (Mini-turbo)
                if (this.lungeTimer > 0) {
                    this.lungeTimer -= dt;
                    speedMod *= 2.5;
                }

                // Aqua Progressive Bubble
                if (this.bubbleEffectTimer > 0) {
                    this.bubbleEffectTimer -= dt;
                    const elapsed = 5 - this.bubbleEffectTimer;
                    if (elapsed < 3) {
                        speedMod *= (1 - (elapsed / 3) * 0.4); // Descenso hasta el 60%
                    } else {
                        speedMod *= 0.3; // Últimos 2s va muy lento
                    }
                }

                // Phoenix Fire Trail during turbo
                if (this.turboActive && this.characterId === 'phoenix' && Math.random() > 0.85) {
                    const trap = new Trap(this.x - 40, this.lane, 'slow', 'burn', '#ff5722', 2, this);
                    trap.lifetime = 1.5;
                    gameState.traps.push(trap);
                }

                // Venom Toxic Trail during turbo
                if (this.turboActive && this.characterId === 'venom' && Math.random() > 0.8) {
                    const trap = new Trap(this.x - 40, this.lane, 'acid_hit', 'acid_trap', '#4caf50', 3, this);
                    trap.lifetime = 2.0;
                    gameState.traps.push(trap);
                }

                // Toxin Drain Effect
                if (this.toxinTimer > 0) {
                    this.toxinTimer -= dt;
                    this.progress -= 80 * dt; // Drenaje constante
                    if (Math.random() > 0.7) particles.emit(this.x, this.y, 2, '#4caf50', 1);
                }

                // Mist: Tornado Trap Stuck State
                if (this.tornadoStuckTimer > 0) {
                    this.tornadoStuckTimer -= dt;
                    speedMod = 0;
                    this.vSpeed = 0;
                    this.y += Math.sin(Date.now() / 30) * 3; // Shake inside tornado

                    // Infect others touching me
                    [gameState.player, ...gameState.bots].forEach(other => {
                        if (other !== this && !other.tornadoStuckTimer && Math.abs(other.x - this.x) < 50 && other.lane === this.lane) {
                            other.tornadoStuckTimer = this.tornadoStuckTimer; // Share remaining duration
                        }
                    });

                    if (this.tornadoStuckTimer <= 0) {
                        // Final light damage
                        this.progress -= 150;
                        particles.emit(this.x, this.y, 20, '#90a4ae', 4);
                    }
                }

                // Storm Turbo Logic: Electrocute passed opponents (700ms)
                if (this.stormSurgeTime > 0) {
                    this.stormSurgeTime -= dt;
                    const racers = [gameState.player, ...gameState.bots];
                    racers.forEach(r => {
                        if (r !== this && Math.abs(r.progress - this.progress) < 150 && !r.stormStunned) {
                            // Apply brief electrocution
                            r.effects.push({ type: 'stun', duration: 0.7 });
                            r.stormStunned = true; // Prevent spam
                            setTimeout(() => r.stormStunned = false, 2000);
                            particles.emit(r.x, r.y, 10, '#1e88e5', 5);
                        }
                    });
                }

                // Resonance: Discharge delayed damage
                if (this.dischargeTimer > 0) {
                    this.dischargeTimer -= dt;
                    if (this.dischargeTimer <= 0) {
                        // Massive damage discharge
                        this.progress -= 600;
                        this.effects.push({ type: 'stun', duration: 0.5 });
                        particles.emit(this.x, this.y, 40, '#d1c4e9', 10);
                        addHitToLog(this, this, 'discharge_burst'); // Self-inflicted if no target? Or just a general effect.
                    }
                }

                // Neutron Turbo Collision Logic
                if (this.turboActive && this.character.turbo.effect === 'neutron_propulsion') {
                    const racers = [gameState.player, ...gameState.bots];
                    racers.forEach(r => {
                        if (r !== this && Math.abs(r.progress - this.progress) < 100 && r.lane === this.lane) {
                            // Light damage
                            if (!r.neutronHit) {
                                r.progress -= 150;
                                addHitToLog(this, r, 'neutron_bump');
                                r.neutronHit = true;
                                setTimeout(() => r.neutronHit = false, 1000);
                                particles.emit(r.x, r.y, 10, '#64ffda', 3);
                            }
                        }
                    });
                }

                // Neutron Orbit Logic
                if (this.neutronOrbitTimer > 0) {
                    this.neutronOrbitTimer -= dt;
                    if (this.neutronOrbitTimer <= 0) {
                        this.neutronAmmo = 0; // Expired
                    }
                }

                // AI Lane Movement
                if (!this.isPlayer && !this.finished && !this.effects.some(e => e.type === 'stun' || e.type === 'freeze')) {
                    this.laneChangeTimer -= dt;
                    if (this.laneChangeTimer <= 0) {
                        this.laneChangeTimer = 1.5 + Math.random() * 2;

                        // Evaluar carril actual vs otros
                        const hasObstacle = gameState.traps.some(t => t.lane === this.lane && t.x > this.x && t.x < this.x + 500);
                        const hasProjAhead = gameState.projectiles.some(p => p.lane === this.lane && p.x > this.x && p.x < this.x + 300);

                        const seesDanger = hasObstacle || hasProjAhead;
                        const dodgeChance = 0.45;

                        // Solo intentar cambiar si detecta peligro (45% de éxito) o por aburrimiento (10%)
                        if ((seesDanger && Math.random() < dodgeChance) || Math.random() > 0.9) {
                            let possibleLanes = [];
                            if (this.lane > 0) possibleLanes.push(this.lane - 1);
                            if (this.lane < LANE_COUNT - 1) possibleLanes.push(this.lane + 1);

                            if (possibleLanes.length > 0) {
                                // Seleccionar carril con menos obstáculos
                                possibleLanes.sort((a, b) => {
                                    const obsA = gameState.traps.filter(t => t.lane === a && t.x > this.x && t.x < this.x + 400).length;
                                    const obsB = gameState.traps.filter(t => t.lane === b && t.x > this.x && t.x < this.x + 400).length;
                                    return obsA - obsB;
                                });
                                this.lane = possibleLanes[0];
                            }
                        }
                    }
                }

                // Emisión de trampa continua (Terra)
                if (this.trapEmissionTimer > 0) {
                    this.trapEmissionTimer -= dt;
                    if (Math.random() > 0.6) {
                        const t = new Trap(this.x, this.lane, 'slow', '🪨', '#8d6e63', 3, this);
                        t.lifetime = 2; // El camino dura poco
                        gameState.traps.push(t);
                    }
                }

                // Emisión de partículas según movimiento
                if (speedMod > 1) {
                    particles.emitSpeed(this.x - 20, this.y, this.character.color);
                    particles.emitSpeed(this.x - 20, this.y + 10, '#ffffff');
                } else if (speedMod < 1) {
                    particles.emit(this.x, this.y, 1, '#888888', 1);
                }
            }

            useItem() {
                if (!this.item) return;

                const char = this.character;

                if (this.item.type === 'turbo') {
                    this.turboActive = true;
                    if (this.isPlayer) updateMissionProgress('use_turbo');

                    // Buff based on turbo level
                    const levelBuff = 1 + (this.turboLevel - 1) * 0.15;
                    this.activeTurboBoost = (char.turbo.boost || 1.8) * levelBuff;

                    if (char.turbo.effect === 'intangible') this.intangibleTimer = 2.0 * levelBuff;
                    if (char.turbo.effect === 'storm_surge') {
                        this.stormSurgeTime = 2.0 * levelBuff; // Enable electrocution logic in update
                        this.isInvulnerable = true;
                    }
                    if (char.turbo.effect === 'cloud_path') {
                        // Mist Turbo: Trails slow others
                        this.cloudPathTimer = 3.0;
                    }
                    if (char.turbo.effect === 'sonic_overload') {
                        // Resonance Turbo: Lighting zap on cross
                        // Logic implemented in checkCollision or Update loop?
                        // Let's do instant zap on range for anyone close during turbo
                        [gameState.player, ...gameState.bots].forEach(r => {
                            if (r !== this && Math.abs(r.progress - this.progress) < 200) {
                                // Zap!
                                r.effects.push({ type: 'stun', duration: 0.5 });
                                particles.emit(r.x, r.y, 10, '#d1c4e9', 5);
                            }
                        });
                    }
                    if (char.turbo.effect === 'dust_cyclone') {
                        // Empujar a todos los cercanos
                        [gameState.player, ...gameState.bots].forEach(r => {
                            if (r !== this && Math.abs(r.progress - this.progress) < 300) {
                                r.knockbackForce = 15;
                                r.lane = Math.floor(Math.random() * LANE_COUNT);
                            }
                        });
                    }
                    if (char.turbo.effect === 'bone_shield') {
                        this.isInvulnerable = true; // Bone shield makes invulnerable
                    }
                    if (char.turbo.effect === 'leaf_dash') {
                        this.leafTurboTimer = 3.0; // Leaf dash gives speed buff
                    }

                    setTimeout(() => {
                        this.turboActive = false;
                        this.isInvulnerable = false;
                        this.activeTurboBoost = 0;
                    }, 2000 * (1 + (this.turboLevel - 1) * 0.1));
                } else if (this.item.type === 'shield') {
                    this.shieldActive = true;
                    setTimeout(() => this.shieldActive = false, 5000);
                } else if (this.item.type === 'projectile') {
                    if (char.projectile.effect === 'bone_swing') {
                        // Bone Swing: Checks for target in front
                        const allSorted = [gameState.player, ...gameState.bots].sort((a, b) => b.progress - a.progress);
                        let target = allSorted.find(r => r !== this && r.lane === this.lane && r.progress > this.progress && r.progress < this.progress + 300);

                        const proj = new Projectile(this.x + 80, this.lane, 1, this, 'bone_swing', 'bone', '#8d6e63');
                        proj.speed = 0; // It's a melee swing attached to racer relatively
                        proj.lifetime = 0.5;
                        gameState.projectiles.push(proj);
                        if (target) {
                            // Massive damage, annoying at level 7
                            const dmg = (this.level >= 7) ? 800 : 500;
                            target.progress -= dmg;
                            target.effects.push({ type: 'stun', duration: 1.0 });
                            addHitToLog(this, target, 'bone_swing');
                            particles.emit(target.x, target.y, 30, '#d7ccc8', 5);
                        }
                    } else if (char.projectile.effect === 'leaf_trail') {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, 'leaf_trail', 'leaf', '#4caf50');
                        proj.speed = 18;
                        gameState.projectiles.push(proj);
                    } else if (char.projectile.effect === 'mist_trail') {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, 'mist_trail', 'cloud', '#90a4ae');
                        proj.speed = 16;
                        gameState.projectiles.push(proj);
                    } else if (char.projectile.effect === 'electric_beam_charge') {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, 'electric_beam', 'resonance', '#d1c4e9');
                        proj.isCharging = true;
                        proj.chargeTimer = 1.5;
                        gameState.projectiles.push(proj);
                    } else if (char.projectile.effect === 'storm_seeker_new') {
                        // Storm: Storm Seeker New
                        // "Lanzara un rayo a quien no reaccione en los 1.5s" - Warnings
                        // Logic: Spawn projectile on victim's lane. If they are still there in 1.5s, Zap.
                        const allSorted = [gameState.player, ...gameState.bots].sort((a, b) => b.progress - a.progress);
                        let target = allSorted.find(r => r !== this && r.progress > this.progress); // Ahead
                        if (!target && allSorted.length > 1) {
                            // If first, attack second
                            const myIdx = allSorted.indexOf(this);
                            target = allSorted[myIdx === 0 ? 1 : 0];
                        }
                        if (target) {
                            const proj = new Projectile(target.progress, target.lane, 1, this, 'storm_seeker_warning', 'storm_seeker', '#1e88e5', target);
                            proj.speed = 0; // Stick to lane/position?
                            // Wait, if it sticks to lane but no X?
                            // "A quien no reaccione". Usually avoiding the lane.
                            // So projectile stays at RELATIVE position?
                            // Let's attach it to the target initially but lock to LANE/X.
                            proj.targetLane = target.lane;
                            proj.targetX = target.x; // Lock position on track
                            proj.warningTimer = 1.5;
                            gameState.projectiles.push(proj);
                            showNotification(`⚠ ¡TORMENTA SOBRE CARRIL ${target.lane + 1}!`);
                        }
                    } else if (char.projectile.effect === 'titan_lunge') {
                        this.lungeTimer = 0.5;
                    } else if (char.projectile.effect === 'progressive_bubble') {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, 'progressive_bubble', 'progressive_bubble', '#00bcd4');
                        proj.speed = 25;
                        gameState.projectiles.push(proj);
                    } else if (char.projectile.effect === 'fire_fan') {
                        for (let i = 0; i < 3; i++) {
                            let targetLane = this.lane + (i - 1);
                            if (targetLane >= 0 && targetLane < LANE_COUNT) {
                                const proj = new Projectile(this.x + 50, targetLane, 1, this, 'burn', 'burn', '#ff9800');
                                gameState.projectiles.push(proj);
                            }
                        }
                    } else if (char.projectile.effect === 'toxin_drain') {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, 'toxin_hit', 'toxin_drain', '#4caf50');
                        proj.speed = 22;
                        gameState.projectiles.push(proj);
                    } else if (char.projectile.effect === 'nova_burst') {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, 'nova_hit', 'nova_burst', '#ffeb3b');
                        proj.speed = 20;
                        gameState.projectiles.push(proj);
                    } else if (char.projectile.effect === 'nova_burst') {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, 'nova_hit', 'nova_burst', '#ffeb3b');
                        proj.speed = 20;
                        gameState.projectiles.push(proj);
                    } else if (char.projectile.effect === 'neutron_blast') {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, 'neutron_blast', 'neutron', '#64ffda');
                        proj.speed = 25; // Fast
                        gameState.projectiles.push(proj);
                    } else if (char.projectile.effect === 'shadow_kunai') {
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                const proj = new Projectile(this.x + 50, this.lane, 1, this, 'kunai_hit', 'kunai_hit', '#212121');
                                proj.speed = 30;
                                gameState.projectiles.push(proj);
                            }, i * 100);
                        }
                    } else {
                        const proj = new Projectile(this.x + 50, this.lane, 1, this, char.projectile.effect, 'generic_proj', char.color);
                        gameState.projectiles.push(proj);
                    }
                } else if (this.item.type === 'trap') {
                    if (char.trap.effect === 'bone_pile_target') {
                        // Bone Pile: Spawns on 1st place if not you, else 2nd. Or next rank up.
                        // Logic: "sobre el que este primero si no lo estas, el que tenga el puesto siguiente a ti... o al segundo si estas primero"

                        // Sort racers by progress
                        const sorted = [gameState.player, ...gameState.bots].sort((a, b) => b.progress - a.progress);
                        const myRank = sorted.indexOf(this);
                        let target = null;

                        if (myRank === 0) {
                            // I am first, attack second
                            if (sorted.length > 1) target = sorted[1];
                        } else {
                            target = sorted[myRank - 1]; // Attack the one ahead
                        }

                        if (target) {
                            const t = new Trap(target.x, target.lane, 'bone_pile', '☠️', '#8d6e63', 3, this);
                            gameState.traps.push(t);
                            showNotification(`¡Huesos enviados a ${target.name}!`);
                        }
                    } else if (char.trap.effect === 'vines_trap') {
                        const t = new Trap(this.x - 100, this.lane, 'vines_trap', '🌿', '#4caf50', 4, this);
                        gameState.traps.push(t);
                    } else if (char.trap.effect === 'tornado_trap_mine') {
                        const t = new Trap(this.x, this.lane, 'tornado_trap_mine', '🌪️', '#90a4ae', 3.5, this);
                        gameState.traps.push(t);
                    } else if (char.trap.effect === 'neutron_orbit') {
                        // Neutron Trap: Orbit State
                        this.neutronOrbitTimer = 5.0;
                        this.neutronAmmo = 3;
                        showNotification("⚛️ ORBITA NEUTRÓNICA ACTIVA (E PARA DISPARAR)");
                    } else if (char.trap.effect === 'storm_block') {
                        // Storm Block: Spawns in front of 1st or 2nd (user rank dependent)
                        const sorted = [gameState.player, ...gameState.bots].sort((a, b) => b.progress - a.progress);
                        const myRank = sorted.indexOf(this);
                        let target = null;
                        if (myRank === 0) target = sorted[1];
                        else target = sorted[0];

                        // "Aparece enfrente"
                        if (target) {
                            const t = new Trap(target.progress + 600, target.lane, 'storm_block', '⛈️', '#1e88e5', 2.0, this);
                            gameState.traps.push(t);
                        }
                    } else if (char.trap.effect === 'electric_mines_triple') {
                        // 3 mines spread
                        [-1, 0, 1].forEach(offset => {
                            const lane = Math.min(LANE_COUNT - 1, Math.max(0, this.lane + offset));
                            const t = new Trap(this.x + (Math.random() * 50 - 25), lane, 'electric_mines_triple', '⚡', '#d1c4e9', 3, this);
                            gameState.traps.push(t);
                        });
                    } else if (char.trap.effect === 'rock_path') {
                        this.trapEmissionTimer = char.trap.duration;
                    } else if (char.trap.effect === 'repulsion_aura') {
                        this.repulsionAuraTimer = char.trap.duration;
                    } else if (char.trap.effect === 'tsunami_trap') {
                        const tsunami = new Tsunami(this.x + 100, this.lane, this);
                        gameState.tsunamis.push(tsunami);
                    } else if (char.trap.effect === 'ash_trap') {
                        const trap = new Trap(this.x - 50, this.lane, 'ash_hit', 'ash_trap', '#ff5722', 2.5, this);
                        gameState.traps.push(trap);
                    } else if (char.trap.effect === 'star_sink') {
                        const trap = new Trap(this.x - 50, this.lane, 'sink_hit', 'star_sink', '#ffc107', 1.5, this);
                        gameState.traps.push(trap);
                    } else if (char.trap.effect === 'shadow_clone') {
                        const trap = new Trap(this.x - 30, this.lane, 'clone_hit', 'clone_hit', '#212121', 3.0, this);
                        gameState.traps.push(trap);
                    } else if (char.trap.effect === 'triple_storm') {
                        for (let l = 0; l < LANE_COUNT; l++) {
                            if (l === this.lane) continue;
                            const trap = new Trap(this.x + 400 + Math.random() * 200, l, 'storm_hit', 'storm_hit', '#ffeb3b', 1);
                            gameState.traps.push(trap);
                        }
                    } else if (char.trap.effect === 'acid_trap') {
                        const trap = new Trap(this.x - 40, this.lane, 'acid_hit', 'acid_trap', '#4caf50', 4.0, this);
                        gameState.traps.push(trap);
                    } else {
                        const trap = new Trap(this.x - 50, this.lane, char.trap.effect, 'generic_trap', char.color, char.trap.duration);
                        gameState.traps.push(trap);
                    }
                }

                if (this.isPlayer) {
                    this.activeItemType = this.item.type;
                    this.itemMaxDuration = 2.0; // Default
                    if (this.item.type === 'turbo') this.itemMaxDuration = 2.0 * (1 + (this.turboLevel - 1) * 0.1);
                    this.itemActiveTimer = this.itemMaxDuration;
                }
                this.item = null;
                updateItemDisplay();
            }

            emitShockwave(damage) {
                const allRacers = [gameState.player, ...gameState.bots];
                allRacers.forEach(r => {
                    if (r !== this && Math.abs(r.x - this.x) < 200 && r.lane === this.lane) {
                        r.progress -= damage;
                        particles.emit(r.x, r.y, 10, '#8d6e63', 3);
                    }
                });
            }

            draw(ctx, cameraX) {
                const screenX = this.x - cameraX + canvas.width * 0.3;
                const laneHeight = canvas.height / (LANE_COUNT + 1);
                this.y = laneHeight * (this.lane + 1);

                ctx.save();

                // Efectos de estado
                if (this.effects.some(e => e.type === 'freeze')) {
                    ctx.filter = 'hue-rotate(180deg) brightness(1.5)';
                } else if (this.effects.some(e => e.type === 'slow')) {
                    ctx.filter = 'grayscale(0.5) contrast(0.8)';
                }

                // Shadow Intangibility Visual
                if (this.intangibleTimer > 0) {
                    ctx.globalAlpha = 0.4;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#fff';
                }

                // Sombra dinámica
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.ellipse(screenX - 5, this.y + 35, 30, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Aura de poder para rarezas altas
                const char = this.character;

                // DIBUJAR ESTELA (Trail)
                ctx.save();
                this.trail.forEach((t, i) => {
                    const tx = t.x - cameraX + canvas.width * 0.3;
                    ctx.globalAlpha = t.alpha * 0.3;
                    ctx.fillStyle = char.color;
                    ctx.beginPath();
                    ctx.arc(tx, t.y, 10 - i * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();

                if (this.turboActive || ['legendary', 'mythic'].includes(char.rarity)) {
                    ctx.shadowColor = char.color;
                    ctx.shadowBlur = this.turboActive ? 60 : 30;

                    if (char.rarity === 'legendary') {
                        const pulse = 0.5 + Math.sin(Date.now() / 300) * 0.5;
                        ctx.strokeStyle = char.color;
                        ctx.save();
                        ctx.globalAlpha = pulse * 0.4;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(screenX, this.y, 42 + pulse * 5, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }

                    if (char.rarity === 'mythic') {
                        const time = Date.now() / 250;
                        ctx.save();
                        ctx.strokeStyle = char.secondaryColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2 + time;
                            const r = 48 + Math.sin(time * 1.5) * 6;
                            const lx = screenX + Math.cos(angle) * r;
                            const ly = this.y + Math.sin(angle) * r;
                            if (i === 0) ctx.moveTo(lx, ly);
                            else ctx.lineTo(lx, ly);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                // DIBUJAR MODELO ÚNICO DE NAVE
                renderRacerModel(ctx, this.characterId, screenX, this.y, 1, char, this.turboActive);

                // --- TIMER OVERLAY (NUEVO) ---
                this.drawTimers(ctx, screenX, this.y);

                // Titan Aura Visual
                if (this.repulsionAuraTimer > 0) {
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#fff';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screenX, this.y, 50, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Titan Bull Charge Effect
                if (this.turboActive && (this.characterId === 'titan' || this.characterId === 'juggernaut')) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(screenX + 30, this.y - 15);
                    ctx.lineTo(screenX + 90, this.y);
                    ctx.lineTo(screenX + 30, this.y + 15);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Aqua Bubble Visual
                if (this.bubbleEffectTimer > 0) {
                    ctx.strokeStyle = '#fff';
                    ctx.fillStyle = 'rgba(0, 188, 212, 0.3)';
                    ctx.beginPath();
                    ctx.arc(screenX, this.y, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }

                // Aqua Tornado Visual
                if (this.turboActive && this.characterId === 'aqua') {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00bcd4';
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    for (let i = 0; i < 3; i++) {
                        const ox = Math.sin(Date.now() / 100 + i) * 20;
                        ctx.beginPath();
                        ctx.ellipse(screenX + ox, this.y, 10 + i * 10, 30, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                }

                // Propulsores traseros
                if (this.turboActive) {
                    const heatGrad = ctx.createRadialGradient(screenX - 35, this.y, 0, screenX - 35, this.y, 20);
                    heatGrad.addColorStop(0, '#fff');
                    heatGrad.addColorStop(0.5, char.color);
                    heatGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = heatGrad;
                    ctx.beginPath();
                    ctx.arc(screenX - 35, this.y, 20, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Escudo
                if (this.shieldActive) {
                    ctx.shadowBlur = 0;
                    const shieldGrad = ctx.createRadialGradient(screenX, this.y, 25, screenX, this.y, 45);
                    shieldGrad.addColorStop(0, 'transparent');
                    shieldGrad.addColorStop(0.8, 'rgba(0, 247, 255, 0.2)');
                    shieldGrad.addColorStop(1, 'rgba(0, 247, 255, 0.5)');
                    ctx.fillStyle = shieldGrad;
                    ctx.beginPath();
                    ctx.arc(screenX, this.y, 45, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Neutron Orbits
                if (this.neutronOrbitTimer > 0 && this.neutronAmmo > 0) {
                    const radius = 60;
                    ctx.save();
                    ctx.translate(screenX, this.y);
                    for (let i = 0; i < this.neutronAmmo; i++) {
                        const angle = (Date.now() / 300) + (i * (Math.PI * 2 / 3));
                        const nx = Math.cos(angle) * radius;
                        const ny = Math.sin(angle) * radius;

                        ctx.fillStyle = '#64ffda';
                        ctx.shadowBlur = 10; ctx.shadowColor = '#18ffff';
                        ctx.beginPath(); ctx.arc(nx, ny, 8, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.restore();
                }

                ctx.restore();

                // HUD sobre el personaje
                ctx.fillStyle = this.isPlayer ? '#00e5ff' : '#fff';
                ctx.font = '900 14px Orbitron';
                ctx.textAlign = 'center';
                const displayName = this.isPlayer ? '>> YOU <<' : this.name;
                ctx.fillText(displayName, screenX, this.y - 45);
            }

            drawTimers(ctx, x, y) {
                const timers = [];
                if (this.turboActive && this.itemActiveTimer > 0) timers.push({ color: '#00e5ff', cur: this.itemActiveTimer, max: this.itemMaxDuration, label: 'TURBO' });
                if (this.electrifiedTimer > 0) timers.push({ color: '#ffeb3b', cur: this.electrifiedTimer, max: 1.0, label: '⚡' });
                if (this.rockDebuffTimer > 0) timers.push({ color: '#8d6e63', cur: this.rockDebuffTimer, max: 4.0, label: '🪨' });
                if (this.vinesTimer > 0) timers.push({ color: '#4caf50', cur: this.vinesTimer, max: 1.5, label: '🌿' });
                if (this.tornadoTimer > 0) timers.push({ color: '#cfd8dc', cur: this.tornadoTimer, max: 2.0, label: '🌪️' });
                if (this.bubbleEffectTimer > 0) timers.push({ color: '#00bcd4', cur: this.bubbleEffectTimer, max: 5.0, label: '🫧' });
                if (this.intangibleTimer > 0) timers.push({ color: '#e040fb', cur: this.intangibleTimer, max: 2.0, label: '👻' });
                if (this.neutronOrbitTimer > 0) timers.push({ color: '#64ffda', cur: this.neutronOrbitTimer, max: 5.0, label: '⚛️' });

                if (timers.length === 0) return;

                const startY = y - 70;
                timers.forEach((t, i) => {
                    const ty = startY - i * 12;
                    const width = 40;
                    const pct = Math.max(0, t.cur / t.max);

                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(x - width / 2, ty, width, 6);
                    ctx.fillStyle = t.color;
                    ctx.fillRect(x - width / 2, ty, width * pct, 6);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                    ctx.strokeRect(x - width / 2, ty, width, 6);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 8px Rajdhani';
                    ctx.textAlign = 'right';
                    ctx.fillText(t.label, x - width / 2 - 5, ty + 6);
                });
            }
        }

        // Clase para manejar partículas
        class Particle {
            constructor(x, y, vx, vy, color, life, size) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = size;
                this.active = true;
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.life -= dt;
                if (this.life <= 0) this.active = false;
            }

            draw(ctx, cameraX) {
                const screenX = this.x - cameraX + canvas.width * 0.3;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                const opacity = this.life / this.maxLife;
                ctx.fillStyle = this.color.replace(')', `, ${opacity})`).replace('rgb', 'rgba');
                if (!this.color.includes('rgb')) ctx.fillStyle = this.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');

                ctx.beginPath();
                ctx.arc(screenX, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            emit(x, y, count, color, speed = 2) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const v = Math.random() * speed;
                    this.particles.push(new Particle(
                        x, y,
                        Math.cos(angle) * v,
                        Math.sin(angle) * v,
                        color,
                        0.5 + Math.random() * 0.5,
                        1 + Math.random() * 3
                    ));
                }
            }

            emitSpeed(x, y, color) {
                this.particles.push(new Particle(
                    x, y,
                    -10 - Math.random() * 10,
                    (Math.random() - 0.5) * 2,
                    color,
                    0.3,
                    1 + Math.random() * 2
                ));
            }

            update(dt) {
                this.particles = this.particles.filter(p => {
                    p.update(dt);
                    return p.active;
                });
            }

            draw(ctx, cameraX) {
                this.particles.forEach(p => p.draw(ctx, cameraX));
            }
        }

        const particles = new ParticleSystem();

        class ItemBox {
            constructor(x, lane) {
                this.x = x;
                this.lane = lane;
                this.collected = false;
                this.respawnTime = 0;
            }

            draw(ctx, cameraX) {
                if (this.collected) return;

                // Check if Glitch Map (or Event Active)
                const isGlitchMap = GameData.selectedMap === 'glitch_void' || activeEvent === 'glitch';

                const screenX = this.x - cameraX + canvas.width * 0.3;
                const laneHeight = canvas.height / (LANE_COUNT + 1);
                const y = laneHeight * (this.lane + 1);

                // Cubo flotante
                const bounce = Math.sin(Date.now() / 200) * 5;

                ctx.save();
                ctx.translate(screenX, y + bounce);
                ctx.rotate(Date.now() / 1000);

                if (isGlitchMap) {
                    // CAJA GLITCH
                    // Color base negro
                    ctx.fillStyle = '#000';
                    ctx.strokeStyle = '#00ff41'; // Matrix Green
                    ctx.lineWidth = 3;

                    // Jitter
                    if (Math.random() < 0.2) {
                        ctx.translate((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
                    }

                    // Cubo
                    ctx.fillRect(-16, -16, 32, 32);
                    ctx.strokeRect(-16, -16, 32, 32);

                    // Caracteres Matrix internos
                    ctx.fillStyle = '#0f0';
                    ctx.font = 'bold 16px "Courier New", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const char = String.fromCharCode(0x30A0 + Math.random() * 96); // Katakana random
                    ctx.fillText(char, 0, 0);

                } else {
                    // CAJA NORMAL
                    ctx.fillStyle = '#ffd700';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;

                    // Cubo
                    ctx.fillRect(-15, -15, 30, 30);
                    ctx.strokeRect(-15, -15, 30, 30);

                    // Signo de interrogación
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('?', 0, 0);
                }

                ctx.restore();
            }

            update(dt) {
                if (this.collected) {
                    this.respawnTime -= dt;
                    if (this.respawnTime <= 0) {
                        this.collected = false;
                    }
                }
            }

            checkCollision(racer, cameraX) {
                if (this.collected) return false;

                const laneHeight = canvas.height / (LANE_COUNT + 1);
                const boxY = laneHeight * (this.lane + 1);
                const racerY = laneHeight * (racer.lane + 1);

                const dx = Math.abs(racer.x - this.x);
                const dy = Math.abs(racerY - boxY);

                return dx < 40 && dy < 40;
            }
        }

        // Clase para proyectiles
        class Projectile {
            constructor(x, lane, direction, owner, effect, icon, color, targetRacer = null) {
                this.x = x;
                this.lane = lane;
                this.direction = direction; // 1 = adelante, -1 = atrás
                this.speed = 15;
                this.owner = owner;
                this.effect = effect;
                this.icon = icon;
                this.color = color;
                this.active = true;
                this.trail = [];
                if (effect === 'storm_seeker') {
                    this.timer = 2;
                    this.targetRacer = targetRacer;
                }
            }

            update(dt) {
                if (this.effect === 'storm_seeker') {
                    this.timer -= dt;
                    if (this.timer > 0) {
                        // Sigue agresivamente al objetivo
                        this.x = this.targetRacer.x;
                        this.lane = this.targetRacer.lane;
                    } else if (this.active) {
                        this.active = false;
                        particles.emit(this.x, canvas.height / (LANE_COUNT + 1) * (this.lane + 1), 40, '#00e5ff', 8);
                        // El rayo SIEMPRE golpea si el timer llega a cero, es un "seeker"
                        this.applyEffect(this.targetRacer);
                    }
                } else {
                    this.x += this.speed * this.direction * dt * 60;
                }

                // Trail effect
                this.trail.unshift({ x: this.x, alpha: 1 });
                if (this.trail.length > 10) this.trail.pop();
                this.trail.forEach(t => t.alpha -= 0.1);

                // Leaf Trail specific Update logic: Buff owner, Slow enemies
                if (this.effect === 'leaf_trail') {
                    // Check for cars behind in same lane
                    const racers = [gameState.player, ...gameState.bots];
                    racers.forEach(r => {
                        if (r.lane === this.lane) {
                            if (r === this.owner && Math.abs(r.x - this.x) < 100) {
                                // Owner near trail: Mini turbo
                                r.speed += 0.2;
                            } else if (r !== this.owner && r.x < this.x && r.x > this.x - 300) {
                                // Enemy behind trail: Slow
                                r.speed *= 0.98;
                            }
                        }
                    });
                }

                // Mist Trail specific Update logic
                if (this.effect === 'mist_trail') {
                    const racers = [gameState.player, ...gameState.bots];
                    racers.forEach(r => {
                        if (r !== this.owner && r.lane === this.lane && r.x < this.x && r.x > this.x - 400) {
                            // Enemies behind in trail get slowed
                            r.speed *= 0.95;
                        }
                    });
                }

                // Resonance Electric Charge Logic
                if (this.effect === 'electric_beam_charge' && this.isCharging) {
                    this.chargeTimer -= dt;
                    // Stick to owner
                    this.x = this.owner.x + 80;
                    this.y = this.owner.y; // approximate y
                    this.lane = this.owner.lane;

                    if (this.chargeTimer <= 0) {
                        this.isCharging = false;
                        this.speed = 40; // Fast shot
                        // Final flash
                        particles.emit(this.x, this.y * (this.lane + 1), 50, '#d1c4e9', 10);
                        gameState.hitFlash = 1.0;
                        // Beam travels instantly or super fast? Let's make it a fast projectile now
                    }
                }
                if (this.effect === 'storm_seeker_warning') {
                    this.warningTimer -= dt;
                    // Check if target racer is still in lane
                    // "A quien no reaccione" -> If you stay in the lane, you get hit.
                    // The projectile is locked to a lane.

                    if (this.warningTimer <= 0) {
                        this.active = false;
                        // Hit everyone in that lane section
                        const victims = [gameState.player, ...gameState.bots].filter(r =>
                            r.lane === this.lane && Math.abs(r.progress - this.x) < 200 // Assuming this.x was progress
                        );
                        // Actually, wait. new Projectile(x, ...) x is progress or screenX?
                        // In the creation I used 'target.progress' which is WORLD COORDINATE.
                        // So this.x is World Coordinate.
                        // 'r.progress' matches.

                        victims.forEach(v => {
                            v.effects.push({ type: 'stun', duration: 1.5 });
                            v.progress -= 400;
                            addHitToLog(this.owner, v, 'storm_strike');
                        });
                        particles.emit(this.x, 0, 100, '#ffeb3b', 10); // Visuals needs to be screen coords
                        // But 'emit' likely takes screen coords if drawing. 
                        // It seems particles.emit(r.x, r.y...) uses World/Screen mix? 
                        // Let's assume standard behavior. Warning visuals handled in draw.
                    }
                }
            }

            draw(ctx, cameraX) {
                if (!this.active && this.effect !== 'storm_seeker') return; // Seeker legacy check
                if (this.effect === 'storm_seeker' && this.timer <= 0) return;

                const screenX = this.x - cameraX + canvas.width * 0.3;
                if (screenX < -100 || screenX > canvas.width + 100) return; // Optimization

                const laneHeight = canvas.height / (LANE_COUNT + 1);
                const y = laneHeight * (this.lane + 1);

                if (this.effect === 'storm_seeker_warning') {
                    // Warning indicator
                    ctx.save();
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 50) * 0.5; // Blinking
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(screenX - 100, y - 20, 200, 40);
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 20px Orbitron';
                    ctx.fillText("¡CUIDADO!", screenX - 40, y - 30);
                    ctx.restore();
                    return;
                }

                if (this.effect === 'storm_seeker') {
                    // Targeting Laser
                    ctx.save();
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00e5ff';
                    ctx.strokeStyle = `rgba(0, 229, 255, ${Math.abs(Math.sin(Date.now() / 100))})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(screenX, y - 50);
                    ctx.lineTo(screenX, y);
                    ctx.stroke();
                    ctx.restore();

                    // Nube realista
                    ctx.save();
                    ctx.fillStyle = '#444';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#000';
                    ctx.beginPath();
                    ctx.arc(screenX, y - 50, 20, 0, Math.PI * 2);
                    ctx.arc(screenX - 15, y - 45, 15, 0, Math.PI * 2);
                    ctx.arc(screenX + 15, y - 45, 15, 0, Math.PI * 2);
                    ctx.fill();
                    // Barra de carga
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(screenX - 25, y - 90, 50, 5);
                    ctx.fillStyle = '#ffeb3b';
                    ctx.fillRect(screenX - 25, y - 90, 50 * (this.timer / 2), 5);
                    ctx.restore();
                    return;
                }

                // Main projectile drawing by effect
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;

                switch (this.effect) {
                    case 'leaf_trail':
                        // Estela con hoja y líneas orbitando
                        ctx.fillStyle = 'rgba(139, 195, 74, 0.3)';
                        ctx.fillRect(screenX - 100, y - 20, 100, 40);
                        // Líneas orbitando
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                        const orbit = Math.sin(Date.now() / 100) * 15;
                        ctx.beginPath(); ctx.moveTo(screenX - 20, y + orbit); ctx.lineTo(screenX + 20, y - orbit); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(screenX - 20, y - orbit); ctx.lineTo(screenX + 20, y + orbit); ctx.stroke();
                        // Hoja central
                        ctx.fillStyle = '#8bc34a';
                        ctx.beginPath(); ctx.ellipse(screenX, y, 15, 8, 0, 0, Math.PI * 2); ctx.fill();
                        // Mini turbo al dueño si está en el mismo carril
                        if (this.owner && this.owner.lane === this.lane && Math.abs(this.owner.x - this.x) < 50) {
                            this.owner.leafTurboTimer = 0.5;
                        }
                        break;
                    case 'mist_trail':
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath(); ctx.arc(screenX - (i * 15), y + Math.sin(Date.now() / 200 + i) * 10, 10 + i * 5, 0, Math.PI * 2); ctx.fill();
                        }
                        break;
                    case 'electric_beam':
                        if (this.isCharging) {
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                            ctx.beginPath(); ctx.moveTo(screenX, y); ctx.lineTo(screenX + 400, y); ctx.stroke();
                            // Indicador de carga
                            ctx.fillStyle = '#d1c4e9';
                            ctx.fillRect(screenX, y - 25, 100 * (1 - this.chargeTimer / 1.5), 5);
                        } else {
                            ctx.fillStyle = '#fff'; ctx.shadowBlur = 30; ctx.shadowColor = '#d1c4e9';
                            ctx.fillRect(screenX, y - 4, 80, 8);
                        }
                        break;
                    case 'bone_swing':
                        ctx.save(); ctx.translate(screenX, y); ctx.rotate(Date.now() / 100);
                        ctx.fillStyle = '#eee'; ctx.fillRect(-20, -5, 40, 10);
                        ctx.beginPath(); ctx.arc(-20, 0, 8, 0, Math.PI * 2); ctx.arc(20, 0, 8, 0, Math.PI * 2); ctx.fill();
                        ctx.restore();
                        break;
                    case 'burn':
                        const grad = ctx.createRadialGradient(screenX, y, 5, screenX, y, 15);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(0.4, '#ffeb3b'); grad.addColorStop(1, '#ff5722');
                        ctx.fillStyle = grad;
                        ctx.beginPath(); ctx.arc(screenX, y, 15, 0, Math.PI * 2); ctx.fill();
                        break;
                    case 'freeze':
                        ctx.fillStyle = '#00d4ff';
                        ctx.beginPath();
                        ctx.moveTo(screenX + 15, y); ctx.lineTo(screenX - 15, y - 5); ctx.lineTo(screenX - 15, y + 5);
                        ctx.closePath(); ctx.fill();
                        ctx.strokeStyle = '#fff'; ctx.stroke();
                        break;
                    case 'kunai_hit':
                        ctx.fillStyle = '#212121';
                        ctx.beginPath();
                        ctx.moveTo(screenX + 10, y); ctx.lineTo(screenX - 10, y - 3); ctx.lineTo(screenX - 10, y + 3);
                        ctx.closePath(); ctx.fill();
                        break;
                    case 'toxin_hit':
                        ctx.fillStyle = '#4caf50';
                        ctx.beginPath(); ctx.arc(screenX, y, 8, 0, Math.PI * 2); ctx.fill();
                        ctx.fillRect(screenX - 15, y - 2, 10, 4);
                        break;
                    case 'chain_lightning':
                        ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(screenX - 15, y + 10); ctx.lineTo(screenX, y); ctx.lineTo(screenX + 15, y - 10);
                        ctx.stroke();
                        break;
                    case 'bubble_shot':
                    case 'progressive_bubble':
                        ctx.fillStyle = 'rgba(0, 188, 212, 0.4)';
                        ctx.strokeStyle = '#fff';
                        ctx.beginPath(); ctx.arc(screenX, y, 15, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                        break;
                    default:
                        ctx.fillStyle = this.color;
                        ctx.beginPath(); ctx.arc(screenX, y, 12, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            }

            checkCollision(racer) {
                if (!this.active || racer === this.owner) return false;
                if (this.effect === 'storm_cloud') return false;
                if (racer.lane !== this.lane) return false;
                const dx = Math.abs(racer.x - this.x);
                return dx < 40;
            }

            applyEffect(racer) {
                if (racer.shieldActive || racer.isInvulnerable || racer.intangibleTimer > 0) {
                    if (racer.shieldActive) {
                        racer.shieldActive = false;
                        addHitToLog(this.owner, racer, 'shield');
                    }
                    if (this.effect !== 'neutron_blast') this.active = false; // Neutron Blast pierces
                    return;
                }

                addHitToLog(this.owner, racer, this.effect);
                if (racer.isPlayer) {
                    gameState.cameraShake = 8;
                    gameState.hitFlash = 0.3;
                }

                // Neutron Blast Piercing Logic
                if (this.effect === 'neutron_blast') {
                    // Don't set active=false.
                    // Add some visual feedback
                    particles.emit(racer.x, racer.y, 20, '#64ffda', 4);
                } else {
                    this.active = false;
                }

                switch (this.effect) {
                    case 'bone_swing':
                        racer.effects.push({ type: 'stun', duration: 1.5 });
                        racer.knockbackForce = 25;
                        break;
                    case 'leaf_trail':
                        racer.vinesTimer = 2.0;
                        racer.effects.push({ type: 'slow', duration: 2.0 });
                        break;
                    case 'mist_trail':
                        racer.effects.push({ type: 'slow', duration: 4.0 });
                        break;
                    case 'electric_beam':
                        racer.effects.push({ type: 'stun', duration: 1.0 });
                        racer.progress -= 500;
                        break;
                    case 'blaze_fireball':
                        racer.effects.push({ type: 'slow', duration: 4.5 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 12;
                        break;
                    case 'neutron_shot': // Neutral damage shot from orbit
                        racer.progress -= 250;
                        racer.knockbackForce = 5;
                        break;
                    case 'freeze':
                        racer.effects.push({ type: 'freeze', duration: 2.5 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 5;
                        break;
                    case 'burn':
                    case 'burn_strong':
                        racer.effects.push({ type: 'slow', duration: 3 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 8;
                        break;
                    case 'stun':
                        racer.effects.push({ type: 'stun', duration: 1.5 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 12;
                        break;
                    case 'knockback':
                        racer.knockbackForce = 15 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.3);
                        break;
                    case 'nova_hit':
                        const victims = [gameState.player, ...gameState.bots].filter(r =>
                            r !== this.owner && !r.isInvulnerable &&
                            Math.abs(r.x - racer.x) < (200 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.25)) &&
                            Math.abs(r.lane - racer.lane) <= 1
                        );
                        victims.forEach(v => {
                            v.effects.push({ type: 'stun', duration: 1.5 });
                            v.knockbackForce = 10;
                            addHitToLog(this.owner, v, 'nova_burst');
                        });
                        particles.emit(racer.x, racer.y, 40, '#ffeb3b', 8);
                        break;
                    case 'kunai_hit':
                        racer.progress -= 80 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.5);
                        racer.knockbackForce = 3;
                        racer.effects.push({ type: 'slow', duration: 0.5 });
                        break;
                    case 'toxin_hit':
                        racer.toxinTimer = 4.0 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.2);
                        racer.effects.push({ type: 'slow', duration: 2.0 });
                        racer.knockbackForce = 4;
                        break;
                    case 'chain_lightning':
                        racer.effects.push({ type: 'stun', duration: 1.2 });
                        removeRacerItem(racer);
                        racer.knockbackForce = 10;
                        break;
                    case 'dust_blind':
                        racer.effects.push({ type: 'slow', duration: 2.0 });
                        racer.effects.push({ type: 'blind', duration: 3.0 });
                        racer.knockbackForce = 5;
                        break;
                    case 'mist_trail_hit':
                        racer.effects.push({ type: 'slow', duration: 4.0 });
                        break;
                    case 'discharge_hit':
                        racer.dischargeTimer = 1.0; // 1s delay before burst
                        racer.effects.push({ type: 'stun', duration: 0.2 });
                        break;
                    case 'neutron_blast':
                        // Daño decente-masivo, recuperación rápida
                        racer.progress -= 550;
                        racer.effects.push({ type: 'stun', duration: 0.3 }); // Rápida recuperación
                        racer.knockbackForce = 15;
                        break;
                    default:
                        racer.effects.push({ type: 'slow', duration: 1.5 * (1 + (this.owner ? this.owner.projectileLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 6;
                }

                // Global Reset Skill (Level 7)
                if (this.owner && this.owner.hasResetSkill && Math.random() < 0.15) {
                    racer.progress = 0;
                    showNotification("🌀 ¡RESET TEMPORAL! 🌀");
                }

                this.active = false;
            }
        }

        function removeRacerItem(racer) {
            if (racer.isPlayer) {
                const types = ['projectile', 'turbo', 'trap'];
                const filled = types.filter(t => gameState.inventory[t]);
                if (filled.length > 0) {
                    const picked = filled[Math.floor(Math.random() * filled.length)];
                    gameState.inventory[picked] = null;
                    updateItemDisplay();
                }
            } else {
                racer.item = null;
            }
        }

        // Clase para trampas
        class Trap {
            constructor(x, lane, effect, icon, color, duration, owner = null) {
                this.x = x;
                this.lane = lane;
                this.effect = effect;
                this.icon = icon;
                this.color = color;
                this.duration = duration;
                this.owner = owner;
                this.active = true;
                this.lifetime = 15;
            }

            update(dt) {
                this.lifetime -= dt;
                if (this.lifetime <= 0) this.active = false;
            }

            draw(ctx, cameraX) {
                if (!this.active) return;
                const screenX = this.x - cameraX + canvas.width * 0.3;
                const laneHeight = canvas.height / (LANE_COUNT + 1);
                const y = laneHeight * (this.lane + 1);

                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;

                switch (this.effect) {
                    case 'bone_pile':
                        ctx.fillStyle = '#fff';
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath(); ctx.arc(screenX + (i - 2) * 8, y + 25 + Math.random() * 5, 6, 0, Math.PI * 2); ctx.fill();
                        }
                        break;
                    case 'vines_effect':
                        ctx.strokeStyle = '#33691e'; ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(screenX - 20, y + 20); ctx.quadraticCurveTo(screenX, y + 10, screenX + 20, y + 30);
                        ctx.stroke();
                        break;
                    case 'tornado_trigger':
                    case 'storm_block_visual':
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.beginPath();
                        ctx.ellipse(screenX, y + 20, 20, 10, 0, 0, Math.PI * 2); ctx.fill();
                        if (this.effect === 'storm_block_visual') {
                            // Lightning
                            if (Math.random() > 0.8) {
                                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                                ctx.beginPath(); ctx.moveTo(screenX, y - 40); ctx.lineTo(screenX, y + 20); ctx.stroke();
                            }
                        }
                        break;
                    case 'electric_mine_hit':
                    case 'electric_mines_triple':
                        ctx.fillStyle = '#d1c4e9';
                        ctx.beginPath(); ctx.arc(screenX, y + 20, 10, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = '#fff'; ctx.setLineDash([2, 1]); ctx.stroke();
                        break;
                    case 'heat_pulse':
                        const pulse = 1 + Math.sin(Date.now() / 100) * 0.2;
                        const grad = ctx.createRadialGradient(screenX, y + 20, 5, screenX, y + 20, 25 * pulse);
                        grad.addColorStop(0, '#ffeb3b'); grad.addColorStop(1, '#ff4500');
                        ctx.fillStyle = grad;
                        ctx.beginPath(); ctx.arc(screenX, y + 20, 25 * pulse, 0, Math.PI * 2); ctx.fill();
                        break;
                    case 'acid_hit':
                        ctx.fillStyle = 'rgba(76, 175, 80, 0.6)';
                        ctx.beginPath();
                        ctx.ellipse(screenX, y + 25, 40, 15, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#1b5e20';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath(); ctx.arc(screenX - 10 + i * 10, y + 25 + Math.sin(i) * 5, 4, 0, Math.PI * 2); ctx.fill();
                        }
                        break;
                    case 'void_trap':
                        ctx.fillStyle = '#e040fb';
                        ctx.beginPath(); ctx.arc(screenX, y + 20, 20, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = '#fff'; ctx.setLineDash([5, 2]); ctx.stroke();
                        break;
                    default:
                        ctx.fillStyle = this.color + '80';
                        ctx.beginPath(); ctx.arc(screenX, y + 20, 25, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = this.color; ctx.stroke();
                }
                ctx.restore();
            }

            checkCollision(racer) {
                if (!this.active || racer === this.owner) return false;

                // Bone Pile and Tornado Mines are lane specific but maybe visually larger
                if (this.effect === 'tornado_trap_mine' && racer.lane === this.lane && Math.abs(racer.x - this.x) < 50) return true;
                if (this.effect === 'bone_pile' && racer.lane === this.lane && Math.abs(racer.x - this.x) < 40) return true;
                if (racer.lane !== this.lane) return false;
                const dx = Math.abs(racer.x - this.x);
                return dx < 35;
            }

            applyEffect(racer) {
                if (racer.shieldActive || racer.isInvulnerable || racer.intangibleTimer > 0) {
                    if (racer.shieldActive) {
                        racer.shieldActive = false;
                        addHitToLog(this.owner, racer, 'shield');
                    }
                    this.active = false;
                    return;
                }

                addHitToLog(this.owner, racer, this.effect);
                if (racer.isPlayer) {
                    gameState.cameraShake = 10;
                    gameState.hitFlash = 0.4;
                }

                switch (this.effect) {
                    case 'dust_storm':
                        const victimsDust = [gameState.player, ...gameState.bots].filter(r =>
                            r !== this.owner && !r.isInvulnerable &&
                            Math.abs(r.x - racer.x) < 400 &&
                            Math.abs(r.lane - racer.lane) <= 2
                        );
                        victimsDust.forEach(v => {
                            v.effects.push({ type: 'slow', duration: 3.0 });
                            v.effects.push({ type: 'blind', duration: 2.0 });
                            v.knockbackForce = 10;
                        });
                        particles.emit(racer.x, racer.y, 60, '#a1887f', 10);
                        break;
                    case 'blaze_mine':
                        racer.effects.push({ type: 'slow', duration: 5.0 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 20;
                        break;
                    case 'sand_trap':
                        racer.effects.push({ type: 'slow', duration: 4.0 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 5;
                        racer.lane = Math.min(LANE_COUNT - 1, Math.max(0, racer.lane + (Math.random() > 0.5 ? 2 : -2)));
                        break;
                    case 'slow':
                        racer.effects.push({ type: 'slow', duration: this.duration * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 5;
                        break;
                    case 'heat_pulse':
                        racer.effects.push({ type: 'slow', duration: 3.5 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 15;
                        break;
                    case 'ash_hit':
                        racer.knockbackForce = 25 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.3);
                        racer.lane = Math.floor(Math.random() * LANE_COUNT);
                        racer.effects.push({ type: 'stun', duration: 1 });
                        break;
                    case 'rock_collision':
                        racer.effects.push({ type: 'slow', duration: 2.5 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 18;
                        break;
                    case 'nova_burst':
                        const victimsNova = [gameState.player, ...gameState.bots].filter(r =>
                            r !== this.owner && !r.isInvulnerable &&
                            Math.abs(r.x - racer.x) < (250 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.25)) &&
                            Math.abs(r.lane - racer.lane) <= 1
                        );
                        victimsNova.forEach(v => {
                            v.effects.push({ type: 'stun', duration: 1.5 });
                            v.knockbackForce = 15;
                            addHitToLog(this.owner, v, 'nova_burst');
                        });
                        particles.emit(racer.x, racer.y, 40, '#ffeb3b', 8);
                        break;
                    case 'void_trap':
                    case 'sink_hit':
                        racer.effects.push({ type: 'stun', duration: 2.0 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 15;
                        break;
                    case 'clone_hit':
                        racer.effects.push({ type: 'stun', duration: 2.5 });
                        racer.effects.push({ type: 'slow', duration: 3.0 });
                        racer.knockbackForce = 12 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.3);
                        break;
                    case 'acid_hit':
                        racer.effects.push({ type: 'slow', duration: 3.0 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 10;
                        break;
                    case 'stun':
                    case 'storm_hit':
                        racer.effects.push({ type: 'stun', duration: 1.5 * (1 + (this.owner ? this.owner.trapLevel - 1 : 0) * 0.2) });
                        racer.knockbackForce = 12;
                        break;
                    case 'slip':
                        racer.lane = Math.min(LANE_COUNT - 1, Math.max(0, racer.lane + (Math.random() > 0.5 ? 1 : -1)));
                        racer.effects.push({ type: 'slow', duration: 2.0 });
                        racer.knockbackForce = 8;
                        break;
                    case 'bone_pile':
                        // Pila de huesos
                        racer.effects.push({ type: 'stun', duration: 1.5 });
                        racer.progress -= 300;
                        racer.knockbackForce = 20;
                        break;
                    case 'vines_trap':
                        racer.vinesTimer = 2.0;
                        racer.effects.push({ type: 'slow', duration: 2.0 });
                        break;
                    case 'tornado_trap_mine':
                        racer.tornadoStuckTimer = 3.5;
                        particles.emit(racer.x, racer.y, 40, '#90a4ae', 5);
                        break;
                    case 'storm_block':
                        racer.effects.push({ type: 'stun', duration: 1.2 });
                        // "Recuperacion lenta" -> Slow after stun
                        setTimeout(() => {
                            racer.effects.push({ type: 'slow', duration: 2.0 });
                        }, 1200);
                        racer.knockbackForce = 20;
                        break;
                    case 'electric_mines_triple':
                        racer.effects.push({ type: 'slow', duration: 3.5 }); // Superior slow
                        racer.effects.push({ type: 'stun', duration: 0.5 });
                        racer.progress -= 200;
                        break;
                    case 'neutron_drop':
                        // Daño neutral al golpear la trampa dejada
                        racer.progress -= 300;
                        racer.knockbackForce = 10;
                        racer.effects.push({ type: 'stun', duration: 0.5 });
                        break;
                }

                // Global Reset Skill (Level 7) for ANY trap hit
                // Debugging "Manda a todos al inicio": This is the only logic that sets progress to 0.
                // Verify owner exists and level is correct.
                if (this.owner && this.owner.hasResetSkill && Math.random() < 0.15) {
                    racer.progress = 0;
                    showNotification("🌀 ¡RESET TEMPORAL! 🌀");
                }

                this.active = false;
            }
        }

        class Tsunami {
            constructor(x, centerLane, owner) {
                this.x = x;
                this.centerLane = centerLane;
                this.owner = owner;
                this.speed = 8; // Buffed speed
                this.active = true;
                this.lifetime = 4.5;
                this.hitRacers = new Set();
            }

            update(dt) {
                this.x += this.speed * dt * 60;
                this.lifetime -= dt;
                if (this.lifetime <= 0) this.active = false;
            }

            draw(ctx, cameraX) {
                if (!this.active) return;
                const screenX = this.x - cameraX + canvas.width * 0.3;
                const laneHeight = canvas.height / (LANE_COUNT + 1);

                // Determinar rango vertical (3 carriles)
                const startY = laneHeight * (this.centerLane); // Comienzo del carril superior
                const endY = laneHeight * (this.centerLane + 2); // Fin del carril inferior
                const height = endY - startY;

                ctx.save();
                // Efecto de distorsión y transparencia
                const grad = ctx.createLinearGradient(screenX - 150, 0, screenX, 0);
                grad.addColorStop(0, 'rgba(0, 188, 212, 0)');
                grad.addColorStop(0.4, 'rgba(0, 145, 163, 0.4)');
                grad.addColorStop(0.8, 'rgba(0, 247, 255, 0.7)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 0.9)');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(screenX, startY);
                // Curva frontal de la gran ola
                ctx.bezierCurveTo(screenX + 60, startY + height * 0.3, screenX + 60, startY + height * 0.7, screenX, endY);
                // Parte trasera
                ctx.lineTo(screenX - 180, endY);
                ctx.bezierCurveTo(screenX - 100, startY + height * 0.7, screenX - 100, startY + height * 0.3, screenX - 180, startY);
                ctx.closePath();
                ctx.fill();

                // Espuma de la ola
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(screenX, startY);
                ctx.bezierCurveTo(screenX + 60, startY + height * 0.3, screenX + 60, startY + height * 0.7, screenX, endY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Partículas internas de agua
                ctx.fillStyle = '#fff';
                for (let i = 0; i < 10; i++) {
                    const px = screenX - Math.random() * 100;
                    const py = startY + Math.random() * height;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            checkCollision(racer) {
                if (!this.active || racer === this.owner || this.hitRacers.has(racer)) return false;

                // Comprobar carril (dentro de un rango de ±1 del centro)
                const laneDiff = Math.abs(racer.lane - this.centerLane);
                if (laneDiff > 1) return false;

                const dx = Math.abs(racer.x - this.x);
                // El tsunami es ancho
                return dx < 80;
            }

            applyEffect(racer) {
                if (racer.isInvulnerable || racer.intangibleTimer > 0) return;
                this.hitRacers.add(racer);
                addHitToLog(this.owner, racer, 'tsunami_trap');
                racer.knockbackForce = 55; // Buffed knockback
                racer.effects.push({ type: 'stun', duration: 1.5 });
                particles.emit(racer.x, racer.y, 40, '#00bcd4', 8);

                // Bonus Reset Chance if owner is level 7
                if (this.owner && this.owner.hasResetSkill && Math.random() < 0.15) {
                    racer.progress = 0;
                    showNotification("🌀 ¡RESET TEMPORAL! 🌀");
                }

                if (racer.isPlayer) {
                    gameState.cameraShake = 15;
                    gameState.hitFlash = 0.5;
                }
            }
        }

        function addHitToLog(attacker, victim, abilityType) {
            if (!attacker || !attacker.character || !victim || !victim.character) return;

            if (attacker.isPlayer) {
                updateMissionProgress('hit_opponents');
                gameState.playerHits = (gameState.playerHits || 0) + 1;
            }

            gameState.hitLog.push({
                attacker: attacker.character,
                victim: victim.character,
                type: abilityType,
                timer: 3.0 // 3 segundos visible
            });
            if (gameState.hitLog.length > 5) gameState.hitLog.shift();
        }

        function drawBattleLog(ctx) {
            const startY = 80;
            const itemHeight = 65;

            gameState.hitLog.forEach((log, i) => {
                const alpha = Math.min(1, log.timer);
                const slideIn = log.timer > 2.5 ? (log.timer - 2.5) * 400 : 0; // Slide in from left
                const y = startY + i * itemHeight;
                const x = 20 - slideIn;

                ctx.save();
                ctx.globalAlpha = alpha;

                // Efecto de brillo detrás de la notificación
                ctx.shadowBlur = 10;
                ctx.shadowColor = log.attacker.color;

                // Contenedor principal (Glassmorphism style)
                const grad = ctx.createLinearGradient(x, y, x + 240, y);
                grad.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
                grad.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.roundRect(x, y, 240, 55, 8);
                ctx.fill();

                // Borde lateral de color
                ctx.fillStyle = log.attacker.color;
                ctx.fillRect(x, y, 4, 55);

                // ATACANTE (Círculo con color)
                ctx.fillStyle = log.attacker.color;
                ctx.beginPath();
                ctx.arc(x + 35, y + 27, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // SÍMBOLO DE ATAQUE (Centro)
                const centerCtx = ctx;
                ctx.save();
                ctx.translate(x + 120, y + 27);
                renderAbilityIcon(ctx, log.type, '#fff', 40);
                ctx.restore();

                // LÍNEA DE CONEXIÓN
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(x + 55, y + 27);
                ctx.lineTo(x + 185, y + 27);
                ctx.stroke();

                // VÍCTIMA (Círculo con color)
                ctx.fillStyle = log.victim.color;
                ctx.beginPath();
                ctx.arc(x + 205, y + 27, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            });
        }

        function startRace() {
            if (!GameData.selectedCharacter) {
                alert('¡Selecciona un personaje primero!');
                return;
            }

            // Fallback de compatibilidad para inicios directos
            ['mainMenu', 'characterSelect', 'modeSelectScreen', 'mapSelect', 'shopMenu', 'eventsScreen', 'resultsScreen']
                .forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });
            document.getElementById('gameScreen').style.display = 'block';

            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            initRace();
            gameLoop();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function initRace() {
            const mapData = MAPS[GameData.selectedMap];
            FINISH_DISTANCE = mapData.distance;

            gameState.running = true;
            gameState.raceProgress = 0;
            gameState.inventory = { projectile: null, turbo: null, trap: null };
            gameState.eliminationTimer = 15.0;
            gameState.destructionPoints = 0;
            gameState.playerHits = 0;
            gameState.turbosUsed = 0;
            gameState.checkpointsReached = [];

            // Crear jugador
            gameState.player = new Racer('TÚ', 1, true, GameData.selectedCharacter);

            // Crear bots si no es Time Attack
            const allCharIds = Object.keys(CHARACTERS);
            gameState.bots = [];
            if (gameState.mode !== 'TIME_ATTACK') {
                const availableLanes = [0, 1, 2, 3].filter(l => l !== 1);
                availableLanes.forEach((lane, idx) => {
                    const randomCharId = allCharIds[Math.floor(Math.random() * allCharIds.length)];
                    gameState.bots.push(new Racer(`BOT-${idx + 1}`, lane, false, randomCharId));
                });
            }

            // Crear Props decorativos
            gameState.props = [];
            const propType = mapData.props || 'rock';
            for (let i = 0; i < 50; i++) {
                gameState.props.push({
                    x: Math.random() * FINISH_DISTANCE,
                    y: Math.random() * canvas.height,
                    type: propType,
                    scale: 0.5 + Math.random() * 1.5,
                    opacity: 0.3 + Math.random() * 0.4
                });
            }

            // Resto de la inicialización...
            gameState.items = [];
            const isChaos = mapData.extraItems;
            const numIntervals = isChaos ? 12 : Math.floor(FINISH_DISTANCE / 1200);
            const intervals = [];
            for (let i = 1; i <= numIntervals; i++) {
                intervals.push(i / (numIntervals + 1));
            }

            intervals.forEach(pct => {
                const x = pct * FINISH_DISTANCE;
                for (let l = 0; l < LANE_COUNT; l++) {
                    gameState.items.push(new ItemBox(x, l));
                }
            });

            gameState.tsunamis = [];
            gameState.hitLog = [];
            gameState.projectiles = [];
            gameState.traps = [];
            gameState.cameraShake = 0;
            gameState.hitFlash = 0;
            gameState.cameraZoom = 1;
            gameState.cameraAngle = 0;
            gameState.slowMo = 1.0;

            updateItemDisplay();
            setupControls();
        }

        function setupControls() {
            document.onkeydown = (e) => {
                if (!gameState.running) return;

                const key = e.key.toLowerCase();
                if (key === 'arrowup' || key === 'w') {
                    gameState.player.lane = Math.max(0, gameState.player.lane - 1);
                }
                if (key === 'arrowdown' || key === 's') {
                    gameState.player.lane = Math.min(LANE_COUNT - 1, gameState.player.lane + 1);
                }

                // Item Shortcuts
                if (key === 'q' || key === '1') useTypedItem('projectile');
                if (key === 'shift' || key === '2') useTypedItem('turbo');
                if (key === 'e' || key === '3') useTypedItem('trap');
            };
        }

        // Hook para misiones de Knockout
        function checkKnockoutMission(position) {
            if (gameState.mode === 'KNOCKOUT' && position <= 2) {
                updateMissionProgress('top_2_ko');
            }
        }

        function useTypedItem(type) {
            if (gameState.inventory[type]) {
                if (type === 'turbo') {
                    updateMissionProgress('use_turbo');
                    gameState.turbosUsed = (gameState.turbosUsed || 0) + 1;
                }
                if (type === 'trap') updateMissionProgress('use_trap');
                gameState.player.item = gameState.inventory[type];
                gameState.player.useItem();
                gameState.inventory[type] = null;
                updateItemDisplay(); // Asegurar que se limpia la UI inmediatamente
            }
        }

        function updateItemDisplay() {
            const slots = {
                projectile: { slot: 'slotProjectile', canvas: 'canvasProjectile', icon: 'iconProjectile' },
                turbo: { slot: 'slotTurbo', canvas: 'canvasTurbo', icon: 'iconTurbo' },
                trap: { slot: 'slotTrap', canvas: 'canvasTrap', icon: 'iconTrap' }
            };

            for (const [type, el] of Object.entries(slots)) {
                const slotDiv = document.getElementById(el.slot);
                const cvs = document.getElementById(el.canvas);
                const iconSpan = document.getElementById(el.icon);
                const item = gameState.inventory[type];
                const ctx = cvs.getContext('2d');

                // Asegurar que el span de emoji está SIEMPRE vacío y oculto
                if (iconSpan) {
                    iconSpan.textContent = '';
                    iconSpan.classList.add('hidden');
                }

                if (item) {
                    slotDiv.classList.remove('empty');
                    const char = gameState.player.character;
                    let effect = '';
                    if (item.type === 'shield') effect = 'shield';
                    else if (item.type === 'projectile') effect = char.projectile.effect;
                    else if (item.type === 'turbo') effect = char.turbo.effect || 'generic_turbo';
                    else if (item.type === 'trap') effect = char.trap.effect;

                    renderAbilityIcon(ctx, effect, char.color);

                    // Overlay de duración si está activo
                    if (gameState.player.activeItemType === type) {
                        const pct = gameState.player.itemActiveTimer / gameState.player.itemMaxDuration;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.beginPath();
                        ctx.moveTo(30, 30);
                        ctx.arc(30, 30, 40, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * pct));
                        ctx.fill();

                        // Pulso suave
                        const pulse = 1 + Math.sin(Date.now() / 200) * 0.1;
                        slotDiv.style.transform = `scale(${pulse})`;
                    } else {
                        slotDiv.style.transform = '';
                    }
                } else {
                    slotDiv.classList.add('empty');
                    ctx.clearRect(0, 0, cvs.width, cvs.height);
                }
            }
        }

        function getRandomItem(racer, position) {
            const char = racer.character;
            const allRacers = [gameState.player, ...gameState.bots].sort((a, b) => b.progress - a.progress);
            const leader = allRacers[0];
            const distanceToLeader = leader.progress - racer.progress;
            const isTrailer = gameState.trailer;

            if (racer.isPlayer || isTrailer) {
                // Restricción de Turbo: Solo si estás a más de 500m del líder o no eres 1ero
                const canGetTurbo = (position > 1) && (distanceToLeader > 500 || isTrailer);

                if (canGetTurbo && !gameState.inventory.turbo) {
                    return { type: 'turbo', name: char.turbo.name };
                }

                if (!gameState.inventory.projectile || !gameState.inventory.trap) {
                    if (!gameState.inventory.projectile && (!gameState.inventory.trap || Math.random() > 0.5)) {
                        return { type: 'projectile', name: char.projectile.name };
                    }
                    if (!gameState.inventory.trap) {
                        return { type: 'trap', name: char.trap.name };
                    }
                }

                return { type: 'shield', name: 'Escudo' };
            }

            // Bots: Turbo solo si están atrás
            const rand = Math.random();
            if (position > 1 && distanceToLeader > 600) return { type: 'turbo', name: char.turbo.name };
            if (rand < 0.45) return { type: 'projectile', name: char.projectile.name };
            if (rand < 0.8) return { type: 'trap', name: char.trap.name };
            return { type: 'shield', name: 'Escudo' };
        }
        function gameLoop() {
            if (!gameState.running) return;

            const dt = 1 / 60;

            // Control dinámico de Velocidad Temporal (Slow-Mo)
            if (gameState.slowMo < 1.0) gameState.slowMo += dt * 2;
            if (gameState.slowMo > 1.0) gameState.slowMo = 1.0;

            const effectiveDt = dt * gameState.slowMo;
            gameState.trailerTimer += effectiveDt; // Usar tiempo efectivo

            // Script del Trailer removido

            // Actualizar jugador
            gameState.player.x = gameState.player.progress;
            gameState.player.update(effectiveDt);

            // Actualizar bots
            gameState.bots.forEach(bot => {
                bot.x = bot.progress;
                bot.update(effectiveDt);
            });

            // Definir todos los corredores para cálculos siguientes
            const allRacers = [gameState.player, ...gameState.bots];

            // Actualizar partículas
            particles.update(effectiveDt);

            // Contacto de Turbo e Impactos Violentos (Más del 50% de turbos ahora dañan)
            allRacers.forEach(attacker => {
                if (attacker.turboActive && !attacker.finished) {
                    allRacers.forEach(victim => {
                        if (attacker !== victim && !victim.finished && attacker.lane === victim.lane) {
                            const dx = Math.abs(attacker.x - victim.x);
                            if (dx < 60) {
                                // Efectos de Contacto por Personaje
                                switch (attacker.characterId) {
                                    case 'terra':
                                        if (victim.rockDebuffTimer <= 0) {
                                            victim.rockDebuffTimer = 4.0;
                                            victim.knockbackForce = 15;
                                            addHitToLog(attacker, victim, '🪨');
                                        }
                                        break;
                                    case 'volt':
                                        victim.electrifiedTimer = 1.0;
                                        removeRacerItem(victim);
                                        victim.knockbackForce = 10;
                                        addHitToLog(attacker, victim, '⚡');
                                        break;
                                    case 'titan':
                                        victim.progress -= 1200;
                                        victim.effects.push({ type: 'stun', duration: 2.0 });
                                        victim.knockbackForce = 40;
                                        addHitToLog(attacker, victim, '🐃');
                                        break;
                                    case 'crimson':
                                        victim.progress -= 600;
                                        victim.effects.push({ type: 'slow', duration: 4.0 });
                                        addHitToLog(attacker, victim, '🩸');
                                        break;
                                    case 'omega':
                                        victim.effects.push({ type: 'stun', duration: 1.5 });
                                        particles.emit(victim.x, victim.y, 30, '#fff', 10);
                                        addHitToLog(attacker, victim, '⚛️');
                                        break;
                                    case 'blaze':
                                        victim.effects.push({ type: 'slow', duration: 2.0 });
                                        addHitToLog(attacker, victim, '🔥');
                                        break;
                                    case 'phantom':
                                        victim.progress -= 300;
                                        removeRacerItem(victim);
                                        addHitToLog(attacker, victim, '👻');
                                        break;
                                    case 'glitch':
                                        victim.progress -= Math.random() * 800;
                                        victim.lane = Math.floor(Math.random() * LANE_COUNT);
                                        addHitToLog(attacker, victim, '👾');
                                        break;
                                    default:
                                        // Daño genérico de colisión a alta velocidad
                                        victim.progress -= 200;
                                        victim.knockbackForce = 5;
                                }

                                if (gameState.mode === 'STRIKE') gameState.destructionPoints += 100;
                            }
                        }
                    });
                }
            });

            // Actualizar cajas de items (Respawn)
            gameState.items.forEach(item => item.update(effectiveDt));

            // Calcular posiciones
            const sortedRacers = [...allRacers].sort((a, b) => b.progress - a.progress);
            const playerPosition = sortedRacers.findIndex(r => r.isPlayer) + 1;

            gameState.items.forEach(item => {
                if (!item.collected && item.checkCollision(gameState.player, gameState.player.x)) {
                    // Solo intentar recoger si hay al menos un hueco libre para lo que nos den
                    const newItem = getRandomItem(gameState.player, playerPosition);
                    let targetSlot = newItem.type === 'shield' ? 'projectile' : newItem.type;

                    if (!gameState.inventory[targetSlot]) {
                        item.collected = true;
                        item.respawnTime = 0.5;
                        gameState.inventory[targetSlot] = newItem;
                        updateMissionProgress('collect_items');
                        // Forzar limpieza de iconos antes de actualizar
                        const slotIds = ['iconProjectile', 'iconTurbo', 'iconTrap'];
                        slotIds.forEach(id => {
                            const el = document.getElementById(id);
                            if (el) { el.textContent = ''; el.classList.add('hidden'); }
                        });
                        updateItemDisplay();
                    }
                }

                // Bots también pueden recoger items
                gameState.bots.forEach((bot, botIndex) => {
                    if (!item.collected && item.checkCollision(bot, bot.x) && !bot.item) {
                        item.collected = true;
                        item.respawnTime = 0.5; // RESTAURADO 0.5s
                        const botPosition = sortedRacers.findIndex(r => r === bot) + 1;
                        bot.item = getRandomItem(bot, botPosition);

                        // Bots usan items automáticamente (Solo si NO están en 1er puesto)
                        setTimeout(() => {
                            if (bot.item && gameState.running) {
                                const botPos = sortedRacers.indexOf(bot) + 1;
                                if (bot.item.type === 'turbo' && botPos === 1) return; // FIX: No usar turbo si es 1ero
                                bot.useItem();
                            }
                        }, 500 + Math.random() * 1500);
                    }
                });
            });

            // Actualizar proyectiles
            gameState.projectiles = gameState.projectiles.filter(proj => {
                proj.update(effectiveDt);

                // Verificar colisiones con todos los corredores
                for (const racer of allRacers) {
                    if (proj.checkCollision(racer)) {
                        proj.applyEffect(racer);
                        return false; // Remover proyectil
                    }
                }

                // Remover si se aleja mucho
                if (Math.abs(proj.x - gameState.player.x) > 2000) {
                    return false;
                }

                return proj.active;
            });

            // Actualizar trampas
            gameState.traps = gameState.traps.filter(trap => {
                trap.update(effectiveDt);

                // Verificar colisiones con todos los corredores
                for (const racer of allRacers) {
                    if (trap.checkCollision(racer)) {
                        trap.applyEffect(racer);
                        return false; // Remover trampa
                    }
                }

                return trap.active;
            });

            // Actualizar Tsunamis
            gameState.tsunamis = gameState.tsunamis.filter(tsu => {
                tsu.update(effectiveDt);
                for (const racer of allRacers) {
                    if (tsu.checkCollision(racer)) {
                        tsu.applyEffect(racer);
                    }
                }
                return tsu.active;
            });

            // Verificar terminados (MOVER ANTES DE DIBUJAR)
            allRacers.forEach(r => {
                if (!r.finished && r.progress >= FINISH_DISTANCE) {
                    r.finished = true;
                    r.progress = FINISH_DISTANCE;
                    r.x = FINISH_DISTANCE; // Asegurar que el modelo visual se detenga aquí

                    const finishedCount = allRacers.filter(other => other.finished).length;
                    r.finalPosition = finishedCount;

                    if (r.isPlayer) {
                        // El HUD ya indica la posición
                    }
                }

                // Si ya terminó, forzar posición y velocidad cero
                if (r.finished) {
                    r.progress = FINISH_DISTANCE;
                    r.x = FINISH_DISTANCE;
                }
            });

            // Dibujar
            draw(playerPosition, allRacers);
            gameState.tsunamis.forEach(tsu => tsu.draw(ctx, gameState.player.x));

            // Actualizar HUD
            drawBattleLog(ctx);

            // Actualizar timers del log
            gameState.hitLog.forEach(log => log.timer -= effectiveDt);
            gameState.hitLog = gameState.hitLog.filter(log => log.timer > 0);

            document.getElementById('currentPosition').innerHTML = playerPosition + '<span style="font-size: 1.5rem; vertical-align: top;">°</span>';
            const progressPct = Math.min(100, Math.floor((gameState.player.progress / FINISH_DISTANCE) * 100));
            document.getElementById('raceProgressPercent').textContent = progressPct + '%';

            // Velocímetro (Simulado KM/H)
            const displaySpeed = Math.floor(gameState.player.vSpeed * 20);
            document.getElementById('speedDisplay').textContent = String(displaySpeed).padStart(3, '0');

            // Texto de espera si el jugador terminó
            if (gameState.player.finished) {
                const results = allRacers.filter(r => r.finished).length;
                document.getElementById('raceProgressPercent').innerHTML = `<span style="color: var(--accent-cyan); animation: titlePulse 1s infinite">COMPLETADO (${results}/4)</span>`;
                document.getElementById('speedDisplay').textContent = "000";
            }

            // Actualizar indicador horizontal
            allRacers.forEach((racer) => {
                const dotId = racer.isPlayer ? 'playerDot' : `bot${gameState.bots.indexOf(racer) + 1}Dot`;
                const dot = document.getElementById(dotId);
                if (dot) {
                    const progress = Math.min(1, racer.progress / FINISH_DISTANCE);
                    dot.style.left = `${progress * 100}%`;
                    if (typeof renderProgressDotModel === 'function') {
                        renderProgressDotModel(dot, racer);
                    } else {
                        dot.textContent = racer.isPlayer ? '👤' : '🤖';
                    }
                }
            });

            // MODO KNOCKOUT: Reworked to timer-based elimination
            if (gameState.mode === 'KNOCKOUT') {
                const stillInRace = allRacers.filter(r => !r.eliminated && !r.finished);

                if (stillInRace.length > 1) {
                    gameState.eliminationTimer -= effectiveDt;

                    if (gameState.eliminationTimer <= 0) {
                        const last = stillInRace.sort((a, b) => a.progress - b.progress)[0];
                        last.eliminated = true;
                        last.speed = 0;
                        particles.emit(last.x, last.y, 100, '#f44336', 15);
                        addHitToLog(null, last, 'ELIMINADO');

                        if (last.isPlayer) {
                            gameState.player.finalPosition = stillInRace.length;
                            showNotification("¡HAS SIDO ELIMINADO! Esperando final de carrera...");
                            gameState.cameraShake = 30;
                        } else {
                            gameState.eliminationTimer = 15.0; // Reset timer for next victim
                            gameState.cameraShake = 20;
                            showNotification(`¡${last.name} ELIMINADO!`);
                        }
                    }
                }
            }

            // Solo finalizar cuando TODOS hayan terminado
            if (allRacers.every(r => r.finished || r.eliminated)) {
                endRace(gameState.player.finalPosition);
                return;
            }

            animationId = requestAnimationFrame(gameLoop);
        }


        // Función para intentar desbloquear un personaje aleatorio (recompensa)
        function tryRandomUnlock() {
            const locked = Object.keys(CHARACTERS).filter(id => !GameData.unlockedCharacters.includes(id));
            if (locked.length > 0 && Math.random() < 0.3) { // 30% de probabilidad si ganas
                const randomCharId = locked[Math.floor(Math.random() * locked.length)];
                GameData.unlockedCharacters.push(randomCharId);
                saveGame();
                return CHARACTERS[randomCharId];
            }
            return null;
        }


        function draw(playerPosition, allRacers) {
            const map = MAPS[GameData.selectedMap];

            // Efecto de Camera Cinemática (Trailer God Mode)
            ctx.save();

            if (gameState.trailer) {
                // Post-proceso cinemático
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(gameState.cameraAngle);
                ctx.scale(gameState.cameraZoom, gameState.cameraZoom);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);

                // Efecto Cromático (Sutil)
                if (Math.random() > 0.9) {
                    ctx.globalCompositeOperation = 'screen';
                    ctx.save();
                    ctx.translate(1, 0);
                    ctx.globalAlpha = 0.2;
                    ctx.restore();
                    ctx.globalCompositeOperation = 'source-over'; // FIX: Resetear SIEMPRE
                }

                // Efecto SCANLINES y VIÑETA (Más suave)
                const vignette = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, canvas.width / 3, canvas.width / 2, canvas.height / 2, canvas.width);
                vignette.addColorStop(0, 'rgba(0,0,0,0)');
                vignette.addColorStop(1, 'rgba(0,0,0,0.5)');
                ctx.fillStyle = vignette;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Ruido digital (Reducido)
                if (Math.random() > 0.98) {
                    ctx.fillStyle = `rgba(255, 255, 255, 0.02)`;
                    for (let x = 0; x < canvas.width; x += 20) ctx.fillRect(x, 0, 1, canvas.height);
                }
            }

            if (gameState.cameraShake > 0) {
                const sx = (Math.random() - 0.5) * gameState.cameraShake;
                const sy = (Math.random() - 0.5) * gameState.cameraShake;
                ctx.translate(sx, sy);
                gameState.cameraShake *= 0.9;
            }

            // --- INICIO MUNDO (Escalado por Cámara) ---

            // Fondo
            ctx.fillStyle = map.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pista
            const laneHeight = canvas.height / (LANE_COUNT + 1);

            for (let i = 0; i < LANE_COUNT; i++) {
                const y = laneHeight * (i + 1);
                ctx.fillStyle = map.trackColor;
                ctx.fillRect(0, y - 30, canvas.width, 60);

                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.setLineDash([30, 20]);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Efectos de velocidad (Mejorados)
            const isTurbo = gameState.player.turboActive;
            const speedLines = isTurbo ? 40 : 15;
            ctx.strokeStyle = isTurbo ? 'rgba(0, 247, 255, 0.6)' : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = isTurbo ? 3 : 1;

            for (let i = 0; i < speedLines; i++) {
                const x = (Date.now() / (isTurbo ? 2 : 5) + i * 100) % canvas.width;
                const y = Math.random() * canvas.height;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x - (isTurbo ? 100 : 30), y);
                ctx.stroke();
            }

            // FLASH DE DAÑO (Vignette roja)
            if (gameState.hitFlash > 0) {
                const grad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width);
                grad.addColorStop(0.5, 'transparent');
                grad.addColorStop(1, `rgba(255, 0, 0, ${gameState.hitFlash * 0.5})`);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                gameState.hitFlash -= 1 / 60;
            }

            // Elección de cámara dinámica: seguir líder si el jugador ya terminó o fue eliminado
            const leadingActiveRacer = allRacers
                .filter(r => !r.finished && !r.eliminated)
                .sort((a, b) => b.progress - a.progress)[0];

            const cameraX = (leadingActiveRacer && (gameState.player.finished || gameState.player.eliminated))
                ? leadingActiveRacer.x
                : gameState.player.x;

            // Dibujar partículas ambientales según el mapa
            if (Math.random() > 0.8) {
                const map = MAPS[GameData.selectedMap];
                particles.emitSpeed(cameraX + canvas.width, Math.random() * canvas.height, map.accentColor);
            }

            // Dibujar Props decorativos
            gameState.props.forEach(p => {
                const screenX = p.x - cameraX + canvas.width * 0.3;
                if (screenX < -200 || screenX > canvas.width + 200) return;

                ctx.save();
                ctx.globalAlpha = p.opacity;
                ctx.translate(screenX, p.y);
                ctx.scale(p.scale, p.scale);
                renderRacerModel(ctx, `prop_${p.type}`, 0, 0, 1, { color: map.accentColor });
                ctx.restore();
            });

            // Dibujar partículas
            particles.draw(ctx, cameraX);

            // Dibujar trampas (detrás de los personajes)
            gameState.traps.forEach(trap => trap.draw(ctx, cameraX));

            // Dibujar items
            gameState.items.forEach(item => item.draw(ctx, cameraX));

            // Dibujar corredores eliminados (estáticos)
            allRacers.forEach(r => {
                if (r.eliminated) {
                    ctx.save();
                    ctx.filter = 'grayscale(1) brightness(0.5)';
                    r.draw(ctx, cameraX);
                    ctx.restore();
                }
            });

            // Dibujar bots
            gameState.bots.forEach(bot => {
                if (!bot.eliminated) bot.draw(ctx, cameraX);
            });

            // Dibujar jugador
            if (!gameState.player.eliminated) gameState.player.draw(ctx, cameraX);

            // Dibujar proyectiles (encima de los personajes)
            gameState.projectiles.forEach(proj => proj.draw(ctx, cameraX));

            // Meta
            const finishX = FINISH_DISTANCE - cameraX + canvas.width * 0.3;
            if (finishX < canvas.width + 100) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.fillRect(finishX, 0, 10, canvas.height);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('🏁 META 🏁', finishX, 50);
            }

            // MODO KNOCKOUT: Visual Timer
            if (gameState.mode === 'KNOCKOUT' && gameState.running) {
                const timer = Math.ceil(gameState.eliminationTimer);
                ctx.save();
                ctx.font = 'bold 60px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                // Color cambiante si queda poco tiempo
                ctx.fillStyle = timer <= 5 ? '#f44336' : '#fff';
                if (timer <= 5) {
                    const pulse = 1 + Math.sin(Date.now() / 100) * 0.1;
                    ctx.scale(pulse, pulse);
                    ctx.shadowColor = '#f44336';
                    ctx.shadowBlur = 20;
                }

                ctx.fillText(timer, canvas.width / 2, 80);

                ctx.font = 'bold 16px Orbitron';
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.fillText('PRÓXIMA ELIMINACIÓN', canvas.width / 2, 60);
                ctx.restore();
            }

            // --- FIN MUNDO ---
            ctx.restore();
        }

        function endRace(position) {
            gameState.running = false;
            cancelAnimationFrame(animationId);

            // Misiones
            if (position === 1) {
                updateMissionProgress('win_race');
                GameData.consecutiveWins = (GameData.consecutiveWins || 0) + 1;
                updateMissionProgress('win_streak_3', GameData.consecutiveWins, true);
            } else {
                GameData.consecutiveWins = 0;
                updateMissionProgress('win_streak_3', 0, true);
            }

            if (position <= 3) updateMissionProgress('top_3');

            // Misión de Mapa Específico (Jardín del Amor)
            if (GameData.selectedMap === 'jungle_temple') {
                updateMissionProgress('race_jungle');
            }
            // Misión Glitch Map
            if (GameData.selectedMap === 'glitch_void') {
                updateMissionProgress('race_glitch');
                if (position === 1 && gameState.turbosUsed === 0) {
                    updateMissionProgress('win_no_turbo_glitch');
                }
            }

            // Otras misiones complejas
            if (gameState.playerHits >= 15) {
                updateMissionProgress('hit_15_one_race');
            }

            if (gameState.mode === 'KNOCKOUT' && position === 1) {
                updateMissionProgress('win_knockout');
            }

            // XP Recompensa
            const mapMultiplier = FINISH_DISTANCE / 5000;
            const xpRewards = { 1: 500, 2: 300, 3: 150, 4: 50 };
            const xpGained = Math.floor(xpRewards[position] * mapMultiplier);
            addXP(xpGained);

            // Mostrar resultados
            document.getElementById('gameScreen').style.display = 'none';
            const results = document.getElementById('resultsScreen');
            results.style.display = 'flex';

            const titles = {
                1: '🏆 ¡VICTORIA MAGISTRAL!',
                2: '🥈 ¡SEGUNDO LUGAR!',
                3: '🥉 ¡TERCER LUGAR!',
                4: '😅 ¡SIGUE ENTRENANDO!'
            };

            document.getElementById('resultsTitle').textContent = titles[position];
            document.getElementById('resultsPosition').textContent = position === 1 ? '🏆' :
                position === 2 ? '🥈' : position === 3 ? '🥉' : '4°';

            let rewardHtml = `<div class="reward-item" style="margin-bottom: 10px;">+${xpGained} XP</div>`;
            // Título de sección de recompensas
            rewardHtml += `<div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 15px 0; padding-top: 15px;">
                <h4 style="color: var(--accent-cyan); margin-bottom: 10px;">RECOMPENSAS DE CARRERA</h4>
                <div id="battleChestArea">
                    <button class="start-race-btn" onclick="claimBattleChest(${position})" style="padding: 10px 20px; font-size: 0.9rem;">RECLAMAR COFRE ${position === 1 ? 'VICTORIA' : 'BATALLA'}</button>
                </div>
            </div>`;

            document.querySelector('.rewards').innerHTML = rewardHtml;

            // Misiones de Evento como SECCION SEPARADA
            if (gameState.pendingRewards && gameState.pendingRewards.length > 0) {
                const rewardSection = document.createElement('div');
                rewardSection.style.marginTop = '20px';
                rewardSection.style.padding = '15px';
                rewardSection.style.background = 'rgba(233, 30, 99, 0.1)';
                rewardSection.style.border = '1px solid #e91e63';
                rewardSection.style.borderRadius = '10px';

                rewardSection.innerHTML = `
                    <h4 style="color: #ff4081; margin-bottom: 10px;">🎁 RECOMPENSAS DE EVENTO</h4>
                    <p style="font-size: 0.8rem; margin-bottom: 10px;">Has completado ${gameState.pendingRewards.length} misiones durante esta carrera.</p>
                    <div id="eventRewardsArea"></div>
                 `;

                const openBtn = document.createElement('button');
                openBtn.className = 'start-race-btn';
                openBtn.style.background = '#e91e63';
                openBtn.textContent = `ABRIR RECOMPENSA (${gameState.pendingRewards.length} PENDIENTES)`;
                openBtn.onclick = () => {
                    const nextMission = gameState.pendingRewards.shift();
                    if (nextMission) {
                        openEventRewardModal(nextMission);
                        if (gameState.pendingRewards.length === 0) {
                            rewardSection.innerHTML = `<p style="color: #0f0; font-weight: bold;">¡TODAS LAS RECOMPENSAS RECLAMADAS!</p>`;
                        } else {
                            openBtn.textContent = `ABRIR RECOMPENSA (${gameState.pendingRewards.length} PENDIENTES)`;
                        }
                    }
                };

                document.querySelector('.rewards').appendChild(rewardSection);
                rewardSection.querySelector('#eventRewardsArea').appendChild(openBtn);
            }

            saveGame();
            updateVoltBitsDisplay();
            updatePlayerLevelDisplay();
        }

        function claimBattleChest(pos) {
            const area = document.getElementById('battleChestArea');
            if (area) {
                area.innerHTML = `<p style="color: var(--accent-cyan); font-weight: bold;">RECOMPENSA RECLAMADA</p>`;
            }
            awardChest('battle_' + pos);
        }

        function addXP(amount) {
            GameData.xp += amount;
            const xpPerLevel = GameData.level * 1000;
            if (GameData.xp >= xpPerLevel) {
                GameData.xp -= xpPerLevel;
                GameData.level++;
                if (grantVoltBits(1000, true, 'Subida de nivel')) {
                    showNotification(`¡NIVEL ALCANZADO: ${GameData.level}! +1000 VoltBits`);
                } else {
                    showNotification(`¡NIVEL ALCANZADO: ${GameData.level}! Vincula Ocean Pay para reclamar VoltBits.`);
                }
            }
            saveGame();
            updatePlayerLevelDisplay();
        }

        function updatePlayerLevelDisplay() {
            const el = document.getElementById('playerLevelDisplay');
            if (el) el.textContent = `LVL ${GameData.level}`;
        }

        // Initialize Key Listeners for Neutron Manual Fire
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'e' || key === '3') { // Trap Key
                // Check if player has Neutron Ammo
                if (gameState.player && gameState.player.neutronAmmo > 0) {
                    gameState.player.neutronAmmo--;

                    // Drop Neutron Trap (Stationary or Backwards)
                    // "Los debe dejar atras suyo" -> Stationary Trap on track implies it stays behind as you move forward.
                    const trap = new Trap(gameState.player.x, gameState.player.lane, 'neutron_drop', '⚛️', '#64ffda', 4, gameState.player);
                    gameState.traps.push(trap);

                    particles.emit(gameState.player.x, gameState.player.y, 10, '#64ffda', 5);
                }
            }
        });

        // Iniciar
        updatePlayerLevelDisplay();

        // --- OCEAN PAY INTEGRATION ---
        // --- OCEAN PAY INTEGRATED INTEGRATION ---
        let oceanPayState = {
            token: localStorage.getItem('opToken'),
            user: JSON.parse(localStorage.getItem('opUser') || 'null'),
            linked: (localStorage.getItem('opLinked') === '1') && !!localStorage.getItem('opToken'),
            lastSyncAt: 0,
            amount: 0,
            concept: '',
            onSuccess: null
        };

        function clearOceanPaySession(notify = false) {
            oceanPayState.token = null;
            oceanPayState.user = null;
            oceanPayState.linked = false;
            oceanPayState.lastSyncAt = 0;
            try {
                localStorage.removeItem('opToken');
                localStorage.removeItem('opUser');
                localStorage.removeItem('opLinked');
            } catch (_) { }
            updateVoltBitsDisplay();
            if (notify && typeof showNotification === 'function') {
                showNotification('Sesion de Ocean Pay expirada. Inicia sesion nuevamente.');
            }
        }

        async function syncOceanPayLinkState() {
            if (!oceanPayState.token) {
                oceanPayState.linked = false;
                updateVoltBitsDisplay();
                return false;
            }
            const wasLinked = oceanPayState.linked;

            const cardList = document.getElementById('opCardList');
            if (cardList) {
                cardList.innerHTML = '<p style="color:var(--accent-cyan); font-family:Orbitron; font-size:0.8rem;">VALIDANDO SESION...</p>';
            }

            try {
                const res = await fetch('https://owsdatabase.onrender.com/ocean-pay/me', {
                    headers: { 'Authorization': `Bearer ${oceanPayState.token}` }
                });
                const data = await res.json();

                if (res.status === 401 || res.status === 403) {
                    clearOceanPaySession(true);
                    return false;
                }
                if (!res.ok || !Array.isArray(data.cards)) {
                    oceanPayState.linked = wasLinked;
                    updateVoltBitsDisplay();
                    return wasLinked;
                }

                if (data.user && typeof data.user === 'object') {
                    oceanPayState.user = data.user;
                    localStorage.setItem('opUser', JSON.stringify(data.user));
                }

                const primary = data.cards.find(c => c.is_primary) || data.cards[0];
                const primaryBalance = Math.floor(primary?.balances?.voltbit || 0);
                GameData.voltBits = primaryBalance;
                oceanPayState.linked = true;
                oceanPayState.lastSyncAt = Date.now();
                localStorage.setItem('opLinked', '1');
                updateVoltBitsDisplay();
                saveGame();
                return true;
            } catch (_) {
                oceanPayState.linked = wasLinked;
                updateVoltBitsDisplay();
                return wasLinked;
            }
        }

        window.disconnectOceanPay = function disconnectOceanPay() {
            clearOceanPaySession(false);
            updateOceanPayUI();
        };

        async function startOceanPayTransaction(amount, concept, onSuccess) {
            oceanPayState.amount = amount;
            oceanPayState.concept = concept;
            oceanPayState.onSuccess = onSuccess;

            updateOceanPayUI();
            document.getElementById('oceanPayIntegratedModal').style.display = 'flex';
        }

        function updateOceanPayUI() {
            const loginSection = document.getElementById('opLoginSection');
            const checkoutSection = document.getElementById('opCheckoutSection');

            document.getElementById('opCheckoutAmount').textContent = oceanPayState.amount;
            document.getElementById('opCheckoutConcept').textContent = oceanPayState.concept;

            if (!oceanPayState.token) {
                oceanPayState.linked = false;
                loginSection.style.display = 'flex';
                checkoutSection.style.display = 'none';
                showOpSubTab('credentials');
                updateVoltBitsDisplay();
            } else {
                loginSection.style.display = 'none';
                checkoutSection.style.display = 'flex';
                document.getElementById('opWelcomeUser').textContent = `Hola, ${(oceanPayState.user && oceanPayState.user.username) ? oceanPayState.user.username : 'Jugador'}`;
                loadOceanPayCards();
            }
        }

        function showOpSubTab(tab) {
            document.getElementById('opSubTabCredentials').style.display = tab === 'credentials' ? 'flex' : 'none';
            document.getElementById('opSubTabCard').style.display = tab === 'card' ? 'flex' : 'none';
            document.getElementById('btnTabCred').classList.toggle('active', tab === 'credentials');
            document.getElementById('btnTabCard').classList.toggle('active', tab === 'card');
        }

        async function opLogin() {
            const user = document.getElementById('opUser').value;
            const pass = document.getElementById('opPass').value;
            const btn = document.getElementById('opLoginBtn');
            const msg = document.getElementById('opMsg');

            if (!user || !pass) { msg.textContent = 'Faltan datos'; return; }

            btn.disabled = true;
            btn.textContent = 'CONECTANDO...';
            msg.textContent = '';

            try {
                const res = await fetch('https://owsdatabase.onrender.com/ocean-pay/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: user, password: pass })
                });
                const data = await res.json();
                if (data.success) {
                    oceanPayState.token = data.token;
                    oceanPayState.user = data.user;
                    oceanPayState.linked = true;
                    localStorage.setItem('opToken', data.token);
                    localStorage.setItem('opUser', JSON.stringify(data.user));
                    localStorage.setItem('opLinked', '1');
                    updateOceanPayUI();
                    syncOceanPayLinkState();
                } else {
                    msg.textContent = data.error || 'Fallo en la conexión';
                }
            } catch (e) {
                msg.textContent = 'Error de servidor';
            } finally {
                btn.disabled = false;
                btn.textContent = 'ENTRAR';
            }
        }

        async function opCardPay() {
            const num = document.getElementById('opCardNum').value;
            const exp = document.getElementById('opCardExp').value;
            const cvv = document.getElementById('opCardCvv').value;
            const btn = document.getElementById('opCardPayBtn');
            const msg = document.getElementById('opMsg');

            if (!num || !cvv) { msg.textContent = 'Faltan datos de tarjeta'; return; }

            btn.disabled = true;
            btn.textContent = 'PROCESANDO...';

            try {
                const res = await fetch('https://owsdatabase.onrender.com/ocean-pay/direct-card-pay', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        cardNumber: num,
                        cvv: cvv,
                        expiryDate: exp,
                        amount: oceanPayState.amount,
                        currency: 'voltbit',
                        concepto: oceanPayState.concept,
                        origen: 'Velocity Surge'
                    })
                });
                const data = await res.json();
                if (data.success) {
                    if (oceanPayState.onSuccess) oceanPayState.onSuccess();
                    showNotification('¡PAGO EXITOSO!');
                    closeOceanPay();
                } else {
                    msg.textContent = data.error;
                }
            } catch (e) {
                msg.textContent = 'Error de conexión';
            } finally {
                btn.disabled = false;
                btn.textContent = 'PAGAR AHORA';
            }
        }

        async function loadOceanPayCards() {
            const cardList = document.getElementById('opCardList');
            if (!oceanPayState.token) {
                oceanPayState.linked = false;
                updateVoltBitsDisplay();
                cardList.innerHTML = '<p style="color:#888;">Inicia sesion para ver tu saldo.</p>';
                return;
            }
            cardList.innerHTML = '<p style="color:var(--accent-cyan); font-family:Orbitron; font-size:0.8rem;">CARGANDO TARJETAS...</p>';

            try {
                const res = await fetch('https://owsdatabase.onrender.com/ocean-pay/me', {
                    headers: { 'Authorization': `Bearer ${oceanPayState.token}` }
                });
                const data = await res.json();
                if (res.status === 401 || res.status === 403) {
                    clearOceanPaySession(true);
                    updateOceanPayUI();
                    return;
                }
                if (Array.isArray(data.cards)) {
                    if (data.user && typeof data.user === 'object') {
                        oceanPayState.user = data.user;
                        localStorage.setItem('opUser', JSON.stringify(data.user));
                    }
                    oceanPayState.linked = true;
                    oceanPayState.lastSyncAt = Date.now();
                    localStorage.setItem('opLinked', '1');
                    cardList.innerHTML = '';
                    let hasPrimary = false;
                    data.cards.forEach(card => {
                        const div = document.createElement('div');
                        div.className = 'op-card-item';
                        const balance = card.balances?.voltbit || 0;

                        // Sync local GameData with Primary card balance
                        if (card.is_primary) {
                            hasPrimary = true;
                            GameData.voltBits = Math.floor(balance);
                            updateVoltBitsDisplay();
                            saveGame();
                        }

                        div.innerHTML = `
                            <div style="font-weight:bold; color:white;">${card.card_name} ${card.is_primary ? '<span style="color:var(--accent-gold); font-size:0.6rem;">PRINCIPAL</span>' : ''}</div>
                            <div style="font-size:0.8rem; color:var(--accent-cyan);">Saldo: ${Math.floor(balance)} VoltBits</div>
                            <div style="font-size:0.75rem; color:#888;">**** **** **** ${card.card_number.slice(-4)}</div>
                        `;
                        div.onclick = () => confirmOpPayment(card.id, balance);
                        cardList.appendChild(div);
                    });
                    if (!hasPrimary && data.cards[0]) {
                        GameData.voltBits = Math.floor(data.cards[0].balances?.voltbit || 0);
                        updateVoltBitsDisplay();
                        saveGame();
                    }
                    if (data.cards.length === 0) cardList.innerHTML = '<p style="color:#888;">No tienes tarjetas vinculadas.</p>';
                }
            } catch (e) {
                cardList.innerHTML = '<p style="color:red;">Error al cargar datos</p>';
            }
        }

        async function confirmOpPayment(cardId, currentBalance) {
            if (currentBalance < oceanPayState.amount) {
                alert('Saldo insuficiente en esta tarjeta.');
                return;
            }

            if (!confirm(`¿Confirmar pago de ${oceanPayState.amount} VoltBits?`)) return;

            document.getElementById('oceanPayIntegratedModal').style.display = 'none';
            document.getElementById('oceanPayLoader').style.display = 'flex';

            try {
                const res = await fetch('https://owsdatabase.onrender.com/ocean-pay/currency/change', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${oceanPayState.token}`
                    },
                    body: JSON.stringify({
                        cardId: cardId,
                        amount: -oceanPayState.amount,
                        currency: 'voltbit',
                        concepto: oceanPayState.concept,
                        origen: 'Velocity Surge'
                    })
                });
                const data = await res.json();
                if (res.status === 401 || res.status === 403) {
                    clearOceanPaySession(true);
                    updateOceanPayUI();
                    return;
                }
                if (data.success) {
                    if (oceanPayState.onSuccess) oceanPayState.onSuccess();
                    showNotification('¡PAGO EXITOSO!');
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (e) {
                alert('Error de conexión');
            } finally {
                document.getElementById('oceanPayLoader').style.display = 'none';
                closeOceanPay();
            }
        }

        window.closeOceanPay = function () {
            const modal = document.getElementById('oceanPayIntegratedModal');
            if (modal) modal.style.display = 'none';
        };
    

// Ultra Patch Core (inlined)
(function velocitySurgeCorePatch() {
        if (window.__velocitySurgeCorePatchApplied) return;
        window.__velocitySurgeCorePatchApplied = true;

        const SAVE_SCHEMA_VERSION = 3;
        const PRIMARY_SAVE_KEY = 'velocity_surge_save';
        const BACKUP_SAVE_KEY = 'velocity_surge_save_backup';
        const ELEMENTAL_EVENT_ID = 'elemental_convergence';
        const FUTURE_EVENT_ID = 'velocity_classics';
        const ELEMENTAL_EVENT_RACERS = [
            'elemental_aqua',
            'elemental_pyre',
            'elemental_gale',
            'elemental_terra',
            'elemental_plasma',
            'elemental_crystal',
            'elemental_thunder'
        ];

        window.__VS_EVENT_CONSTANTS = {
            SAVE_SCHEMA_VERSION,
            ELEMENTAL_EVENT_ID,
            FUTURE_EVENT_ID,
            ELEMENTAL_EVENT_RACERS
        };

        const EXTRA_CHARACTERS = {
            neutron_core: {
                name: 'NEUTRON CORE', rarity: 'common', color: '#8fa3ad', secondaryColor: '#dde9ee',
                effect: 'Nucleo estable', stats: { speed: 5.2, accel: 6, handling: 7.2, weight: 8.5 },
                projectile: { name: 'Pulso Compacto', effect: 'knockback' },
                turbo: { name: 'Estabilizador', boost: 1.6 },
                trap: { name: 'Masa Inercial', effect: 'slow', duration: 2.2 }, unlocked: false, price: 320
            },
            bone_runner: {
                name: 'BONE RUNNER', rarity: 'common', color: '#dfd6cf', secondaryColor: '#8d8177',
                effect: 'Resistencia osea', stats: { speed: 5.2, accel: 6.4, handling: 7.3, weight: 8.8 },
                projectile: { name: 'Fragmento Oseo', effect: 'bone_swing' },
                turbo: { name: 'Paso Seco', boost: 1.65 },
                trap: { name: 'Monticulo', effect: 'bone_pile_target', duration: 2.5 }, unlocked: false, price: 260
            },
            mist_runner: {
                name: 'MIST RUNNER', rarity: 'common', color: '#bec8d2', secondaryColor: '#607182',
                effect: 'Niebla tactica', stats: { speed: 6.1, accel: 7, handling: 9, weight: 3.5 },
                projectile: { name: 'Rastro Bruma', effect: 'mist_air_trail' },
                turbo: { name: 'Corriente Fria', boost: 1.85, effect: 'cloud_path_turbo' },
                trap: { name: 'Mina Vapor', effect: 'tornado_trap_mine', duration: 3 }, unlocked: false, price: 290
            },
            leaf_runner: {
                name: 'LEAF RUNNER', rarity: 'common', color: '#85c64f', secondaryColor: '#325f1d',
                effect: 'Agilidad vegetal', stats: { speed: 5.3, accel: 8.2, handling: 9, weight: 3.4 },
                projectile: { name: 'Hoja Cuchilla', effect: 'leaf_trail_active' },
                turbo: { name: 'Brisa Verde', boost: 1.75 },
                trap: { name: 'Raices Vivas', effect: 'vines_trap', duration: 3.2 }, unlocked: false, price: 290
            },
            elemental_aqua: {
                name: 'AQUA ELEMENTAL', rarity: 'rare', color: '#20d0ff', secondaryColor: '#7cf1ff',
                effect: 'Flujo absoluto', stats: { speed: 7.9, accel: 7.1, handling: 8.8, weight: 6 },
                projectile: { name: 'Orbe de Marea', effect: 'progressive_bubble' },
                turbo: { name: 'Corriente Abisal', boost: 2.35, effect: 'water_tornado' },
                trap: { name: 'Velo Tsunami', effect: 'tsunami_trap', duration: 2.3 }, unlocked: false, price: 1900
            },
            elemental_pyre: {
                name: 'PYRE ELEMENTAL', rarity: 'rare', color: '#ff5b2e', secondaryColor: '#ffd180',
                effect: 'Combustion viva', stats: { speed: 8.2, accel: 7.8, handling: 7.2, weight: 6.8 },
                projectile: { name: 'Lanza Ignea', effect: 'burn' },
                turbo: { name: 'Ignicion Total', boost: 2.45, effect: 'fire_trail' },
                trap: { name: 'Ceniza Letal', effect: 'ash_trap', duration: 2.8 }, unlocked: false, price: 1900
            },
            elemental_gale: {
                name: 'GALE ELEMENTAL', rarity: 'rare', color: '#c9f0ff', secondaryColor: '#8dd8ff',
                effect: 'Viento cortante', stats: { speed: 8.3, accel: 8.7, handling: 9.6, weight: 2.8 },
                projectile: { name: 'Lamina de Viento', effect: 'mist_trail' },
                turbo: { name: 'Jet de Ciclon', boost: 2.3, effect: 'cloud_path' },
                trap: { name: 'Nudo de Aire', effect: 'tornado_trap_mine', duration: 2.8 }, unlocked: false, price: 2100
            },
            elemental_terra: {
                name: 'TERRA ELEMENTAL', rarity: 'rare', color: '#b18b62', secondaryColor: '#e2c298',
                effect: 'Masa tectonica', stats: { speed: 5.5, accel: 5.9, handling: 5.1, weight: 13.8 },
                projectile: { name: 'Roca Prismatica', effect: 'knockback' },
                turbo: { name: 'Pulso Sismico', boost: 1.9, effect: 'rock_collision' },
                trap: { name: 'Falla de Tierra', effect: 'rock_path', duration: 2.6 }, unlocked: false, price: 2100
            },
            elemental_plasma: {
                name: 'PLASMA ELEMENTAL', rarity: 'epic', color: '#ffea00', secondaryColor: '#ff4ff2',
                effect: 'Carga inestable', stats: { speed: 8.8, accel: 9.1, handling: 7.9, weight: 4.5 },
                projectile: { name: 'Arco de Plasma', effect: 'electric_beam_charge' },
                turbo: { name: 'Sobrecarga', boost: 2.55, effect: 'electric_dash' },
                trap: { name: 'Mina Pulsar', effect: 'electric_mines_triple', duration: 2.5 }, unlocked: false, price: 3300
            },
            elemental_crystal: {
                name: 'CRYSTAL ELEMENTAL', rarity: 'epic', color: '#8ff7ff', secondaryColor: '#6f77ff',
                effect: 'Resonancia de cuarzo', stats: { speed: 7.8, accel: 8.4, handling: 8.6, weight: 6.2 },
                projectile: { name: 'Lanza Prisma', effect: 'storm_seeker_new' },
                turbo: { name: 'Fase Radiante', boost: 2.35, effect: 'sonic_overload' },
                trap: { name: 'Nido Prismático', effect: 'storm_block', duration: 2.4 }, unlocked: false, price: 3400
            },
            elemental_thunder: {
                name: 'THUNDER ELEMENTAL', rarity: 'epic', color: '#ffe95c', secondaryColor: '#5ac8ff',
                effect: 'Ruptura electrica', stats: { speed: 8.7, accel: 9.3, handling: 7.8, weight: 5.1 },
                projectile: { name: 'Rayo Fractal', effect: 'chain_lightning' },
                turbo: { name: 'Impulso de Tormenta', boost: 2.5, effect: 'storm_surge' },
                trap: { name: 'Trampa de Relampagos', effect: 'triple_storm', duration: 2.2 }, unlocked: false, price: 3600
            }
        };

        Object.entries(EXTRA_CHARACTERS).forEach(([id, def]) => {
            if (!CHARACTERS[id]) CHARACTERS[id] = def;
        });

        if (!MODES.SANDBOX) {
            MODES.SANDBOX = {
                name: 'SANDBOX',
                desc: 'Prueba libre. Puedes desconectar y reconectar corredor/bots en plena carrera.'
            };
        }

        function migrateGameData(rawData) {
            const data = { ...rawData };
            const ensureArray = (v) => Array.isArray(v) ? v : [];
            const ensureChestInventory = (v) => (v && typeof v === 'object') ? v : {};

            data.saveVersion = Number(data.saveVersion || 0);
            data.unlockedCharacters = ensureArray(data.unlockedCharacters);
            data.completedMissions = ensureArray(data.completedMissions);
            data.purchasedOffers = ensureArray(data.purchasedOffers);
            data.characterLevels = (data.characterLevels && typeof data.characterLevels === 'object') ? data.characterLevels : { blaze: 1 };
            data.characterCards = (data.characterCards && typeof data.characterCards === 'object') ? data.characterCards : {};
            data.selectedMode = String(data.selectedMode || 'CLASSIC').toUpperCase();

            if (!MODES[data.selectedMode]) data.selectedMode = 'CLASSIC';
            if (!CHARACTERS[data.selectedCharacter]) data.selectedCharacter = 'blaze';
            if (!MAPS[data.selectedMap]) data.selectedMap = 'neon_city';
            if (!data.unlockedCharacters.includes('blaze')) data.unlockedCharacters.unshift('blaze');
            if (!data.characterLevels.blaze) data.characterLevels.blaze = 1;
            if (!data.eventTargetRacer || !CHARACTERS[data.eventTargetRacer]) data.eventTargetRacer = ELEMENTAL_EVENT_RACERS[0];
            const baseChestInventory = {
                electric: 0,
                fortune: 0,
                iron: 0,
                gold: 0,
                diamond: 0,
                cosmic: 0
            };
            const rawInventory = ensureChestInventory(data.chestInventory);
            Object.keys(rawInventory).forEach(key => {
                const n = Math.floor(Number(rawInventory[key]) || 0);
                baseChestInventory[key] = Math.max(0, n);
            });
            data.chestInventory = baseChestInventory;
            data.saveVersion = SAVE_SCHEMA_VERSION;
            return data;
        }

        saveGame = function saveGamePatched() {
            const payload = migrateGameData({
                ...GameData,
                saveVersion: SAVE_SCHEMA_VERSION,
                updatedAt: new Date().toISOString()
            });
            const serialized = JSON.stringify(payload);
            localStorage.setItem(PRIMARY_SAVE_KEY, serialized);
            localStorage.setItem(BACKUP_SAVE_KEY, serialized);
        };

        loadGame = function loadGamePatched() {
            const saved = localStorage.getItem(PRIMARY_SAVE_KEY);
            const backup = localStorage.getItem(BACKUP_SAVE_KEY);
            if (!saved && !backup) return;
            try {
                const parsed = JSON.parse(saved || backup);
                const migrated = migrateGameData(parsed);
                GameData = { ...GameData, ...migrated };
                const reserialized = JSON.stringify(migrated);
                localStorage.setItem(PRIMARY_SAVE_KEY, reserialized);
                localStorage.setItem(BACKUP_SAVE_KEY, reserialized);
            } catch (err) {
                if (backup && backup !== saved) {
                    try {
                        const parsedBackup = JSON.parse(backup);
                        const migratedBackup = migrateGameData(parsedBackup);
                        GameData = { ...GameData, ...migratedBackup };
                        const fixed = JSON.stringify(migratedBackup);
                        localStorage.setItem(PRIMARY_SAVE_KEY, fixed);
                        localStorage.setItem(BACKUP_SAVE_KEY, fixed);
                        return;
                    } catch (_) { }
                }
                console.warn('Save migration failed:', err);
            }
        };

        loadGame();

        window.__VS_REBUILD_EVENTS = function rebuildEventCalendar() {
            const now = new Date();
            const activeStart = new Date(now);
            activeStart.setDate(now.getDate() - 1);
            activeStart.setHours(0, 0, 0, 0);

            const activeEnd = new Date(now);
            activeEnd.setDate(now.getDate() + 6);
            activeEnd.setHours(23, 59, 59, 999);

            const futureStart = new Date(activeEnd);
            futureStart.setDate(activeEnd.getDate() + 2);
            futureStart.setHours(0, 0, 0, 0);

            const futureEnd = new Date(futureStart);
            futureEnd.setDate(futureStart.getDate() + 7);
            futureEnd.setHours(23, 59, 59, 999);

            EVENTS_CALENDAR.length = 0;
            EVENTS_CALENDAR.push(
                {
                    id: ELEMENTAL_EVENT_ID,
                    name: 'ELEMENTAL CONVERGENCE',
                    shortName: 'ELEMENTALES',
                    color: '#00f7ff',
                    bgGradient: 'linear-gradient(135deg,#0a1734 0%,#1a0f2d 45%,#1e1408 100%)',
                    startDate: activeStart,
                    endDate: activeEnd,
                    featuredRacer: 'elemental_plasma',
                    racers: ELEMENTAL_EVENT_RACERS,
                    description: 'Evento activo. Elige un corredor elemental y sus cofres llegaran en tus misiones.',
                    mapOverride: 'energy_nexus'
                },
                {
                    id: FUTURE_EVENT_ID,
                    name: 'GLITCH PROTOCOL REPLAY',
                    shortName: 'GLITCH REPLAY',
                    color: '#7dff8a',
                    bgGradient: 'linear-gradient(135deg,#071a0d 0%,#1a0f2d 100%)',
                    startDate: futureStart,
                    endDate: futureEnd,
                    featuredRacer: 'glitch',
                    racers: ['glitch', 'elemental_plasma', 'pulse'],
                    description: 'Repeticion de evento: vuelve GLITCH con recompensas remix para nuevos jugadores.',
                    mapOverride: 'glitch_void'
                }
            );

            EVENT_OFFERS[ELEMENTAL_EVENT_ID] = [
                {
                    id: 'elemental_pack_1',
                    name: 'PACK ELEMENTAL INICIAL',
                    desc: 'Desbloquea un corredor elemental elegido + 20 tarjetas.',
                    price: 6800,
                    type: 'early',
                    gives: { character: 'elemental_pyre', cards: 20, bits: 0 },
                    pool: ELEMENTAL_EVENT_RACERS.slice(),
                    badgeText: 'NUEVO',
                    badgeColor: '#00f7ff',
                    chestType: null
                },
                {
                    id: 'elemental_pack_2',
                    name: 'ULTIMA CORRIENTE',
                    desc: 'Cofre elemental premium + 45 tarjetas del corredor objetivo.',
                    price: 9800,
                    originalPrice: 12400,
                    type: 'lastchance',
                    lastChanceDays: 3,
                    gives: { character: 'elemental_aqua', cards: 45, bits: 300 },
                    badgeText: '-21%',
                    badgeColor: '#ffd166',
                    chestType: 'event_chest_elemental_aqua'
                }
            ];

        EVENT_OFFERS[FUTURE_EVENT_ID] = [
            {
                id: 'glitch_replay_pack_1',
                name: 'REPLAY PROTOCOL',
                desc: 'Pack de repeticion: mejora a GLITCH o PLASMA para el evento replay.',
                price: 5900,
                type: 'early',
                gives: { character: 'glitch', cards: 25, bits: 350 },
                badgeText: 'REPLAY',
                badgeColor: '#7dff8a',
                chestType: null
            }
        ];
        };

        window.__VS_REBUILD_EVENTS();

        window.__VS_GET_CURRENT_EVENT = function getCurrentEvent(now = new Date()) {
            return EVENTS_CALENDAR.find(e => now >= e.startDate && now <= e.endDate) || null;
        };

        window.__VS_GET_NEXT_EVENT = function getNextEvent(now = new Date()) {
            return EVENTS_CALENDAR.filter(e => e.startDate > now).sort((a, b) => a.startDate - b.startDate)[0] || null;
        };

        applySeasonalEvents = function applySeasonalEventsPatched() {
            const evt = window.__VS_GET_CURRENT_EVENT();
            activeEvent = evt ? evt.id : null;
        };
        applySeasonalEvents();

        const baseDrawChestModel = drawChestModel;
        drawChestModel = function drawChestModelPatched(ctx, type, x, y, scale = 1) {
            const custom = ['iron', 'gold', 'diamond', 'cosmic'];
            if (custom.includes(type) || String(type).startsWith('event_chest_')) {
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(scale, scale);
                let a = '#00e5ff';
                let b = '#1a1a2a';
                if (type === 'iron') { a = '#b0bec5'; b = '#37474f'; }
                if (type === 'gold') { a = '#ffd54f'; b = '#5d3b00'; }
                if (type === 'diamond') { a = '#80deea'; b = '#263238'; }
                if (type === 'cosmic') { a = '#d500f9'; b = '#100019'; }
                if (String(type).startsWith('event_chest_')) {
                    const racerId = String(type).replace('event_chest_', '');
                    const char = CHARACTERS[racerId];
                    if (char) {
                        a = char.color;
                        b = char.secondaryColor || '#111';
                    }
                }
                const grd = ctx.createLinearGradient(-24, -25, 26, 28);
                grd.addColorStop(0, a);
                grd.addColorStop(1, b);
                ctx.fillStyle = '#111';
                ctx.fillRect(-24, -12, 48, 34);
                ctx.fillStyle = grd;
                ctx.fillRect(-24, -12, 48, 34);
                ctx.strokeStyle = '#fff';
                ctx.globalAlpha = 0.25;
                ctx.strokeRect(-24, -12, 48, 34);
                ctx.globalAlpha = 1;
                ctx.fillStyle = b;
                ctx.beginPath();
                ctx.moveTo(-26, -12);
                ctx.lineTo(26, -12);
                ctx.lineTo(20, -30);
                ctx.lineTo(-20, -30);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = a;
                ctx.lineWidth = 2.2;
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, -5, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                return;
            }
            return baseDrawChestModel(ctx, type, x, y, scale);
        };

        const baseProcessChestReward = processChestReward;
        processChestReward = function processChestRewardPatched() {
            if (currentChestData && String(currentChestData.type).startsWith('event_chest_')) {
                const rewardEl = document.getElementById('chestReward');
                const mission = currentChestData.missionReward || {};
                const racerId = String(currentChestData.type).replace('event_chest_', '');
                const racer = CHARACTERS[racerId] || CHARACTERS[GameData.eventTargetRacer];
                const cards = Math.max(4, Number(mission.rewardCards || 8));
                const bits = Math.floor(80 + Math.random() * 170);
                const bitsGranted = grantVoltBits(bits, true, `Cofre de evento: ${racer?.name || 'Evento'}`) ? bits : 0;

                saveGame();
                updateVoltBitsDisplay();

                rewardEl.innerHTML = `
                <div style="margin-bottom:8px;color:${racer?.color || '#fff'};font-family:Orbitron;">${racer?.name || 'CORREDOR'} · COFRE</div>
                <div style="margin-bottom:6px;">+${cards} tarjetas</div>
                ${bitsGranted > 0
                        ? `<div style="display:flex;align-items:center;justify-content:center;gap:8px;">+${bitsGranted} <canvas id="rewardCoin" width="20" height="20"></canvas></div>`
                        : `<div style="font-size:0.8rem;opacity:0.85;">Vincula Ocean Pay para reclamar +${bits} VoltBits</div>`
                    }
            `;
                if (bitsGranted > 0) {
                    setTimeout(() => {
                        const icon = document.getElementById('rewardCoin');
                        if (icon) renderRacerModel(icon.getContext('2d'), 'currency_voltbit', 10, 10, 0.8, { color: '#00e5ff', secondaryColor: '#8effff' });
                    }, 0);
                }
                if (racerId && CHARACTERS[racerId] && typeof animateCardRewardProgress === 'function') {
                    const closeBtn = document.getElementById('chestCloseBtn');
                    closeBtn.style.display = 'none';
                    animateCardRewardProgress([{ id: racerId, count: cards }], rewardEl).finally(() => {
                        closeBtn.style.display = 'inline-block';
                        if (typeof updateChestContinueLabel === 'function') updateChestContinueLabel();
                    });
                } else {
                    document.getElementById('chestCloseBtn').style.display = 'inline-block';
                    if (typeof updateChestContinueLabel === 'function') updateChestContinueLabel();
                }
                rewardEl.classList.add('show');
                return;
            }
            return baseProcessChestReward();
        };

        const baseShowShop = showShop;
        showShop = function showShopPatched() {
            baseShowShop();
            setTimeout(() => {
                const ids = [
                    ['iconChestElectric', 'electric'],
                    ['iconChestFortune', 'fortune'],
                    ['iconChestIron', 'iron'],
                    ['iconChestGold', 'gold'],
                    ['iconChestDiamond', 'diamond'],
                    ['iconChestCosmic', 'cosmic']
                ];
                ids.forEach(([id, chestType]) => {
                    const c = document.getElementById(id);
                    if (!c) return;
                    const cctx = c.getContext('2d');
                    cctx.clearRect(0, 0, c.width, c.height);
                    drawChestModel(cctx, chestType, 60, 60, 1.5);
                });
                for (let i = 1; i <= 6; i++) {
                    const p = document.getElementById(`priceIcon${i}`);
                    if (!p) continue;
                    const pctx = p.getContext('2d');
                    pctx.clearRect(0, 0, p.width, p.height);
                    renderRacerModel(pctx, 'currency_voltbit', 12, 12, 0.8, { color: '#00e5ff', secondaryColor: '#8effff' });
                }
            }, 120);
        };

        async function fetchWithTimeoutAndRetry(url, options = {}, retries = 2, timeoutMs = 12000) {
            const exec = async () => {
                const ctrl = new AbortController();
                const timeout = setTimeout(() => ctrl.abort(), timeoutMs);
                try {
                    const res = await fetch(url, { ...options, signal: ctrl.signal });
                    return res;
                } finally {
                    clearTimeout(timeout);
                }
            };

            let lastErr = null;
            for (let i = 0; i <= retries; i++) {
                try {
                    const res = await exec();
                    if (res.ok) return res;
                    if (res.status >= 500 && i < retries) continue;
                    return res;
                } catch (e) {
                    lastErr = e;
                    if (i >= retries) throw e;
                }
            }
            throw lastErr || new Error('Network error');
        }

        const VS_PENDING_VOLTBIT_KEY = 'velocity_surge_pending_voltbit_credits_v1';
        const voltbitSyncState = {
            flushing: false,
            timer: null,
            lastFlushOkAt: 0
        };

        function readPendingVoltBitCredits() {
            try {
                const raw = localStorage.getItem(VS_PENDING_VOLTBIT_KEY);
                if (!raw) return [];
                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) return [];
                return parsed
                    .map(entry => ({
                        id: String(entry.id || `${Date.now()}_${Math.random().toString(16).slice(2, 8)}`),
                        amount: Math.max(0, Math.floor(Number(entry.amount) || 0)),
                        source: String(entry.source || 'Recompensa'),
                        createdAt: Number(entry.createdAt || Date.now())
                    }))
                    .filter(entry => entry.amount > 0);
            } catch (_) {
                return [];
            }
        }

        function writePendingVoltBitCredits(list) {
            try {
                if (!Array.isArray(list) || list.length === 0) {
                    localStorage.removeItem(VS_PENDING_VOLTBIT_KEY);
                    return;
                }
                localStorage.setItem(VS_PENDING_VOLTBIT_KEY, JSON.stringify(list));
            } catch (_) { }
        }

        function getPendingVoltBitCreditsTotal() {
            return readPendingVoltBitCredits().reduce((acc, item) => acc + (item.amount || 0), 0);
        }

        function queueVoltBitCredit(amount, source = 'Recompensa') {
            const safeAmount = Math.max(0, Math.floor(Number(amount) || 0));
            if (!safeAmount) return;
            const queue = readPendingVoltBitCredits();
            queue.push({
                id: `${Date.now()}_${Math.random().toString(16).slice(2, 8)}`,
                amount: safeAmount,
                source: String(source || 'Recompensa'),
                createdAt: Date.now()
            });
            writePendingVoltBitCredits(queue);
        }

        async function flushPendingVoltBitCredits({ silent = true } = {}) {
            if (voltbitSyncState.flushing) return false;
            if (!oceanPayState || !oceanPayState.token || oceanPayState.linked !== true) return false;
            if (typeof navigator !== 'undefined' && navigator.onLine === false) return false;

            let queue = readPendingVoltBitCredits();
            if (queue.length === 0) return true;

            voltbitSyncState.flushing = true;
            try {
                while (queue.length > 0) {
                    const next = queue[0];
                    const res = await fetchWithTimeoutAndRetry('https://owsdatabase.onrender.com/ocean-pay/currency/change', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${oceanPayState.token}`
                        },
                        body: JSON.stringify({
                            amount: next.amount,
                            currency: 'voltbit',
                            concepto: `${next.source} (Sync)`,
                            origen: 'Velocity Surge'
                        })
                    }, 1, 15000);

                    let data = {};
                    try { data = await res.json(); } catch (_) { }

                    if (res.status === 401 || res.status === 403) {
                        clearOceanPaySession(true);
                        break;
                    }
                    if (!res.ok || !data.success) {
                        if (!silent && typeof showNotification === 'function') {
                            showNotification('No se pudo sincronizar saldo con Ocean Pay. Se reintentara automaticamente.');
                        }
                        break;
                    }

                    queue.shift();
                    writePendingVoltBitCredits(queue);
                    oceanPayState.lastSyncAt = Date.now();
                }

                if (queue.length === 0) {
                    voltbitSyncState.lastFlushOkAt = Date.now();
                    return true;
                }
                return false;
            } catch (_) {
                return false;
            } finally {
                voltbitSyncState.flushing = false;
            }
        }

        function scheduleVoltBitCreditSync(delayMs = 900) {
            if (voltbitSyncState.timer) clearTimeout(voltbitSyncState.timer);
            voltbitSyncState.timer = setTimeout(() => {
                flushPendingVoltBitCredits({ silent: true });
            }, Math.max(150, Number(delayMs) || 900));
        }

        grantVoltBits = function grantVoltBitsPatched(amount, showNotice = true, source = 'Recompensa de carrera') {
            const safeAmount = Math.max(0, Math.floor(Number(amount) || 0));
            if (!safeAmount) return false;
            if (!canUseVoltBits(showNotice)) return false;
            GameData.voltBits += safeAmount;
            queueVoltBitCredit(safeAmount, source);
            saveGame();
            updateVoltBitsDisplay();
            scheduleVoltBitCreditSync(600);
            return true;
        };

        syncOceanPayLinkState = async function syncOceanPayLinkStatePatched() {
            if (!oceanPayState.token) {
                oceanPayState.linked = false;
                updateVoltBitsDisplay();
                return false;
            }
            const wasLinked = oceanPayState.linked;
            const cardList = document.getElementById('opCardList');
            if (cardList) {
                cardList.innerHTML = '<p style="color:var(--accent-cyan); font-family:Orbitron; font-size:0.8rem;">VALIDANDO SESION...</p>';
            }
            try {
                const res = await fetchWithTimeoutAndRetry('https://owsdatabase.onrender.com/ocean-pay/me', {
                    headers: { 'Authorization': `Bearer ${oceanPayState.token}` }
                }, 1, 12000);
                const data = await res.json();
                if (res.status === 401 || res.status === 403) {
                    clearOceanPaySession(true);
                    return false;
                }
                if (!res.ok || !Array.isArray(data.cards)) {
                    oceanPayState.linked = wasLinked;
                    updateVoltBitsDisplay();
                    return wasLinked;
                }

                if (data.user && typeof data.user === 'object') {
                    oceanPayState.user = data.user;
                    localStorage.setItem('opUser', JSON.stringify(data.user));
                }

                oceanPayState.linked = true;
                oceanPayState.lastSyncAt = Date.now();
                localStorage.setItem('opLinked', '1');

                await flushPendingVoltBitCredits({ silent: true });

                const primary = data.cards.find(c => c.is_primary) || data.cards[0];
                const serverBalance = Math.floor(primary?.balances?.voltbit || 0);
                const pendingTotal = getPendingVoltBitCreditsTotal();
                GameData.voltBits = pendingTotal > 0
                    ? Math.max(Math.floor(GameData.voltBits || 0), serverBalance + pendingTotal)
                    : serverBalance;
                saveGame();
                updateVoltBitsDisplay();
                return true;
            } catch (_) {
                oceanPayState.linked = wasLinked;
                updateVoltBitsDisplay();
                return wasLinked;
            }
        };

        if (!window.__vsVoltBitSyncListenersAttached) {
            window.__vsVoltBitSyncListenersAttached = true;
            window.addEventListener('online', () => scheduleVoltBitCreditSync(200));
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') scheduleVoltBitCreditSync(300);
            });
        }

        opLogin = async function opLoginPatched() {
            const user = document.getElementById('opUser').value.trim();
            const pass = document.getElementById('opPass').value;
            const btn = document.getElementById('opLoginBtn');
            const msg = document.getElementById('opMsg');
            if (!user || !pass) { msg.textContent = 'Completa usuario y contrasena.'; return; }
            btn.disabled = true;
            btn.textContent = 'CONECTANDO...';
            msg.textContent = '';
            try {
                const res = await fetchWithTimeoutAndRetry('https://owsdatabase.onrender.com/ocean-pay/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: user, password: pass })
                }, 1, 12000);
                const data = await res.json();
                if (!res.ok || !data.success) {
                    msg.textContent = data.error || `Error de acceso (${res.status})`;
                    return;
                }
                oceanPayState.token = data.token;
                oceanPayState.user = data.user;
                oceanPayState.linked = true;
                localStorage.setItem('opToken', data.token);
                localStorage.setItem('opUser', JSON.stringify(data.user));
                localStorage.setItem('opLinked', '1');
                updateOceanPayUI();
                syncOceanPayLinkState();
            } catch (e) {
                msg.textContent = navigator.onLine ? 'No se pudo conectar con Ocean Pay.' : 'Sin conexion a internet.';
            } finally {
                btn.disabled = false;
                btn.textContent = 'ENTRAR';
            }
        };

        loadOceanPayCards = async function loadOceanPayCardsPatched() {
            const cardList = document.getElementById('opCardList');
            const wasLinked = oceanPayState.linked;
            if (!oceanPayState.token) {
                oceanPayState.linked = false;
                updateVoltBitsDisplay();
                cardList.innerHTML = '<p style="color:#888;">Inicia sesion para ver tu saldo.</p>';
                return;
            }
            cardList.innerHTML = '<p style="color:var(--accent-cyan); font-family:Orbitron; font-size:0.8rem;">CARGANDO TARJETAS...</p>';
            try {
                const res = await fetchWithTimeoutAndRetry('https://owsdatabase.onrender.com/ocean-pay/me', {
                    headers: { 'Authorization': `Bearer ${oceanPayState.token}` }
                }, 1, 12000);
                const data = await res.json();
                if (res.status === 401 || res.status === 403) {
                    clearOceanPaySession(true);
                    updateOceanPayUI();
                    return;
                }
                if (!res.ok) {
                    cardList.innerHTML = `<p style="color:#ff8080;">Error al cargar tarjetas (${res.status})</p>`;
                    oceanPayState.linked = wasLinked;
                    updateVoltBitsDisplay();
                    return;
                }
                if (!Array.isArray(data.cards) || data.cards.length === 0) {
                    oceanPayState.linked = true;
                    oceanPayState.lastSyncAt = Date.now();
                    updateVoltBitsDisplay();
                    cardList.innerHTML = '<p style="color:#888;">No tienes tarjetas vinculadas.</p>';
                    return;
                }
                if (data.user && typeof data.user === 'object') {
                    oceanPayState.user = data.user;
                    localStorage.setItem('opUser', JSON.stringify(data.user));
                }
                oceanPayState.linked = true;
                oceanPayState.lastSyncAt = Date.now();
                localStorage.setItem('opLinked', '1');
                await flushPendingVoltBitCredits({ silent: true });
                cardList.innerHTML = '';
                let pendingTotal = getPendingVoltBitCreditsTotal();
                let hasPrimary = false;
                data.cards.forEach(card => {
                    const div = document.createElement('div');
                    div.className = 'op-card-item';
                    const balance = Math.floor(card.balances?.voltbit || 0);
                    if (card.is_primary) {
                        hasPrimary = true;
                        GameData.voltBits = pendingTotal > 0
                            ? Math.max(Math.floor(GameData.voltBits || 0), balance + pendingTotal)
                            : balance;
                        updateVoltBitsDisplay();
                        saveGame();
                    }
                    div.innerHTML = `
                    <div style="font-weight:bold; color:white;">${card.card_name} ${card.is_primary ? '<span style="color:var(--accent-gold); font-size:0.6rem;">PRINCIPAL</span>' : ''}</div>
                    <div style="font-size:0.8rem; color:var(--accent-cyan);">Saldo: ${balance} VoltBits</div>
                    <div style="font-size:0.75rem; color:#888;">**** **** **** ${card.card_number.slice(-4)}</div>
                `;
                    div.onclick = () => confirmOpPayment(card.id, balance);
                    cardList.appendChild(div);
                });
                if (!hasPrimary && data.cards[0]) {
                    const firstBalance = Math.floor(data.cards[0].balances?.voltbit || 0);
                    GameData.voltBits = pendingTotal > 0
                        ? Math.max(Math.floor(GameData.voltBits || 0), firstBalance + pendingTotal)
                        : firstBalance;
                    updateVoltBitsDisplay();
                    saveGame();
                }
            } catch (e) {
                oceanPayState.linked = wasLinked;
                updateVoltBitsDisplay();
                cardList.innerHTML = navigator.onLine
                    ? '<p style="color:#ff8080;">No se pudo conectar con Ocean Pay.</p>'
                    : '<p style="color:#ff8080;">Sin conexion.</p>';
            }
        };

        confirmOpPayment = async function confirmOpPaymentPatched(cardId, currentBalance) {
            if (currentBalance < oceanPayState.amount) {
                alert('Saldo insuficiente en esta tarjeta.');
                return;
            }
            if (!confirm(`¿Confirmar pago de ${oceanPayState.amount} VoltBits?`)) return;
            document.getElementById('oceanPayIntegratedModal').style.display = 'none';
            document.getElementById('oceanPayLoader').style.display = 'flex';
            try {
                const res = await fetchWithTimeoutAndRetry('https://owsdatabase.onrender.com/ocean-pay/currency/change', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${oceanPayState.token}`
                    },
                    body: JSON.stringify({
                        cardId: cardId,
                        amount: -oceanPayState.amount,
                        currency: 'voltbit',
                        concepto: oceanPayState.concept,
                        origen: 'Velocity Surge'
                    })
                }, 2, 15000);
                const data = await res.json();
                if (res.status === 401 || res.status === 403) {
                    clearOceanPaySession(true);
                    updateOceanPayUI();
                    return;
                }
                if (!res.ok || !data.success) {
                    alert('Error de pago: ' + (data.error || `HTTP ${res.status}`));
                    return;
                }
                if (oceanPayState.onSuccess) oceanPayState.onSuccess();
                showNotification('¡PAGO EXITOSO!');
            } catch (e) {
                alert(navigator.onLine ? 'Error de conexion con Ocean Pay.' : 'Sin conexion a internet.');
            } finally {
                document.getElementById('oceanPayLoader').style.display = 'none';
                closeOceanPay();
            }
        };
    })();


// Ultra Patch UI (inlined)
(function velocitySurgeUiPatch() {
        if (window.__velocitySurgeUiPatchApplied) return;
        window.__velocitySurgeUiPatchApplied = true;

        const constants = window.__VS_EVENT_CONSTANTS || {};
        const ELEMENTAL_EVENT_RACERS = constants.ELEMENTAL_EVENT_RACERS || ['elemental_aqua'];

        function ensureGarageLayout() {
            const root = document.getElementById('characterSelect');
            const grid = document.getElementById('charactersGrid');
            if (!root || !grid || document.getElementById('garageLayout')) return;

            const layout = document.createElement('div');
            layout.id = 'garageLayout';
            layout.className = 'garage-layout';

            const roster = document.createElement('div');
            roster.className = 'garage-roster';
            roster.appendChild(grid);

            const detail = document.createElement('div');
            detail.id = 'garageDetail';
            detail.className = 'garage-detail';
            detail.innerHTML = '<p style="opacity:0.7">Selecciona un corredor para ver detalles.</p>';

            layout.appendChild(roster);
            layout.appendChild(detail);

            const startBtn = root.querySelector('.start-race-btn');
            if (startBtn) {
                root.insertBefore(layout, startBtn);
                startBtn.textContent = 'SIGUIENTE: MODOS';
                startBtn.onclick = showModeSelect;
            } else {
                root.appendChild(layout);
            }

            const modeLabel = Array.from(root.querySelectorAll('label')).find(l => l.textContent.includes('MODO'));
            if (modeLabel && modeLabel.parentElement) modeLabel.parentElement.style.display = 'none';
        }

        function renderGarageDetail(id) {
            const panel = document.getElementById('garageDetail');
            if (!panel) return;
            const char = CHARACTERS[id];
            if (!char) return;
            const unlocked = GameData.unlockedCharacters.includes(id);
            const lvl = GameData.characterLevels[id] || 1;
            const req = CARD_REQUIREMENTS[char.rarity] || 10;
            const owned = GameData.characterCards[id] || 0;
            const safeTip = (txt) => String(txt || '-').replace(/"/g, '&quot;');
            const countMilestonesReached = (level, milestones) => milestones.reduce((acc, m) => acc + (level >= m ? 1 : 0), 0);
            const abilitySlots = [
                {
                    id: 'projectile',
                    label: 'ATAQUE',
                    name: char.projectile?.name || 'Ataque',
                    effect: char.projectile?.effect || 'knockback',
                    color: char.color || '#8fd6ff',
                    milestones: [3, 6, 9]
                },
                {
                    id: 'turbo',
                    label: 'TURBO',
                    name: char.turbo?.name || 'Turbo',
                    effect: char.turbo?.effect || 'fire_trail',
                    color: char.secondaryColor || '#8effff',
                    milestones: [2, 5, 8]
                },
                {
                    id: 'trap',
                    label: 'TRAMPA',
                    name: char.trap?.name || 'Trampa',
                    effect: char.trap?.effect || 'slow',
                    color: '#ff9d7a',
                    milestones: [4, 7, 10]
                }
            ].map(slot => {
                const reached = unlocked ? countMilestonesReached(lvl, slot.milestones) : 0;
                const total = slot.milestones.length;
                const pct = Math.max(0, Math.min(100, (reached / Math.max(1, total)) * 100));
                return { ...slot, reached, total, pct };
            });
            const abilityHtml = abilitySlots.map(slot => `
                <div class="garage-skill-card">
                    <div class="garage-skill-icon-wrap" data-tip="${safeTip(slot.name)}">
                        <canvas id="garageSkillIcon-${id}-${slot.id}" class="garage-skill-icon" width="52" height="52"></canvas>
                    </div>
                    <div style="font-family:Orbitron;font-size:0.62rem;letter-spacing:0.6px;color:#dff6ff;opacity:0.9;">${slot.label}</div>
                    <div class="garage-skill-track">
                        <div class="garage-skill-fill" style="width:${slot.pct}%;background:linear-gradient(90deg, ${slot.color}, ${char.secondaryColor || '#b9e8ff'});"></div>
                    </div>
                    <div class="garage-skill-pct">${slot.reached}/${slot.total} mejoras</div>
                </div>
            `).join('');

            panel.innerHTML = `
            <div class="garage-detail-header">
                <div id="garageDetailAvatar" class="garage-detail-avatar"></div>
                <div>
                    <div style="font-family:Orbitron;font-size:1.25rem;color:${char.color};">${char.name}</div>
                    <div style="opacity:0.75;font-size:0.85rem;">${getRarityName(char.rarity)} ${unlocked ? `· LVL ${lvl}` : '· BLOQUEADO'}</div>
                    <div style="opacity:0.8;margin-top:5px;font-size:0.88rem;">${char.effect}</div>
                </div>
            </div>
            <div class="garage-info-grid">
                <div class="garage-info-block">
                    <div style="font-family:Orbitron;font-size:0.78rem;color:var(--accent-cyan);">ESTADISTICAS</div>
                    <div class="garage-ability">Velocidad: ${char.stats.speed}</div>
                    <div class="garage-ability">Aceleracion: ${char.stats.accel}</div>
                    <div class="garage-ability">Manejo: ${char.stats.handling}</div>
                    <div class="garage-ability">Peso: ${char.stats.weight}</div>
                </div>
            </div>
            <div class="garage-skills-panel">
                <div style="font-family:Orbitron;font-size:0.78rem;color:var(--accent-pink);margin-bottom:8px;">HABILIDADES</div>
                <div class="garage-skills-grid">
                    ${abilityHtml}
                </div>
            </div>
            <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;">
                ${unlocked ? `<button class="menu-btn" style="min-width:0;padding:8px 14px;" onclick="openUpgradeModal('${id}')">MEJORAR</button>` : ''}
                ${!unlocked && owned >= req ? `<button class="menu-btn" style="min-width:0;padding:8px 14px;border-color:#00ff88;color:#00ff88;" onclick="unlockCharacter('${id}')">DESBLOQUEAR</button>` : ''}
                ${!unlocked && owned < req ? `<div style="padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.05);font-size:0.82rem;">Tarjetas: ${owned}/${req}</div>` : ''}
            </div>
        `;

            setTimeout(() => {
                const host = document.getElementById('garageDetailAvatar');
                if (!host) return;
                host.innerHTML = '';
                const c = document.createElement('canvas');
                c.width = 100;
                c.height = 100;
                host.appendChild(c);
                renderRacerModel(c.getContext('2d'), id, 50, 50, 1.3, char);

                abilitySlots.forEach(slot => {
                    const sc = document.getElementById(`garageSkillIcon-${id}-${slot.id}`);
                    if (!sc) return;
                    try {
                        renderAbilityIcon(sc.getContext('2d'), slot.effect, slot.color, 52);
                    } catch (_) { }
                });
            }, 0);
        }

        function playSelectorUnlockRevealSfx() {
            try {
                if (typeof playCardRowCompleteSfx === 'function') playCardRowCompleteSfx('legendary');
                if (typeof playChestUnlockRunnerSfx === 'function') {
                    setTimeout(() => playChestUnlockRunnerSfx(), 70);
                }
            } catch (_) { }
        }

        function triggerPendingUnlockReveal() {
            const root = document.getElementById('characterSelect');
            if (!root || root.style.display !== 'flex') return;
            if (!Array.isArray(window.__VS_UNLOCK_QUEUE) || window.__VS_UNLOCK_QUEUE.length === 0) return;

            const pending = window.__VS_UNLOCK_QUEUE[0];
            if (!pending || !pending.id) return;
            const card = document.querySelector(`#charactersGrid .char-card[data-char-id="${pending.id}"]`);
            if (!card) return;

            window.__VS_UNLOCK_QUEUE.shift();
            card.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
            card.classList.add('unlock-reveal');

            const flash = document.createElement('div');
            flash.className = 'unlock-break-flash';
            card.appendChild(flash);
            const lock = document.createElement('div');
            lock.className = 'unlock-break-lock';
            lock.textContent = '🔒';
            card.appendChild(lock);

            GameData.selectedCharacter = pending.id;
            renderGarageDetail(pending.id);
            playSelectorUnlockRevealSfx();

            setTimeout(() => {
                flash.remove();
                lock.remove();
                card.classList.remove('unlock-reveal');
            }, 1250);

            if (window.__VS_UNLOCK_QUEUE.length > 0) {
                setTimeout(triggerPendingUnlockReveal, 1350);
            }
        }

        renderCharacters = function renderCharactersPatched() {
            ensureGarageLayout();
            const grid = document.getElementById('charactersGrid');
            if (!grid) return;
            grid.innerHTML = '';

            const rarityWeight = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4, mythic: 5 };
            const sortedChars = Object.entries(CHARACTERS).sort((a, b) => {
                const aw = rarityWeight[a[1].rarity] ?? 0;
                const bw = rarityWeight[b[1].rarity] ?? 0;
                if (aw !== bw) return aw - bw;
                return (a[1].price || 0) - (b[1].price || 0);
            });

            sortedChars.forEach(([id, char]) => {
                const unlocked = GameData.unlockedCharacters.includes(id);
                const selected = GameData.selectedCharacter === id;
                const lvl = GameData.characterLevels[id] || 1;
                const req = CARD_REQUIREMENTS[char.rarity] || 10;
                const owned = GameData.characterCards[id] || 0;
                const pct = Math.max(0, Math.min(100, (owned / Math.max(1, req)) * 100));

                const card = document.createElement('div');
                card.className = `char-card ${selected ? 'selected' : ''} ${unlocked ? '' : 'locked'}`;
                card.style.borderColor = selected ? char.color : 'transparent';
                card.dataset.charId = id;
                card.innerHTML = `
                <div class="char-avatar" id="avatar-${id}"></div>
                <div class="char-name" style="color:${char.color};">${char.name}</div>
                <div style="width:100%;margin-top:6px;">
                    <div style="height:10px;width:100%;border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,0.16);background:rgba(0,0,0,0.38);">
                        <div style="height:100%;width:${pct}%;background:linear-gradient(90deg, ${char.color}, ${char.secondaryColor || '#8effff'});"></div>
                    </div>
                    <div style="font-family:Orbitron;font-size:0.58rem;color:#dff6ff;opacity:0.9;margin-top:4px;letter-spacing:0.2px;">${owned}/${req} tarjetas</div>
                </div>
                <div style="font-size:0.66rem;opacity:0.82;margin-top:4px;">${unlocked ? `LVL ${lvl}` : 'BLOQUEADO'}</div>
            `;

                card.onclick = () => {
                    GameData.selectedCharacter = id;
                    if (!unlocked && owned >= req) {
                        unlockCharacter(id);
                        return;
                    }
                    saveGame();
                    renderCharacters();
                    renderGarageDetail(id);
                };

                grid.appendChild(card);
                setTimeout(() => drawCharacterAvatar(id, char), 0);
            });

            if (!GameData.selectedCharacter || !CHARACTERS[GameData.selectedCharacter]) GameData.selectedCharacter = 'blaze';
            renderGarageDetail(GameData.selectedCharacter);
            setTimeout(triggerPendingUnlockReveal, 120);
        };

        unlockCharacter = function unlockCharacterPatched(id) {
            const char = CHARACTERS[id];
            if (!char) return;
            const req = CARD_REQUIREMENTS[char.rarity] || 10;
            const owned = GameData.characterCards[id] || 0;
            if (owned < req) {
                showNotification(`Faltan ${req - owned} tarjetas de ${char.name}`);
                return;
            }
            GameData.characterCards[id] -= req;
            if (!GameData.unlockedCharacters.includes(id)) GameData.unlockedCharacters.push(id);
            if (!GameData.characterLevels[id]) GameData.characterLevels[id] = 1;
            if (!Array.isArray(window.__VS_UNLOCK_QUEUE)) window.__VS_UNLOCK_QUEUE = [];
            window.__VS_UNLOCK_QUEUE.push({ id, ts: Date.now(), source: 'manual' });
            saveGame();
            showNotification(`¡${char.name} desbloqueado!`);
            renderCharacters();
        };

        showCharacterSelect = function showCharacterSelectPatched() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('mapSelect').style.display = 'none';
            const modeScreen = document.getElementById('modeSelectScreen');
            if (modeScreen) modeScreen.style.display = 'none';
            document.getElementById('characterSelect').style.display = 'flex';
            ensureGarageLayout();
            renderCharacters();
        };

        showGarage = function showGaragePatched() {
            showCharacterSelect();
        };

        function ensureModeScreen() {
            if (document.getElementById('modeSelectScreen')) return;
            const screen = document.createElement('div');
            screen.id = 'modeSelectScreen';
            screen.innerHTML = `
            <button class="back-btn" onclick="showCharacterSelect()">← VOLVER</button>
            <h2 class="select-title" style="text-align:center;">SELECCIONA EL MODO</h2>
            <div class="mode-grid" id="modeGrid"></div>
            <div style="width:min(1180px,96vw);margin:12px auto 0;display:flex;justify-content:flex-end;">
                <button class="start-race-btn" onclick="continueToMapSelection()">SIGUIENTE: MAPAS</button>
            </div>
        `;
            document.body.appendChild(screen);
        }

        function renderModeCards() {
            const grid = document.getElementById('modeGrid');
            if (!grid) return;
            grid.innerHTML = '';
            Object.entries(MODES).forEach(([modeId, mode]) => {
                const card = document.createElement('div');
                card.className = `mode-card ${GameData.selectedMode === modeId ? 'active' : ''}`;
                card.onclick = () => selectModeCard(modeId);
                card.innerHTML = `
                <div style="font-family:Orbitron;color:var(--accent-cyan);font-size:1rem;">${mode.name}</div>
                <div style="font-size:0.86rem;opacity:0.8;margin-top:8px;">${mode.desc}</div>
            `;
                grid.appendChild(card);
            });
        }

        selectModeCard = function selectModeCardPatched(modeId) {
            if (!MODES[modeId]) return;
            GameData.selectedMode = modeId;
            saveGame();
            renderModeCards();
        };

        showModeSelect = function showModeSelectPatched() {
            ensureModeScreen();
            if (!GameData.selectedCharacter) {
                showNotification('Selecciona un corredor primero.');
                showCharacterSelect();
                return;
            }
            document.getElementById('characterSelect').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('modeSelectScreen').style.display = 'block';
            renderModeCards();
        };

        continueToMapSelection = function continueToMapSelectionPatched() {
            document.getElementById('modeSelectScreen').style.display = 'none';
            showMapSelect();
        };

        showMaps = function showMapsPatched() {
            showModeSelect();
        };

        showMapSelect = function showMapSelectPatched() {
            if (!GameData.selectedCharacter) {
                showNotification('Selecciona un corredor primero.');
                return;
            }
            document.getElementById('characterSelect').style.display = 'none';
            const modeScreen = document.getElementById('modeSelectScreen');
            if (modeScreen) modeScreen.style.display = 'none';
            document.getElementById('mapSelect').style.display = 'flex';
            renderMaps();
        };

        const baseShowMainMenu = showMainMenu;
        showMainMenu = function showMainMenuPatched() {
            baseShowMainMenu();
            const modeScreen = document.getElementById('modeSelectScreen');
            if (modeScreen) modeScreen.style.display = 'none';
            const sandboxPanel = document.getElementById('sandboxPanel');
            if (sandboxPanel) sandboxPanel.style.display = 'none';
        };

        const baseStartRaceWithCountdown = startRaceWithCountdown;
        startRaceWithCountdown = async function startRaceWithCountdownPatched() {
            if (!gameState.trailer) {
                gameState.mode = GameData.selectedMode || 'CLASSIC';
            }
            await baseStartRaceWithCountdown();
        };

        function ensureSandboxPanel() {
            if (document.getElementById('sandboxPanel')) return;
            const panel = document.createElement('div');
            panel.id = 'sandboxPanel';
            panel.innerHTML = `
            <div style="font-family:Orbitron;color:var(--accent-cyan);font-size:0.74rem;letter-spacing:1.5px;">SANDBOX · CONEXIONES</div>
            <div id="sandboxRows"></div>
        `;
            const gameScreen = document.getElementById('gameScreen');
            if (gameScreen) gameScreen.appendChild(panel);
        }

        function getRacerByKey(key) {
            if (!key) return null;
            if (key === 'player') return gameState.player;
            const idx = Number(String(key).replace('bot', ''));
            if (!Number.isFinite(idx)) return null;
            return gameState.bots[idx] || null;
        }

        toggleSandboxConnection = function toggleSandboxConnectionPatched(key) {
            if (gameState.mode !== 'SANDBOX') return;
            const racer = getRacerByKey(key);
            if (!racer) return;
            racer.disconnected = !racer.disconnected;
            refreshSandboxPanel();
        };

        function refreshSandboxPanel() {
            const panel = document.getElementById('sandboxPanel');
            const rows = document.getElementById('sandboxRows');
            if (!panel || !rows) return;
            if (gameState.mode !== 'SANDBOX' || !gameState.running) {
                panel.style.display = 'none';
                return;
            }
            panel.style.display = 'block';
            const racers = [{ key: 'player', label: 'TU' }].concat(gameState.bots.map((_, i) => ({ key: `bot${i}`, label: `BOT-${i + 1}` })));
            rows.innerHTML = '';
            racers.forEach(r => {
                const target = getRacerByKey(r.key);
                if (!target) return;
                const row = document.createElement('div');
                row.className = 'sandbox-row';
                row.innerHTML = `
                <span style="color:${target.character?.color || '#fff'};font-weight:700;">${r.label}</span>
                <button class="${target.disconnected ? 'off' : ''}" onclick="toggleSandboxConnection('${r.key}')">
                    ${target.disconnected ? 'CONECTAR' : 'DESCONECTAR'}
                </button>
            `;
                rows.appendChild(row);
            });
        }

        const baseInitRace = initRace;
        initRace = function initRacePatched() {
            baseInitRace();
            [gameState.player, ...gameState.bots].forEach(r => { r.disconnected = false; });
            refreshSandboxPanel();
        };

        function getBlazeProfile(racer) {
            const lvl = Math.max(1, Number(racer?.level || 1));
            const projectileTier = lvl >= 6 ? 3 : (lvl >= 2 ? 2 : 1); // Primera mejora visible desde nivel 2
            const trapTier = lvl >= 7 ? 3 : (lvl >= 4 ? 2 : 1);
            const turboTier = lvl >= 5 ? 3 : (lvl >= 2 ? 2 : 1);
            return {
                projectileTier,
                trapTier,
                turboTier,
                projectile: projectileTier === 3
                    ? { speed: 34, damage: 790, slow: 1.8, splashDamage: 320, splashRadius: 235, duration: 1.5 }
                    : projectileTier === 2
                        ? { speed: 27, damage: 460, slow: 1.35, splashDamage: 0, splashRadius: 0, duration: 1.45 }
                        : { speed: 21, damage: 290, slow: 1.1, splashDamage: 0, splashRadius: 0, duration: 1.4 },
                trap: trapTier === 3
                    ? { auraDuration: 3, shotsPerSecond: 1, totalShots: 3, shotSpeed: 28, shotDamage: 260, baseSlow: 1.6, duration: 1.45 }
                    : trapTier === 2
                        ? { auraDuration: 2, shotsPerSecond: 1, totalShots: 2, shotSpeed: 24, shotDamage: 205, baseSlow: 1.25, duration: 1.35 }
                        : { auraDuration: 2, shotsPerSecond: 1, totalShots: 2, shotSpeed: 18, shotDamage: 145, baseSlow: 1.0, duration: 1.28 },
                turbo: turboTier === 3
                    ? { duration: 1.52, boost: 2.48, contactDamage: 220, slow: 1.1, pulse: 0.24 }
                    : turboTier === 2
                        ? { duration: 1.38, boost: 2.28, contactDamage: 165, slow: 0.95, pulse: 0.27 }
                        : { duration: 1.24, boost: 2.1, contactDamage: 120, slow: 0.75, pulse: 0.3 }
            };
        }

        function applyCombatImpactResponse(racer, directDamage, extraImpulse = 0) {
            if (!racer) return;
            const stats = racer.character?.stats || { weight: 5, handling: 5, accel: 5 };
            const safeDamage = Math.max(0, Number(directDamage) || 0);
            const safeImpulse = Math.max(0, Number(extraImpulse) || 0);

            // Heavy + good handling reduces effective retroceso.
            const resistance = Math.max(0, Math.min(0.45, (stats.weight * 0.018) + (stats.handling * 0.012)));
            const effectiveDamage = safeDamage * (1 - resistance);
            const impulseFromDamage = Math.max(0, effectiveDamage / 26);
            const totalImpulse = impulseFromDamage + safeImpulse;

            if (totalImpulse > 0) {
                racer.knockbackForce = Math.max(Number(racer.knockbackForce || 0), totalImpulse);
            }

            // Recovery duration: lighter racers recover slower, heavier/handling recover faster.
            const recoveryPower = 180 + (stats.weight * 20) + (stats.handling * 16) + (stats.accel * 8);
            const recoveryDuration = Math.max(0.25, Math.min(2.8, effectiveDamage / Math.max(90, recoveryPower)));
            racer.combatRecoveryMax = Math.max(Number(racer.combatRecoveryMax || 0), recoveryDuration);
            racer.combatRecoveryTimer = Math.max(Number(racer.combatRecoveryTimer || 0), recoveryDuration);
            racer.hitFlashTimer = Math.max(Number(racer.hitFlashTimer || 0), 0.18 + Math.min(0.55, effectiveDamage / 750));
        }

        const baseRacerUpdate = Racer.prototype.update;
        Racer.prototype.update = function patchedRacerUpdate(dt) {
            if (this.disconnected) {
                this.turboActive = false;
                this.item = null;
                this.effects = [];
                this.speed = 0;
                this.vSpeed = 0;
                this.progress = Math.max(0, this.progress - (55 * dt * 60 / 60));
                this.x = this.progress;
                return;
            }
            const progressBeforeTick = Number(this.progress || 0);
            const knockbackBeforeTick = Number(this.knockbackForce || 0);
            const result = baseRacerUpdate.call(this, dt);
            const instantDrop = Math.max(0, progressBeforeTick - Number(this.progress || 0));

            // Anti-teleport hit behavior:
            // if a single frame causes a very large drop, convert it to physical retroceso.
            if (instantDrop >= 55 && knockbackBeforeTick < 1 && !this.finished && !this.eliminated) {
                this.progress = progressBeforeTick;
                applyCombatImpactResponse(this, instantDrop, 0);
            }

            if (this.blazeMineAuraTimer > 0) {
                this.blazeMineAuraTimer = Math.max(0, this.blazeMineAuraTimer - dt);
                this.blazeMineShotCooldown = (this.blazeMineShotCooldown || 0) - dt;

                const spawnBlazeMineShot = () => {
                    if (this.blazeMineShotsRemaining <= 0) return;
                    const owner = this.blazeMineOwner || this;
                    const shot = new Projectile(this.x - 35, this.lane, -1, owner, 'blaze_counterfire', 'burn', '#ff6a2e');
                    shot.speed = this.blazeMineShotSpeed || 16;
                    shot.blazeDamage = this.blazeMineShotDamage || 140;
                    shot.blazeSlow = 0.9;
                    gameState.projectiles.push(shot);

                    this.blazeMineShotsRemaining -= 1;
                    const cadence = Math.max(0.2, Number(this.blazeMineShotCadence || 0.5));
                    this.blazeMineShotCooldown += cadence;

                    const laneHeight = canvas.height / (LANE_COUNT + 1);
                    particles.emit(this.x, laneHeight * (this.lane + 1), 12, '#ff5a2f', 3);
                };

                // 2 bolas por segundo mientras dura el aura (0.5s de cadencia)
                while (this.blazeMineShotsRemaining > 0 && this.blazeMineAuraTimer > 0 && this.blazeMineShotCooldown <= 0) {
                    spawnBlazeMineShot();
                }

                // Si queda una bola extra (última mejora), se dispara al finalizar el aura
                if (this.blazeMineAuraTimer <= 0 && this.blazeMineShotsRemaining > 0 && !this.blazeMineFinalBurstDone) {
                    this.blazeMineFinalBurstDone = true;
                    while (this.blazeMineShotsRemaining > 0) {
                        spawnBlazeMineShot();
                    }
                }
            }

            if (this.characterId === 'blaze' && this.turboActive && !this.finished) {
                this.blazeTurboHitCooldown = Math.max(0, (this.blazeTurboHitCooldown || 0) - dt);
                if (this.blazeTurboHitCooldown <= 0) {
                    const touchDamage = Math.max(100, Number(this.blazeTurboContactDamage || 130));
                    const victims = [gameState.player, ...gameState.bots].filter(r =>
                        r !== this &&
                        !r.finished &&
                        !r.isInvulnerable &&
                        !r.shieldActive &&
                        Math.abs(r.progress - this.progress) < 95 &&
                        Math.abs(r.lane - this.lane) <= 1
                    );
                    if (victims.length > 0) {
                        victims.forEach(v => {
                            v.progress -= touchDamage;
                            v.effects.push({ type: 'slow', duration: Math.max(0.55, Number(this.blazeTurboSlow || 0.8)) });
                            v.knockbackForce = Math.max(v.knockbackForce || 0, 9 + Math.floor(touchDamage / 70));
                            addHitToLog(this, v, 'blaze_turbo_burn');
                        });
                        const laneHeight = canvas.height / (LANE_COUNT + 1);
                        particles.emit(this.x, laneHeight * (this.lane + 1), 18, '#ff8a38', 4);
                        this.blazeTurboHitCooldown = Math.max(0.2, Number(this.blazeTurboPulse || 0.28));
                    }
                }
            }

            if (this.combatRecoveryTimer > 0) {
                const maxRec = Math.max(0.001, Number(this.combatRecoveryMax || this.combatRecoveryTimer));
                const t = Math.max(0, Math.min(1, this.combatRecoveryTimer / maxRec));
                const slowMul = 0.68 + (0.32 * (1 - t));
                this.speed *= slowMul;
                this.vSpeed *= slowMul;
                this.combatRecoveryTimer = Math.max(0, this.combatRecoveryTimer - dt);
                if (this.combatRecoveryTimer <= 0) this.combatRecoveryMax = 0;
            }
            if (this.hitFlashTimer > 0) {
                this.hitFlashTimer = Math.max(0, this.hitFlashTimer - dt);
            }

            return result;
        };

        const baseRacerUseItem = Racer.prototype.useItem;
        Racer.prototype.useItem = function patchedRacerUseItem() {
            if (this.disconnected) return;
            if (this.characterId === 'blaze' && this.item) {
                const consumeItem = (itemType, activeDuration) => {
                    if (this.isPlayer) {
                        this.activeItemType = itemType;
                        this.itemMaxDuration = activeDuration;
                        this.itemActiveTimer = activeDuration;
                    }
                    this.item = null;
                    updateItemDisplay();
                };
                const profile = getBlazeProfile(this);

                if (this.item.type === 'projectile') {
                    const fireball = new Projectile(this.x + 52, this.lane, 1, this, 'blaze_fireball', 'burn', '#ff6f2f');
                    fireball.speed = profile.projectile.speed;
                    fireball.blazeDamage = profile.projectile.damage;
                    fireball.blazeSlow = profile.projectile.slow;
                    fireball.blazeSplashDamage = profile.projectile.splashDamage;
                    fireball.blazeSplashRadius = profile.projectile.splashRadius;
                    gameState.projectiles.push(fireball);
                    consumeItem('projectile', profile.projectile.duration);
                    return;
                }

                if (this.item.type === 'trap') {
                    // Rework: no deja mina inmovil.
                    // Blaze activa un "escudo visual rojo" sobre si mismo y dispara fuego mientras corre.
                    this.blazeMineAuraTimer = profile.trap.auraDuration;
                    this.blazeMineShotsRemaining = profile.trap.totalShots;
                    this.blazeMineShotTotal = profile.trap.totalShots;
                    this.blazeMineShotCooldown = 0;
                    this.blazeMineShotSpeed = profile.trap.shotSpeed;
                    this.blazeMineShotDamage = profile.trap.shotDamage;
                    this.blazeMineShotCadence = Math.max(0.2, 1 / Math.max(1, profile.trap.shotsPerSecond));
                    this.blazeMineFinalBurstDone = false;
                    this.blazeMineOwner = this;
                    consumeItem('trap', profile.trap.duration);
                    return;
                }

                if (this.item.type === 'turbo') {
                    const turboDuration = profile.turbo.duration;
                    this.turboActive = true;
                    this.activeTurboBoost = profile.turbo.boost;
                    this.blazeTurboHitCooldown = 0;
                    this.blazeTurboContactDamage = profile.turbo.contactDamage;
                    this.blazeTurboSlow = profile.turbo.slow;
                    this.blazeTurboPulse = profile.turbo.pulse;
                    if (this.isPlayer) updateMissionProgress('use_turbo');

                    setTimeout(() => {
                        this.turboActive = false;
                        this.activeTurboBoost = 0;
                        this.blazeTurboContactDamage = 0;
                    }, turboDuration * 1000);

                    consumeItem('turbo', turboDuration);
                    return;
                }
            }
            return baseRacerUseItem.call(this);
        };

        const baseProjectileApplyEffect = Projectile.prototype.applyEffect;
        Projectile.prototype.applyEffect = function patchedProjectileApplyEffect(racer) {
            if (this.effect === 'blaze_fireball' || this.effect === 'blaze_counterfire') {
                if (racer.shieldActive || racer.isInvulnerable || racer.intangibleTimer > 0) {
                    if (racer.shieldActive) {
                        racer.shieldActive = false;
                        addHitToLog(this.owner, racer, 'shield');
                    }
                    this.active = false;
                    return;
                }

                addHitToLog(this.owner, racer, this.effect);
                if (racer.isPlayer) {
                    gameState.cameraShake = 10;
                    gameState.hitFlash = 0.32;
                }

                const ownerLvl = Math.max(1, Number(this.owner?.projectileLevel || 1));
                const directDamage = Math.max(100, Math.floor(Number(this.blazeDamage || (220 + ownerLvl * 120))));
                racer.effects.push({ type: 'slow', duration: Math.max(0.8, Number(this.blazeSlow || 1.25)) });
                applyCombatImpactResponse(racer, directDamage, 8 + (ownerLvl * 3));

                if (this.effect === 'blaze_fireball' && Number(this.blazeSplashDamage || 0) > 0) {
                    const splashDamage = Math.floor(Number(this.blazeSplashDamage || 0));
                    const splashRadius = Math.max(120, Number(this.blazeSplashRadius || 160));
                    [gameState.player, ...gameState.bots].forEach(v => {
                        if (v === racer || v === this.owner || v.isInvulnerable || v.shieldActive) return;
                        if (Math.abs(v.x - racer.x) > splashRadius) return;
                        if (Math.abs(v.lane - racer.lane) > 1) return;
                        v.effects.push({ type: 'slow', duration: 0.75 });
                        applyCombatImpactResponse(v, splashDamage, 6);
                        addHitToLog(this.owner, v, 'blaze_splash');
                    });
                }

                const laneHeight = canvas.height / (LANE_COUNT + 1);
                particles.emit(racer.x, laneHeight * (racer.lane + 1), this.effect === 'blaze_fireball' ? 24 : 12, '#ff7b2e', 4);
                this.active = false;
                return;
            }
            return baseProjectileApplyEffect.call(this, racer);
        };

        const baseProjectileApplyEffectCombat = Projectile.prototype.applyEffect;
        Projectile.prototype.applyEffect = function patchedProjectileCombatResponse(racer) {
            const prevProgress = Number(racer?.progress || 0);
            const prevKB = Number(racer?.knockbackForce || 0);
            const out = baseProjectileApplyEffectCombat.call(this, racer);
            if (!racer) return out;
            if (this.effect === 'blaze_fireball' || this.effect === 'blaze_counterfire') return out;

            const instantLoss = Math.max(0, prevProgress - Number(racer.progress || 0));
            const kbGain = Math.max(0, Number(racer.knockbackForce || 0) - prevKB);
            if (instantLoss > 0) {
                racer.progress = prevProgress;
                applyCombatImpactResponse(racer, instantLoss, kbGain);
            } else if (kbGain > 0) {
                applyCombatImpactResponse(racer, 0, kbGain);
            }
            return out;
        };

        const baseTrapApplyEffect = Trap.prototype.applyEffect;
        Trap.prototype.applyEffect = function patchedTrapApplyEffect(racer) {
            if (this.effect === 'blaze_mine') {
                if (racer.shieldActive || racer.isInvulnerable || racer.intangibleTimer > 0) {
                    if (racer.shieldActive) {
                        racer.shieldActive = false;
                        addHitToLog(this.owner, racer, 'shield');
                    }
                    this.active = false;
                    return;
                }

                addHitToLog(this.owner, racer, 'blaze_mine');
                if (racer.isPlayer) {
                    gameState.cameraShake = 12;
                    gameState.hitFlash = 0.4;
                }

                const trapLvl = Math.max(1, Number(this.owner?.trapLevel || 1));
                racer.blazeMineAuraTimer = Number(this.blazeAuraDuration || (trapLvl >= 3 ? 3 : 2));
                racer.blazeMineShotsRemaining = Math.max(2, Math.floor(Number(this.blazeCounterShots || (trapLvl >= 3 ? 3 : 2))));
                racer.blazeMineShotTotal = racer.blazeMineShotsRemaining;
                racer.blazeMineShotCooldown = 0;
                racer.blazeMineShotSpeed = Math.max(14, Number(this.blazeCounterSpeed || (trapLvl >= 2 ? 21 : 16)));
                racer.blazeMineShotDamage = Math.max(120, Number(this.blazeCounterDamage || (trapLvl >= 3 ? 240 : (trapLvl === 2 ? 190 : 140))));
                racer.blazeMineShotCadence = Math.max(0.2, Number(this.blazeShotCadence || 0.5));
                racer.blazeMineFinalBurstDone = false;
                racer.blazeMineOwner = this.owner || null;
                racer.effects.push({ type: 'slow', duration: Math.max(0.9, Number(this.blazeTrapSlow || (0.8 + (trapLvl * 0.35)))) });
                applyCombatImpactResponse(racer, 170 + trapLvl * 65, 12 + (trapLvl * 4));

                const laneHeight = canvas.height / (LANE_COUNT + 1);
                particles.emit(racer.x, laneHeight * (racer.lane + 1), 16, '#ff4d2d', 4);
                this.active = false;
                return;
            }
            return baseTrapApplyEffect.call(this, racer);
        };

        const baseTrapApplyEffectCombat = Trap.prototype.applyEffect;
        Trap.prototype.applyEffect = function patchedTrapCombatResponse(racer) {
            const prevProgress = Number(racer?.progress || 0);
            const prevKB = Number(racer?.knockbackForce || 0);
            const out = baseTrapApplyEffectCombat.call(this, racer);
            if (!racer) return out;
            if (this.effect === 'blaze_mine') return out;

            const instantLoss = Math.max(0, prevProgress - Number(racer.progress || 0));
            const kbGain = Math.max(0, Number(racer.knockbackForce || 0) - prevKB);
            if (instantLoss > 0) {
                racer.progress = prevProgress;
                applyCombatImpactResponse(racer, instantLoss, kbGain);
            } else if (kbGain > 0) {
                applyCombatImpactResponse(racer, 0, kbGain);
            }
            return out;
        };

        const baseRacerDraw = Racer.prototype.draw;
        Racer.prototype.draw = function patchedRacerDraw(ctx, cameraX) {
            baseRacerDraw.call(this, ctx, cameraX);
            const screenX = this.x - cameraX + canvas.width * 0.3;
            const laneHeight = canvas.height / (LANE_COUNT + 1);
            const y = this.y || (laneHeight * (this.lane + 1));

            if (this.hitFlashTimer > 0) {
                ctx.save();
                const p = Math.max(0, Math.min(1, this.hitFlashTimer / 0.7));
                ctx.strokeStyle = `rgba(255, 80, 80, ${0.25 + p * 0.45})`;
                ctx.lineWidth = 2.4 + p * 2;
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#ff6464';
                ctx.beginPath();
                ctx.arc(screenX, y, 28 + p * 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            if (this.blazeMineAuraTimer > 0) {
                ctx.save();
                const pulse = 0.55 + (Math.sin(Date.now() / 120) * 0.45);
                const bubble = ctx.createRadialGradient(screenX, y, 8, screenX, y, 42 + (pulse * 10));
                bubble.addColorStop(0, 'rgba(255,70,50,0.08)');
                bubble.addColorStop(0.6, 'rgba(255,55,40,0.16)');
                bubble.addColorStop(1, 'rgba(255,30,20,0)');
                ctx.fillStyle = bubble;
                ctx.beginPath();
                ctx.arc(screenX, y, 39 + (pulse * 8), 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 80, 50, ${0.25 + pulse * 0.35})`;
                ctx.lineWidth = 2 + pulse * 2;
                ctx.shadowBlur = 16;
                ctx.shadowColor = '#ff4d2e';
                ctx.beginPath();
                ctx.arc(screenX, y, 38 + (pulse * 6), 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            if (this.characterId === 'blaze' && this.turboActive) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (let i = 0; i < 4; i++) {
                    const jitter = (Math.random() - 0.5) * 4;
                    const len = 26 + (i * 7);
                    ctx.fillStyle = i % 2 === 0 ? 'rgba(255,130,40,0.55)' : 'rgba(255,70,20,0.45)';
                    ctx.beginPath();
                    ctx.moveTo(screenX - 20 - i * 2, y + jitter);
                    ctx.lineTo(screenX - len, y - 8 + jitter);
                    ctx.lineTo(screenX - len - 8, y + jitter);
                    ctx.lineTo(screenX - len, y + 8 + jitter);
                    ctx.closePath();
                    ctx.fill();
                }
                const ringPulse = 0.55 + Math.sin(Date.now() / 90) * 0.45;
                ctx.strokeStyle = `rgba(255,120,40,${0.35 + ringPulse * 0.25})`;
                ctx.lineWidth = 3.5;
                ctx.beginPath();
                ctx.arc(screenX, y, 34 + ringPulse * 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        };

        const baseProjectileDraw = Projectile.prototype.draw;
        Projectile.prototype.draw = function patchedProjectileDraw(ctx, cameraX) {
            if (this.effect !== 'blaze_fireball' && this.effect !== 'blaze_counterfire') {
                return baseProjectileDraw.call(this, ctx, cameraX);
            }
            const screenX = this.x - cameraX + canvas.width * 0.3;
            if (screenX < -130 || screenX > canvas.width + 130) return;
            const laneHeight = canvas.height / (LANE_COUNT + 1);
            const y = laneHeight * (this.lane + 1);
            const isMain = this.effect === 'blaze_fireball';
            const core = isMain ? 14 : 9;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = 'rgba(255,90,25,0.3)';
            for (let i = 0; i < 4; i++) {
                const tx = screenX - (this.direction * (12 + i * 13));
                const ty = y + Math.sin(Date.now() / 90 + i) * (isMain ? 2.2 : 1.4);
                const rx = Math.max(0.8, (core - i * 2.1));
                const ry = Math.max(0.8, (core - i * 3.3));
                ctx.beginPath();
                ctx.ellipse(tx, ty, rx, ry, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            const g = ctx.createRadialGradient(screenX, y, 1, screenX, y, core * 2.6);
            g.addColorStop(0, '#fff7d6');
            g.addColorStop(0.35, '#ffb347');
            g.addColorStop(0.75, '#ff5f2e');
            g.addColorStop(1, 'rgba(255,70,10,0)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(screenX, y, core * 1.75, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(screenX + 2, y - 1, Math.max(2.5, core * 0.35), 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        };

        const baseTrapDraw = Trap.prototype.draw;
        Trap.prototype.draw = function patchedTrapDraw(ctx, cameraX) {
            if (this.effect !== 'blaze_mine') {
                return baseTrapDraw.call(this, ctx, cameraX);
            }
            if (!this.active) return;
            const screenX = this.x - cameraX + canvas.width * 0.3;
            const laneHeight = canvas.height / (LANE_COUNT + 1);
            const y = laneHeight * (this.lane + 1);
            const pulse = 0.55 + Math.sin(Date.now() / 130) * 0.45;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = 'rgba(255, 60, 20, 0.28)';
            ctx.beginPath();
            ctx.arc(screenX, y + 24, 24 + pulse * 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#271109';
            ctx.strokeStyle = '#ff5f2e';
            ctx.lineWidth = 2.2;
            ctx.beginPath();
            ctx.arc(screenX, y + 24, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#ffb347';
            for (let i = 0; i < 6; i++) {
                const ang = (Math.PI * 2 / 6) * i + Date.now() / 600;
                const px = screenX + Math.cos(ang) * 9;
                const py = y + 24 + Math.sin(ang) * 9;
                ctx.beginPath();
                ctx.arc(px, py, 1.8, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        };

        const baseUseTypedItem = useTypedItem;
        useTypedItem = function patchedUseTypedItem(type) {
            if (gameState.mode === 'SANDBOX' && gameState.player?.disconnected) {
                showNotification('Reconecta tu corredor para usar items.');
                return;
            }
            return baseUseTypedItem(type);
        };

        renderProgressDotModel = function renderProgressDotModelPatched(dot, racer) {
            const key = `${racer.characterId}_${racer.disconnected ? 'off' : 'on'}`;
            if (dot.dataset.modelKey !== key) {
                dot.dataset.modelKey = key;
                dot.innerHTML = '';
                const c = document.createElement('canvas');
                c.width = 34;
                c.height = 34;
                renderRacerModel(c.getContext('2d'), racer.characterId, 17, 17, 0.42, CHARACTERS[racer.characterId] || { color: '#fff', secondaryColor: '#bbb' });
                dot.appendChild(c);
            }
            dot.style.filter = racer.disconnected ? 'grayscale(1) brightness(0.65)' : 'none';
            dot.style.opacity = racer.disconnected ? '0.78' : '1';
        };

        showEvents = function showEventsPatched() {
            const now = new Date();
            const currentEvt = (window.__VS_GET_CURRENT_EVENT && window.__VS_GET_CURRENT_EVENT(now)) || null;
            const fallbackEvt = currentEvt || ((window.__VS_GET_NEXT_EVENT && window.__VS_GET_NEXT_EVENT(now)) || null);
            activeEvent = currentEvt ? currentEvt.id : null;

            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('eventsScreen').style.display = 'block';

            const hero = document.getElementById('evtHero');
            const badge = document.getElementById('evtBadge');
            const title = document.getElementById('evtTitle');
            const desc = document.getElementById('evtDesc');
            const timeline = document.getElementById('evtTimeline');
            const evtCountdown = document.getElementById('evtCountdown');
            const offersPanel = document.getElementById('evtOffersPanel');

            if (!fallbackEvt) {
                badge.textContent = 'SIN EVENTO';
                title.textContent = 'No hay eventos cargados';
                desc.textContent = 'Vuelve pronto para mas temporadas.';
                timeline.innerHTML = '';
                evtCountdown.style.display = 'none';
                offersPanel.style.display = 'none';
                return;
            }

            hero.style.background = fallbackEvt.bgGradient;
            badge.textContent = currentEvt ? 'ACTIVO' : 'PROXIMO';
            badge.style.background = fallbackEvt.color;
            badge.style.color = '#000';
            title.textContent = fallbackEvt.name;
            title.style.color = fallbackEvt.color;
            desc.textContent = fallbackEvt.description;

            const featured = CHARACTERS[fallbackEvt.featuredRacer];
            if (featured) {
                const evtCvs = document.getElementById('evtRacerCvs');
                const evtCtx = evtCvs.getContext('2d');
                evtCtx.clearRect(0, 0, evtCvs.width, evtCvs.height);
                renderRacerModel(evtCtx, fallbackEvt.featuredRacer, 75, 75, 1.8, featured);
                document.getElementById('evtRacerName').textContent = featured.name;
                document.getElementById('evtRacerRarity').textContent = getRarityName(featured.rarity).toUpperCase();
                document.getElementById('evtRacerRarity').style.background = featured.color;
                document.getElementById('evtRacerRarity').style.color = '#000';
            }

            if (_evtCountdownInterval) clearInterval(_evtCountdownInterval);
            _updateEvtCountdown((currentEvt || fallbackEvt).endDate);
            _evtCountdownInterval = setInterval(() => _updateEvtCountdown((currentEvt || fallbackEvt).endDate), 1000);
            evtCountdown.style.display = 'flex';

            timeline.innerHTML = '';
            EVENTS_CALENDAR.forEach(evt => {
                const el = document.createElement('div');
                const isActive = currentEvt && evt.id === currentEvt.id;
                el.className = `tl-item ${isActive ? 'tl-active' : ''}`;
                el.style.background = 'rgba(255,255,255,0.03)';
                el.style.border = `1px solid ${isActive ? evt.color : 'rgba(255,255,255,0.1)'}`;
                el.innerHTML = `
                <div class="tl-dot" style="background:${evt.color};box-shadow:0 0 10px ${evt.color};"></div>
                <div style="flex:1;">
                    <div style="font-family:Orbitron;font-size:0.75rem;color:#fff;">${evt.shortName}</div>
                    <div style="font-size:0.7rem;opacity:0.7;">${evt.startDate.toLocaleDateString()} - ${evt.endDate.toLocaleDateString()}</div>
                </div>
            `;
                timeline.appendChild(el);
            });

            if (currentEvt) {
                _renderEventOffers(currentEvt, now);
                checkEventReset();
                renderEventMissions();
                renderEventTargetSelector(currentEvt);
            } else {
                offersPanel.style.display = 'none';
                const list = document.getElementById('eventMissionList');
                if (list) list.innerHTML = '<div style="opacity:0.7;padding:10px;">No hay misiones activas hasta que comience el proximo evento.</div>';
                renderEventTargetSelector(fallbackEvt);
            }
        };

        function renderEventTargetSelector(evt) {
            const missionList = document.getElementById('eventMissionList');
            if (!missionList || !evt) return;
            let host = document.getElementById('eventRacerSelector');
            if (!host) {
                host = document.createElement('div');
                host.id = 'eventRacerSelector';
                host.className = 'event-racer-selector';
                missionList.parentElement.insertBefore(host, missionList);
            }
            const racers = evt.racers || [evt.featuredRacer];
            if (!GameData.eventTargetRacer || !racers.includes(GameData.eventTargetRacer)) {
                GameData.eventTargetRacer = racers[0];
                saveGame();
            }
            host.innerHTML = racers.map(r => {
                const c = CHARACTERS[r];
                if (!c) return '';
                const activeCls = GameData.eventTargetRacer === r ? 'active' : '';
                return `<button class="event-racer-chip ${activeCls}" onclick="selectEventTargetRacer('${r}')">${c.name}</button>`;
            }).join('');
        }

        selectEventTargetRacer = function selectEventTargetRacerPatched(racerId) {
            GameData.eventTargetRacer = racerId;
            saveGame();
            const evt = (window.__VS_GET_CURRENT_EVENT && window.__VS_GET_CURRENT_EVENT()) || (window.__VS_GET_NEXT_EVENT && window.__VS_GET_NEXT_EVENT());
            if (evt) renderEventTargetSelector(evt);
            renderEventMissions();
        };

        resetEventMissions = function resetEventMissionsPatched(isPaid) {
            if (!isPaid) GameData.missionResetCost = 100;
            GameData.lastMissionResetTime = Date.now();
            const evt = window.__VS_GET_CURRENT_EVENT ? window.__VS_GET_CURRENT_EVENT() : null;
            if (!evt) {
                GameData.eventMissions = [];
                saveGame();
                renderEventMissions();
                return;
            }
            const rewardRacer = GameData.eventTargetRacer || evt.featuredRacer;
            const pool = [
                { txt: 'Gana 1 carrera', goal: 1, id: 'win_race', rewardCards: 8, rarity: 'rare' },
                { txt: 'Termina 2 veces en Top 2', goal: 2, id: 'top_2_ko', rewardCards: 10, rarity: 'rare' },
                { txt: 'Golpea a 12 rivales', goal: 12, id: 'hit_opponents', rewardCards: 9, rarity: 'epic' },
                { txt: 'Recoge 20 cajas', goal: 20, id: 'collect_items', rewardCards: 7, rarity: 'rare' },
                { txt: 'Usa 6 turbos', goal: 6, id: 'use_turbo', rewardCards: 8, rarity: 'rare' },
                { txt: 'Juega una carrera en el mapa del evento', goal: 1, id: 'race_event_map', rewardCards: 11, rarity: 'epic' }
            ];
            GameData.eventMissions = pool.sort(() => 0.5 - Math.random()).slice(0, 3).map(m => ({
                ...m,
                progress: 0,
                completed: false,
                rewardRacer
            }));
            saveGame();
            renderEventMissions();
            const resetCost = document.getElementById('resetCostDisplay');
            if (resetCost) resetCost.textContent = GameData.missionResetCost;
        };

        renderEventMissions = function renderEventMissionsPatched() {
            const list = document.getElementById('eventMissionList');
            if (!list) return;
            if (!Array.isArray(GameData.eventMissions) || GameData.eventMissions.length === 0) resetEventMissions(false);
            const missions = GameData.eventMissions || [];
            list.innerHTML = '';
            missions.forEach(m => {
                const char = CHARACTERS[m.rewardRacer];
                const row = document.createElement('div');
                row.style.cssText = 'background:rgba(0,0,0,0.35);border:1px solid rgba(255,255,255,0.09);padding:10px;border-radius:10px;display:flex;justify-content:space-between;gap:12px;align-items:center;';
                row.innerHTML = `
                <div>
                    <div style="font-weight:700;">${m.txt}</div>
                    <div style="font-size:0.72rem;opacity:0.75;">Cofre objetivo: <span style="color:${char?.color || '#fff'}">${char?.name || 'Corredor'}</span></div>
                </div>
                <div style="font-family:Orbitron;color:${m.completed ? '#00ff88' : '#fff'};">${m.progress}/${m.goal} ${m.completed ? '✔' : ''}</div>
            `;
                list.appendChild(row);
            });
            const resetCost = document.getElementById('resetCostDisplay');
            if (resetCost) resetCost.textContent = GameData.missionResetCost || 100;
        };

        openEventRewardModal = function openEventRewardModalPatched(mission) {
            const rewardRacer = mission.rewardRacer || GameData.eventTargetRacer || ELEMENTAL_EVENT_RACERS[0];
            awardChest(`event_chest_${rewardRacer}`, false, mission);
        };

        const baseEndRace = endRace;
        endRace = function endRacePatched(position) {
            if (gameState.mode === 'SANDBOX') {
                gameState.running = false;
                cancelAnimationFrame(animationId);
                document.getElementById('gameScreen').style.display = 'none';

                const results = document.getElementById('resultsScreen');
                results.style.display = 'flex';
                document.getElementById('resultsTitle').textContent = '🧪 SANDBOX FINALIZADO';
                document.getElementById('resultsPosition').textContent = position === 1 ? '🏁' : `${position}°`;

                const noRewardHtml = `
                    <div class="reward-item" style="margin-bottom: 10px;">Modo libre sin recompensas</div>
                    <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 15px 0; padding-top: 15px; opacity:0.85;">
                        <h4 style="color: var(--accent-cyan); margin-bottom: 10px;">SANDBOX</h4>
                        <p style="font-size:0.9rem;">No se entregan XP, VoltBits, cofres ni progreso de misiones en este modo.</p>
                    </div>
                `;
                document.querySelector('.rewards').innerHTML = noRewardHtml;
                return;
            }

            const evt = (window.__VS_GET_CURRENT_EVENT && window.__VS_GET_CURRENT_EVENT()) || null;
            if (evt && evt.mapOverride && GameData.selectedMap === evt.mapOverride) {
                updateMissionProgress('race_event_map', 1, true);
            }
            return baseEndRace(position);
        };

        ensureModeScreen();
        ensureGarageLayout();
        ensureSandboxPanel();
        const mapBackBtn = document.querySelector('#mapSelect .back-btn');
        if (mapBackBtn) mapBackBtn.onclick = showModeSelect;
        renderCharacters();
        updateVoltBitsDisplay();
        if (oceanPayState.token) {
            syncOceanPayLinkState();
        }
    })();
</script>
</body>
<!-- Ocean Pay UI Elements -->
<div id="oceanPayLoader"
    style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:9999; flex-direction:column; align-items:center; justify-content:center;">
    <div
        style="font-family:'Orbitron'; color:var(--accent-cyan); font-size:1.5rem; margin-bottom:20px; letter-spacing: 2px;">
        PROCESANDO PAGO...</div>
    <div
        style="border: 4px solid rgba(0, 229, 255, 0.1); border-top: 4px solid var(--accent-cyan); border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite;">
    </div>
    <p style="color:#888; margin-top:20px; font-family:'Orbitron'; font-size: 0.8rem;">Conectando con Ocean Pay Secure
        Gateway</p>
    
</div>

<!-- Integrated Ocean Pay Modal -->
<div id="oceanPayIntegratedModal"
    style="display:none; position:fixed; inset:0; z-index:10000; background:rgba(0,0,0,0.9); align-items:center; justify-content:center; flex-direction: column; font-family:'Rajdhani', sans-serif;">
    <div
        style="width:100%; max-width:450px; background: #0a0a1a; border-radius: 20px; border: 2px solid var(--accent-cyan); padding: 2.5rem; position: relative; box-shadow: 0 0 80px rgba(0, 247, 255, 0.3); overflow:hidden;">
        <!-- Glow Effect -->
        <div
            style="position:absolute; top:-50px; left:-50px; width:150px; height:150px; background:var(--accent-cyan); filter:blur(100px); opacity:0.2; pointer-events:none;">
        </div>

        <button onclick="closeOceanPay()"
            style="position:absolute; top:20px; right:20px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:white; width: 35px; height: 35px; border-radius: 50%; display:flex; align-items:center; justify-content:center; cursor:pointer; font-weight:bold; transition:all 0.2s; z-index:10;">✕</button>

        <div style="text-align:center; margin-bottom:2.5rem;">
            <h2 style="font-family:'Orbitron'; color:var(--accent-cyan); letter-spacing:4px; margin-bottom:5px;">OCEAN
                PAY</h2>
            <div style="height:2px; width:60px; background:var(--accent-cyan); margin:0 auto 15px;"></div>
            <p style="color:#888; font-size:0.8rem; letter-spacing:2px; text-transform:uppercase;">Pasarela de Pago
                Segura</p>
        </div>

        <!-- Section: Initial View (Tabs) -->
        <div id="opLoginSection" style="display:flex; flex-direction:column; gap:1.5rem;">
            <div style="display:flex; background:rgba(255,255,255,0.03); border-radius:12px; padding:5px; gap:5px;">
                <button onclick="showOpSubTab('credentials')" id="btnTabCred"
                    class="op-tab-btn active">Credenciales</button>
                <button onclick="showOpSubTab('card')" id="btnTabCard" class="op-tab-btn">Tarjeta Directa</button>
            </div>

            <!-- TAB: Credentials -->
            <div id="opSubTabCredentials" style="display:flex; flex-direction:column; gap:1.2rem;">
                <div style="display:flex; flex-direction:column; gap:5px;">
                    <label style="font-size:0.7rem; color:#888; margin-left:5px;">NOMBRE DE USUARIO</label>
                    <input type="text" id="opUser" placeholder="ej. oceanandwild"
                        style="padding:15px; background:rgba(255,255,255,0.05); border:1px solid #333; color:white; border-radius:12px; font-family:'Orbitron'; outline:none; transition:border-color 0.2s;">
                </div>
                <div style="display:flex; flex-direction:column; gap:5px;">
                    <label style="font-size:0.7rem; color:#888; margin-left:5px;">CONTRASEÑA</label>
                    <input type="password" id="opPass" placeholder="••••••••"
                        style="padding:15px; background:rgba(255,255,255,0.05); border:1px solid #333; color:white; border-radius:12px; font-family:'Orbitron'; outline:none;">
                </div>
                <button id="opLoginBtn" onclick="opLogin()" class="menu-btn"
                    style="min-width:0; width:100%; margin-top:0.5rem;">AUTORIZAR PAGO</button>
                <p style="font-size:0.7rem; color:#666; text-align:center;">Tus datos serán guardados de forma segura en
                    este dispositivo.</p>
            </div>

            <!-- TAB: Direct Card -->
            <div id="opSubTabCard" style="display:none; flex-direction:column; gap:1.2rem;">
                <div style="display:flex; flex-direction:column; gap:5px;">
                    <label style="font-size:0.7rem; color:#888; margin-left:5px;">NÚMERO DE TARJETA</label>
                    <input type="text" id="opCardNum" placeholder="4000 0000 0000 0000" maxlength="16"
                        style="padding:15px; background:rgba(255,255,255,0.05); border:1px solid #333; color:white; border-radius:12px; font-family:'Orbitron'; outline:none; letter-spacing:2px;">
                </div>
                <div style="display:flex; gap:15px;">
                    <div style="flex:1; display:flex; flex-direction:column; gap:5px;">
                        <label style="font-size:0.7rem; color:#888; margin-left:5px;">EXP (MM/AA)</label>
                        <input type="text" id="opCardExp" placeholder="12/28" maxlength="5"
                            style="padding:15px; background:rgba(255,255,255,0.05); border:1px solid #333; color:white; border-radius:12px; font-family:'Orbitron'; outline:none; text-align:center;">
                    </div>
                    <div style="flex:1; display:flex; flex-direction:column; gap:5px;">
                        <label style="font-size:0.7rem; color:#888; margin-left:5px;">CVV</label>
                        <input type="text" id="opCardCvv" placeholder="123" maxlength="3"
                            style="padding:15px; background:rgba(255,255,255,0.05); border:1px solid #333; color:white; border-radius:12px; font-family:'Orbitron'; outline:none; text-align:center;">
                    </div>
                </div>
                <button id="opCardPayBtn" onclick="opCardPay()" class="menu-btn"
                    style="min-width:0; width:100%; border-color:var(--accent-gold); color:var(--accent-gold); margin-top:0.5rem;">PAGAR
                    CON TARJETA</button>
                <p style="font-size:0.7rem; color:#666; text-align:center;">Pago único. La tarjeta no se guardará sin
                    una cuenta.</p>
            </div>

            <p id="opMsg" style="color:var(--accent-pink); font-size:0.9rem; text-align:center; font-weight:bold;"></p>
        </div>

        <!-- Section: Logged In / Checkout -->
        <div id="opCheckoutSection" style="display:none; flex-direction:column; gap:1.5rem;">
            <div
                style="background:rgba(0, 247, 255, 0.05); padding:1.2rem; border-radius:15px; border:1px solid rgba(0, 247, 255, 0.2);">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <p id="opWelcomeUser" style="color:var(--accent-cyan); font-weight:bold; font-size:0.9rem;"></p>
                    <button onclick="disconnectOceanPay();"
                        style="background:transparent; border:none; color:#666; font-size:0.7rem; cursor:pointer; text-decoration:underline;">Cambiar
                        Usuario</button>
                </div>
                <div style="margin-top:1.2rem; text-align:center;">
                    <p style="font-size:0.7rem; color:#888; letter-spacing:1px;">TOTAL A PAGAR</p>
                    <h2 style="font-family:'Orbitron'; color:var(--accent-gold); font-size:2.5rem; margin:5px 0;"><span
                            id="opCheckoutAmount">0</span></h2>
                    <p style="font-size:0.8rem; color:var(--accent-gold); letter-spacing:2px;">VOLTBITS</p>
                    <p id="opCheckoutConcept" style="font-size:0.9rem; color:#aaa; margin-top:10px; font-style:italic;">
                    </p>
                </div>
            </div>

            <div style="display:flex; flex-direction:column; gap:10px;">
                <h4
                    style="font-family:'Orbitron'; font-size:0.8rem; color:var(--accent-cyan); display:flex; align-items:center; gap:8px;">
                    <i class="fas fa-credit-card"></i> SELECCIONA TU TARJETA
                </h4>
                <div id="opCardList"
                    style="display:flex; flex-direction:column; gap:0.8rem; max-height:220px; overflow-y:auto; padding-right:8px; scrollbar-width: thin; scrollbar-color: var(--accent-cyan) transparent;">
                    <!-- Cards injected here -->
                </div>
            </div>
        </div>
    </div>
</div>





</html>


